<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Trench Warfare FPS</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; font-family: sans-serif; user-select: none; }
        #game-canvas { width: 100%; height: 100%; display: block; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: rgba(255, 255, 255, 0.7); font-size: 24px; font-weight: bold; }
        #action-prompt { position: absolute; bottom: 150px; left: 50%; transform: translateX(-50%); color: white; font-size: 20px; font-weight: bold; background: rgba(0, 0, 0, 0.6); padding: 10px 20px; border: 2px solid #333; display: none; }
        #healthbar-container { position: absolute; bottom: 30px; left: 30px; width: 300px; height: 25px; background: rgba(0, 0, 0, 0.6); border: 2px solid #333; }
        #healthbar { width: 100%; height: 100%; background: #00aa00; transition: width 0.2s; }
        #heatbar-container { position: absolute; bottom: 60px; left: 30px; width: 300px; height: 10px; background: rgba(0, 0, 0, 0.6); border: 2px solid #333; display: none; }
        #heatbar { width: 0%; height: 100%; background: #ff8800; transition: width 0.1s; }
        #weapon-indicator { position: absolute; bottom: 30px; right: 30px; color: white; font-size: 24px; font-weight: bold; background: rgba(0, 0, 0, 0.6); padding: 10px 20px; border: 2px solid #333; }
        #kill-count-indicator { position: absolute; bottom: 90px; right: 30px; color: white; font-size: 20px; font-weight: bold; background: rgba(0, 0, 0, 0.6); padding: 8px 16px; border: 2px solid #333; }
        #reserves-indicator { position: absolute; top: 30px; right: 30px; color: white; font-size: 20px; font-weight: bold; background: rgba(0, 0, 0, 0.6); padding: 8px 16px; border: 2px solid #333; display: none; }
        #scope-overlay { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; background: radial-gradient(circle, transparent 35%, rgba(0,0,0,0.9) 55%, black 100%); align-items: center; justify-content: center; }
        .scope-line-h { width: 100%; height: 2px; background: rgba(0,0,0,0.8); position: absolute; }
        .scope-line-v { width: 2px; height: 100%; background: rgba(0,0,0,0.8); position: absolute; }
        .scope-dot { width: 4px; height: 4px; background: red; border-radius: 50%; position: absolute; }
        #instructions { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); color: white; display: flex; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; z-index: 10; }
        .menu-btn { background: #333; color: #fff; border: 2px solid #555; padding: 12px 24px; font-size: 18px; font-weight: bold; cursor: pointer; transition: 0.2s; border-radius: 4px; font-family: sans-serif; }
        .menu-btn:hover { background: #555; border-color: #888; }
        #victory-screen { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 50, 0, 0.85); color: white; z-index: 20; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; }
        .inst-text { max-width: 600px; text-align: center; line-height: 1.6; font-size: 18px; }
        #hurt-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: red; opacity: 0; transition: opacity 0.1s; }
        #hit-marker { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; border-top: 2px solid white; border-right: 2px solid white; opacity: 0; transform-origin: center; transform: translate(-50%, -50%) rotate(45deg); transition: opacity 0.1s; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="ui">
        <div id="hurt-overlay"></div>
        <div id="scope-overlay"><div class="scope-line-h"></div><div class="scope-line-v"></div><div class="scope-dot"></div></div>
        <div id="crosshair">+</div>
        <div id="action-prompt">Press T to use turret</div>
        <div id="hit-marker"></div>
        <div id="healthbar-container"><div id="healthbar"></div></div>
        <div id="heatbar-container"><div id="heatbar"></div></div>
        <div id="reserves-indicator">Enemies Remaining: 0</div>
        <div id="kill-count-indicator">Kills: 0</div>
        <div id="weapon-indicator">1: Rifle</div>
        <div id="instructions">
            <div class="inst-text">
                <h2>TRENCH WARFARE</h2>
                <p>Select a mode to deploy and lock pointer.</p>
                <p><b>WASD</b>: Move &nbsp;|&nbsp; <b>Shift</b>: Sprint &nbsp;|&nbsp; <b>C</b>: Toggle Crouch / Slide<br>
                <b>Q / E</b>: Lean (Roll while Prone) &nbsp;|&nbsp; <b>T</b>: Mount Turret &nbsp;|&nbsp; <b>R</b>: Reload Turret &nbsp;|&nbsp; <b>Z</b>: Go Prone<br>
                <b>RMB / Space</b>: Aim Down Sights &nbsp;|&nbsp; <b>LMB</b>: Fire<br>
                <b>1, 2, 3</b>: Switch Weapons &nbsp;|&nbsp; <b>F / G</b>: Sniper Zoom</p>
            </div>
            <div style="margin: 20px 0; display: flex; flex-direction: column; align-items: center; background: rgba(0,0,0,0.5); padding: 15px; border-radius: 8px; border: 1px solid #444; width: 340px;">
                <label for="soldier-count" style="font-size: 16px; font-weight: bold; margin-bottom: 5px;">Total Forces (Elimination): <span id="soldier-count-display">500</span></label>
                <input type="range" id="soldier-count" min="10" max="1000" value="500" style="width: 250px; cursor: pointer; margin-bottom: 15px;">
                <label for="active-count" style="font-size: 16px; font-weight: bold; margin-bottom: 5px;">Max Active on Field: <span id="active-count-display">25</span></label>
                <input type="range" id="active-count" min="10" max="100" value="25" style="width: 250px; cursor: pointer;">
                <div style="margin-top: 15px; display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="dev-mode-toggle" style="cursor: pointer; width: 18px; height: 18px;">
                    <label for="dev-mode-toggle" style="font-size: 14px; color: #ff6666; font-weight: bold; cursor: pointer;">Developer Mode (Infinite Health)</label>
                </div>
            </div>
            <div style="display: flex; gap: 20px;">
                <button id="btn-endless" class="menu-btn">Play Endless Mode</button>
                <button id="btn-elimination" class="menu-btn">Play Elimination Mode</button>
            </div>
        </div>
        <div id="victory-screen">
            <h1 style="font-size: 72px; margin-bottom: 10px; text-shadow: 0 0 10px #0f0;">VICTORY</h1>
            <p style="font-size: 24px; margin-bottom: 30px;">The enemy line has been broken.</p>
            <button id="btn-victory-menu" class="menu-btn">Return to Menu</button>
        </div>
    </div>
    <script>
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x555555, 0.015);
        scene.background = new THREE.Color(0x555555);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        let audioCtx, masterFilter, masterGain, shellShockTimer = 0;
        const audioBuffers = {};

        function triggerShellShock(duration) { shellShockTimer = Math.max(shellShockTimer, duration); }

        function createRealisticGunshot(ctx) {
            const buf=ctx.createBuffer(1,ctx.sampleRate,ctx.sampleRate), dat=buf.getChannelData(0); let out=0;
            for(let i=0;i<dat.length;i++){
                const t=i/ctx.sampleRate;
                let samp=((Math.random()*2-1)*Math.exp(-t*50)*1.5)+(Math.sin(2*Math.PI*(40+140*Math.exp(-t*35))*t)*Math.exp(-t*12)*4.0)+(Math.sin(2*Math.PI*35*t)*Math.exp(-t*6)*1.5)+((Math.random()*2-1)*Math.exp(-t*18)*0.8);
                out+=0.45*(samp-out); dat[i]=Math.tanh(out*1.3)+((Math.random()*2-1)*Math.exp(-t*2.5)*0.12);
            } return buf;
        }

        function createRealisticExplosion(ctx) {
            const buf=ctx.createBuffer(1,ctx.sampleRate*2.5,ctx.sampleRate), dat=buf.getChannelData(0); let out=0;
            for(let i=0;i<dat.length;i++){
                const t=i/ctx.sampleRate; let samp=((Math.random()*2-1)*0.6+Math.sin(2*Math.PI*(20+30*Math.random())*t)*0.4)*Math.min(1.0,t*20)*Math.exp(-t*1.5);
                out+=0.05*(samp-out); dat[i]=out*3.0;
            } return buf;
        }

        function createBulletWhiz(ctx) {
            const buf=ctx.createBuffer(1,ctx.sampleRate*0.3,ctx.sampleRate), dat=buf.getChannelData(0); let out=0;
            for(let i=0;i<dat.length;i++){
                const t=i/ctx.sampleRate, env=t<0.1?(t/0.1):1.0-((t-0.1)/0.2);
                let samp=(Math.sin(2*Math.PI*(1200-800*(t/0.3))*t)*0.6+(Math.random()*2-1)*0.4)*env;
                out+=0.4*(samp-out); dat[i]=out*0.8;
            } return buf;
        }

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                masterFilter = audioCtx.createBiquadFilter(); masterFilter.type = 'lowpass'; masterFilter.frequency.value = 22000;
                masterGain = audioCtx.createGain(); masterGain.gain.value = 1.0;
                masterFilter.connect(masterGain); masterGain.connect(audioCtx.destination);
                audioBuffers['gunshot'] = createRealisticGunshot(audioCtx); audioBuffers['artillery'] = createRealisticExplosion(audioCtx); audioBuffers['whiz'] = createBulletWhiz(audioCtx);
            }
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function playSoundFile(name, pitchShift=1.0, volume=1.0, isDistant=false) {
            if(!audioCtx||!audioBuffers[name])return; const source=audioCtx.createBufferSource(); source.buffer=audioBuffers[name]; source.playbackRate.value=pitchShift*(0.95+Math.random()*0.1);
            const gain=audioCtx.createGain(); gain.gain.value=volume;
            if(isDistant){ const filter=audioCtx.createBiquadFilter(); filter.type='lowpass'; filter.frequency.value=300+Math.random()*500; source.connect(filter); filter.connect(gain); }else{ source.connect(gain); }
            gain.connect(masterFilter); source.start(0);
        }

        function playPositionalSound(pos, type='gunshot') {
            if(!audioCtx)return; const dist=camera.getWorldPosition(new THREE.Vector3()).distanceTo(pos); if(dist>25)return; let vol=2.0/(2.0+dist);
            if(type==='impact'){ playSoundFile('gunshot', 1.5+Math.random()*0.5, vol*0.3); } else if(type==='artillery'){ playSoundFile('artillery', 1.2+Math.random()*0.3, vol*1.5); } else { playSoundFile('gunshot', 0.9+Math.random()*0.2, vol*0.525); }
        }

        let lastNearMissTime = 0;
        function playNearMissSound() {
            if(!audioCtx)return; const now=audioCtx.currentTime; if(now-lastNearMissTime<0.3)return; lastNearMissTime=now; playSoundFile('whiz',0.9+Math.random()*0.2,0.8);
        }

        function startAmbientBattle() {
            setInterval(()=>{ if(Math.random()>0.5){ const isClose=Math.random()<0.15; playSoundFile('artillery',0.6+Math.random()*0.4,isClose?1.5:0.7,!isClose); let hl=horizonLights[Math.floor(Math.random()*horizonLights.length)]; hl.light.intensity=5.0+Math.random()*15.0; hl.timer=0.2+Math.random()*0.4; if(isClose)triggerShellShock(2.5); } }, 2500);
            setInterval(()=>{ if(Math.random()>0.3)playSoundFile('gunshot',0.25+Math.random()*0.2,0.1125,true); }, 150);
        }

        const worldMeshes = []; const collisionObstacles = []; const turrets = []; const deathHotspots = []; let mountedTurret = null;
        function addStaticWorldMesh(mesh) { scene.add(mesh); worldMeshes.push(mesh); mesh.matrixAutoUpdate=false; mesh.updateMatrix(); }
        
        function getTerrainHeight(x, z) {
            const absZ=Math.abs(z);
            if(absZ>=66.0)return 1.0; 
            if(absZ>=62.0&&absZ<66.0){ const inGap=(Math.abs(x+60)<4.2)||(Math.abs(x+20)<4.2)||(Math.abs(x-20)<4.2)||(Math.abs(x-60)<4.2); return inGap?(-1.2+(2.2*((absZ-62.0)/4.0))):1.0; }
            if((absZ>=20.0&&absZ<=30.0)||(absZ>=40.0&&absZ<=50.0)){ const inGap=(Math.abs(x+60)<4.2)||(Math.abs(x+20)<4.2)||(Math.abs(x-20)<4.2)||(Math.abs(x-60)<4.2); if(!inGap)return 0.0; }
            return -1.2; 
        }

        const groundMat = new THREE.MeshLambertMaterial({color: 0x3a4530}), wallMat = new THREE.MeshLambertMaterial({color: 0x4a3c2b}), woodMat = new THREE.MeshLambertMaterial({color: 0x3d2817});
        const baseFloor = new THREE.Mesh(new THREE.PlaneGeometry(200,200), groundMat); baseFloor.rotation.x=-Math.PI/2; baseFloor.position.set(0,-1.2,0); addStaticWorldMesh(baseFloor);

        function createWall(x, z, w, h, yCenter) { const mesh=new THREE.Mesh(new THREE.BoxGeometry(w,h,0.5),wallMat); mesh.position.set(x,yCenter,z); addStaticWorldMesh(mesh); collisionObstacles.push({minX:x-w/2,maxX:x+w/2,minZ:z-0.25,maxZ:z+0.25}); }
        const rampGeo = new THREE.PlaneGeometry(8,4.565); const gapCenters = [-60,-20,20,60]; const blockCenters = [-82,-40,0,40,82]; const blockWidths = [36,32,32,32,36];

        const sepZs = [-45,-25,25,45]; 
        for(let sz of sepZs){ for(let i=0;i<blockCenters.length;i++){ let cx=blockCenters[i], w=blockWidths[i], b=new THREE.Mesh(new THREE.BoxGeometry(w,1.2,10.0),groundMat); b.position.set(cx,-0.6,sz); addStaticWorldMesh(b); collisionObstacles.push({minX:cx-w/2,maxX:cx+w/2,minZ:sz-5.0,maxZ:sz+5.0}); createWall(cx,sz-5.25,w,1.4,-0.5); createWall(cx,sz+5.25,w,1.4,-0.5); } }
        const bfA=new THREE.Mesh(new THREE.PlaneGeometry(200,40),wallMat); bfA.rotation.x=-Math.PI/2; bfA.position.set(0,1.0,-86.0); addStaticWorldMesh(bfA);
        const bfE=new THREE.Mesh(new THREE.PlaneGeometry(200,40),wallMat); bfE.rotation.x=-Math.PI/2; bfE.position.set(0,1.0,86.0); addStaticWorldMesh(bfE);

        for(let i=0;i<blockCenters.length;i++){
            let cx=blockCenters[i], w=blockWidths[i];
            let bA=new THREE.Mesh(new THREE.BoxGeometry(w,2.2,4.0),groundMat); bA.position.set(cx,-0.1,-64.0); addStaticWorldMesh(bA); collisionObstacles.push({minX:cx-w/2,maxX:cx+w/2,minZ:-66.0,maxZ:-62.0});
            let bE=new THREE.Mesh(new THREE.BoxGeometry(w,2.2,4.0),groundMat); bE.position.set(cx,-0.1,64.0); addStaticWorldMesh(bE); collisionObstacles.push({minX:cx-w/2,maxX:cx+w/2,minZ:62.0,maxZ:66.0});
            createWall(cx,-61.75,w,1.4,-0.5); createWall(cx,61.75,w,1.4,-0.5);
        }
        createWall(0,-106.75,200,2.0,2.0); createWall(0,106.75,200,2.0,2.0);

        for(let i=0;i<gapCenters.length;i++){
            let rA=new THREE.Mesh(rampGeo,groundMat); rA.rotation.x=-Math.PI/2+0.5028; rA.position.set(gapCenters[i],-0.1,-64.0); addStaticWorldMesh(rA);
            let rE=new THREE.Mesh(rampGeo,groundMat); rE.rotation.x=-Math.PI/2-0.5028; rE.position.set(gapCenters[i],-0.1,64.0); addStaticWorldMesh(rE);
        }

        const allyCovers = {0:[],1:[],2:[],3:[]}, enemyCovers = {0:[],1:[],2:[],3:[]};
        function addCover(x, z, arr, dirZ) {
            let bw=1.2+Math.random()*0.8, bd=0.8+Math.random()*0.4, mesh=new THREE.Mesh(new THREE.BoxGeometry(bw,1.2+Math.random()*0.5,bd),woodMat); mesh.position.set(x,-0.6,z); mesh.rotation.y=(Math.random()-0.5)*1.5; addStaticWorldMesh(mesh);
            let maxR=Math.max(bw,bd)/1.5; collisionObstacles.push({minX:x-maxR,maxX:x+maxR,minZ:z-maxR,maxZ:z+maxR}); arr.push({x:x,z:z+dirZ,y:-1.2});
        }
        function scatterCovers(zStart, zEnd, arr, isEnemy) {
            for(let x=-90; x<=90; x+=5+Math.random()*6){ if(Math.abs(x+60)<5||Math.abs(x+20)<5||Math.abs(x-20)<5||Math.abs(x-60)<5)continue; addCover(x,zStart+Math.random()*(zEnd-zStart),arr,isEnemy?1.8:-1.8); }
        }
        scatterCovers(-8,0,allyCovers[3],false); scatterCovers(0,8,enemyCovers[3],true); scatterCovers(-18,-12,allyCovers[2],false); scatterCovers(12,18,enemyCovers[2],true); scatterCovers(-38,-32,allyCovers[1],false); scatterCovers(32,38,enemyCovers[1],true); scatterCovers(-58,-52,allyCovers[0],false); scatterCovers(52,58,enemyCovers[0],true);

        class Turret {
            constructor(x, y, z, isEnemy, coverArr) {
                this.isEnemy=isEnemy; this.mesh=new THREE.Group(); this.mesh.position.set(x,y,z); this.ammo=5; this.maxAmmo=5; this.isReloading=false; this.reloadTimer=0;
                const base=new THREE.Mesh(new THREE.CylinderGeometry(0.3,0.4,0.6,8),wallMat); base.position.y=-0.3; this.mesh.add(base);
                this.swivel=new THREE.Group(); this.swivel.position.y=0.1; this.baseYaw=isEnemy?0:Math.PI; this.swivel.rotation.y=this.baseYaw; this.mesh.add(this.swivel);
                this.pitchGroup=new THREE.Group(); this.swivel.add(this.pitchGroup);
                const rec=new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.5),new THREE.MeshLambertMaterial({color:0x1a1a1a})); this.pitchGroup.add(rec);
                const wj=new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,0.8,12),new THREE.MeshLambertMaterial({color:0x2a2a2a})); wj.rotation.x=Math.PI/2; wj.position.set(0,0,-0.65); this.pitchGroup.add(wj);
                const bar=new THREE.Mesh(new THREE.CylinderGeometry(0.025,0.03,0.2,8),new THREE.MeshLambertMaterial({color:0x111111})); bar.rotation.x=Math.PI/2; bar.position.z=-1.15; this.pitchGroup.add(bar);
                const gb=new THREE.Mesh(new THREE.BoxGeometry(0.18,0.02,0.02),new THREE.MeshLambertMaterial({color:0x111111})); gb.position.set(0,0,0.26);
                const lg=new THREE.Mesh(new THREE.CylinderGeometry(0.015,0.015,0.1),new THREE.MeshLambertMaterial({color:0x3a2e15})); lg.rotation.x=Math.PI/2; lg.position.set(-0.09,0,0.3);
                const rg=new THREE.Mesh(new THREE.CylinderGeometry(0.015,0.015,0.1),new THREE.MeshLambertMaterial({color:0x3a2e15})); rg.rotation.x=Math.PI/2; rg.position.set(0.09,0,0.3);
                const tt=new THREE.Mesh(new THREE.BoxGeometry(0.04,0.02,0.02),new THREE.MeshLambertMaterial({color:0x555555})); tt.position.set(0,0,0.28); this.pitchGroup.add(gb,lg,rg,tt);
                const ab=new THREE.Mesh(new THREE.BoxGeometry(0.15,0.2,0.25),new THREE.MeshLambertMaterial({color:0x3a4530})); ab.position.set(-0.18,-0.05,0); this.pitchGroup.add(ab);
                for(let b=0;b<4;b++){ let bl=new THREE.Mesh(new THREE.CylinderGeometry(0.008,0.008,0.04,6),new THREE.MeshLambertMaterial({color:0xccaa44})); bl.rotation.z=Math.PI/2; bl.position.set(-0.12+(b*0.02),0.05,0); this.pitchGroup.add(bl); }
                const sl=new THREE.Mesh(new THREE.BoxGeometry(0.35,0.5,0.05),new THREE.MeshLambertMaterial({color:0x3a4530})); sl.position.set(-0.25,-0.15,-0.2);
                const sr=new THREE.Mesh(new THREE.BoxGeometry(0.35,0.5,0.05),new THREE.MeshLambertMaterial({color:0x3a4530})); sr.position.set(0.25,-0.15,-0.2);
                const sb=new THREE.Mesh(new THREE.BoxGeometry(0.15,0.2,0.05),new THREE.MeshLambertMaterial({color:0x3a4530})); sb.position.set(0,-0.3,-0.2); this.pitchGroup.add(sl,sr,sb);
                const tsb=new THREE.Mesh(new THREE.BoxGeometry(0.12,0.02,0.04),new THREE.MeshLambertMaterial({color:0x111111})); tsb.position.set(0,0.11,0.15);
                const tsl=new THREE.Mesh(new THREE.BoxGeometry(0.02,0.04,0.04),new THREE.MeshLambertMaterial({color:0x111111})); tsl.position.set(-0.04,0.14,0.15);
                const tsr=new THREE.Mesh(new THREE.BoxGeometry(0.02,0.04,0.04),new THREE.MeshLambertMaterial({color:0x111111})); tsr.position.set(0.04,0.14,0.15);
                const tfs=new THREE.Mesh(new THREE.BoxGeometry(0.01,0.08,0.02),new THREE.MeshLambertMaterial({color:0x111111})); tfs.position.set(0,0.12,-1.0); this.pitchGroup.add(tsb,tsl,tsr,tfs);
                this.dummyShell=new THREE.Mesh(new THREE.CylinderGeometry(0.015,0.015,0.1,8),new THREE.MeshLambertMaterial({color:0xccaa44})); this.dummyShell.rotation.x=Math.PI/2; this.dummyShell.visible=false; this.pitchGroup.add(this.dummyShell);
                scene.add(this.mesh); worldMeshes.push(base,sl,sr,sb,rec,wj,ab); collisionObstacles.push({minX:x-0.5,maxX:x+0.5,minZ:z-0.5,maxZ:z+0.5}); turrets.push(this); this.user=null; this.lastShot=0;
                this.coverPos={x:this.mesh.position.x,z:this.mesh.position.z+(this.isEnemy?1.2:-1.2),isTurret:true,turret:this}; if(coverArr)coverArr.push(this.coverPos);
            }
        }

        function buildElevatedWallAndCovers(zPos, isEnemy) {
            const coverArr=isEnemy?enemyCovers[0]:allyCovers[0];
            for(let i=0;i<blockCenters.length;i++){
                const cx=blockCenters[i], w=blockWidths[i]; createWall(cx,zPos,w,0.8,1.4); let startX=cx-w/2+2, endX=cx+w/2-2, count=0;
                for(let x=startX;x<=endX;x+=4){
                    if(count%2===0){ createWall(x,zPos,3.5,1.8,1.9); }else{ if((i===1||i===2||i===3)&&count===3){ new Turret(x,2.0,zPos,isEnemy,coverArr); }else{ coverArr.push({x:x,z:isEnemy?zPos+1.2:zPos-1.2,y:1.0}); } } count++;
                }
            }
        }
        buildElevatedWallAndCovers(-66.25,false); buildElevatedWallAndCovers(66.25,true);

        for(let i=0;i<100;i++){
            let x=(Math.random()-0.5)*180, z=(Math.random()-0.5)*140; if(Math.abs(x+40)<4||Math.abs(x-40)<4)continue;
            let bw=0.8+Math.random(), bh=0.5+Math.random(), bd=0.8+Math.random(), m=new THREE.Mesh(new THREE.BoxGeometry(bw,bh,bd),Math.random()>0.5?woodMat:wallMat);
            m.position.set(x,getTerrainHeight(x,z)+0.2,z); m.rotation.set(Math.random()*Math.PI,Math.random()*Math.PI,Math.random()*Math.PI); addStaticWorldMesh(m);
            let maxR=Math.max(bw,bh,bd)/1.8; collisionObstacles.push({minX:x-maxR,maxX:x+maxR,minZ:z-maxR,maxZ:z+maxR});
        }

        const craterGeo=new THREE.PlaneGeometry(3,3), craterMat=new THREE.MeshBasicMaterial({color:0x1a1c14,depthWrite:false,transparent:true,opacity:0.8});
        for(let i=0;i<200;i++){ let cr=new THREE.Mesh(craterGeo,craterMat), cx=(Math.random()-0.5)*190, cz=(Math.random()-0.5)*140, s=0.5+Math.random()*2; cr.scale.set(s,s,s); cr.rotation.x=-Math.PI/2; cr.rotation.z=Math.random()*Math.PI; cr.position.set(cx,getTerrainHeight(cx,cz)+0.02,cz); cr.matrixAutoUpdate=false; cr.updateMatrix(); scene.add(cr); }

        const ashGeo=new THREE.BufferGeometry(), ashCount=1500, ashPos=new Float32Array(ashCount*3);
        for(let i=0;i<ashCount*3;i+=3){ ashPos[i]=(Math.random()-0.5)*200; ashPos[i+1]=Math.random()*10; ashPos[i+2]=(Math.random()-0.5)*160; }
        ashGeo.setAttribute('position',new THREE.BufferAttribute(ashPos,3)); const ashParticles=new THREE.Points(ashGeo,new THREE.PointsMaterial({color:0x666666,size:0.15,transparent:true,opacity:0.5})); scene.add(ashParticles);

        const horizonLights=[];
        for(let i=0;i<8;i++){ let l=new THREE.PointLight(0xffaa55,0,150); l.position.set((Math.random()-0.5)*180,5,(i%2===0?1:-1)*(80+Math.random()*20)); scene.add(l); horizonLights.push({light:l,timer:0}); }

        function resolveObstacles(pos, rad) {
            for(let obs of collisionObstacles){
                let cX=Math.max(obs.minX,Math.min(pos.x,obs.maxX)), cZ=Math.max(obs.minZ,Math.min(pos.z,obs.maxZ));
                if(pos.x>=obs.minX&&pos.x<=obs.maxX&&pos.z>=obs.minZ&&pos.z<=obs.maxZ){
                    let dL=pos.x-obs.minX, dR=obs.maxX-pos.x, dT=pos.z-obs.minZ, dB=obs.maxZ-pos.z, mD=Math.min(dL,dR,dT,dB);
                    if(mD===dL)pos.x=obs.minX-rad; else if(mD===dR)pos.x=obs.maxX+rad; else if(mD===dT)pos.z=obs.minZ-rad; else if(mD===dB)pos.z=obs.maxZ+rad;
                }else{
                    let dx=pos.x-cX, dz=pos.z-cZ, dSq=dx*dx+dz*dz; if(dSq<rad*rad&&dSq>0.0001){ let d=Math.sqrt(dSq), o=rad-d; pos.x+=(dx/d)*o; pos.z+=(dz/d)*o; }
                }
            }
        }

        scene.add(new THREE.AmbientLight(0x404040,1.5)); const dirLight=new THREE.DirectionalLight(0xffddbb,0.8); dirLight.position.set(10,20,10); scene.add(dirLight);

        const playerRoot=new THREE.Group(); playerRoot.position.set(0,-1.2,-60); scene.add(playerRoot);
        const leanObject=new THREE.Group(); leanObject.position.y=1.5; playerRoot.add(leanObject);
        const pitchObject=new THREE.Group(); leanObject.add(pitchObject); pitchObject.add(camera);

        const playerAI = {
            isPlayer: true, hp: 10, dead: false,
            takeDamage: function(amt, attacker) {
                if(this.dead || (attacker && !attacker.isPlayer && !attacker.isEnemy)) return;
                playNearMissSound(); triggerShellShock(1.0);
                if(!devMode) playerHp-=amt;
                document.getElementById('healthbar').style.width=(playerHp*10)+'%'; document.getElementById('hurt-overlay').style.opacity=0.5;
                if(playerHp<=0){ this.dead=true; if(mountedTurret){mountedTurret.user=null;mountedTurret=null;weaponContainer.visible=true;} document.getElementById('hurt-overlay').style.background='black'; document.getElementById('hurt-overlay').style.opacity=1.0; setTimeout(()=>{if(document.pointerLockElement)document.exitPointerLock();},2000); }
            }
        };
        playerAI.mesh=new THREE.Mesh(new THREE.BoxGeometry(0.8,1.8,0.8),new THREE.MeshBasicMaterial({visible:false})); playerAI.mesh.userData.ai=playerAI; playerAI.mesh.position.y=0.9; playerRoot.add(playerAI.mesh);

        const weaponContainer=new THREE.Group(); camera.add(weaponContainer); weaponContainer.position.set(0.2,-0.2,-0.4);
        const weaponsData=[ {id:'rifle',name:'1: Rifle',type:'semi',fireRate:250,recoilPitch:0.0066,recoilZ:0.033,barrelLen:-0.8,soundPitch:1.0,alignY:-0.06}, {id:'mg',name:'2: Machine Gun',type:'auto',fireRate:100,recoilPitch:0.012,recoilZ:0.05,barrelLen:-0.9,soundPitch:1.1,alignY:-0.08}, {id:'sniper',name:'3: Sniper Rifle',type:'semi',fireRate:1500,recoilPitch:0.0198,recoilZ:0.1,barrelLen:-1.2,soundPitch:0.7,alignY:0} ];
        let currentWeaponIndex=0, sniperZoomLevel=4, snBoltGroup, sniperNeedsRechamber=false, sniperRechamberStartTime=0;

        const modelRifle=new THREE.Group();
        const rBarrel=new THREE.Mesh(new THREE.CylinderGeometry(0.012,0.015,0.9,8),new THREE.MeshLambertMaterial({color:0x222222})); rBarrel.rotation.x=Math.PI/2; rBarrel.position.set(0,0,-0.45);
        const rReceiver=new THREE.Mesh(new THREE.BoxGeometry(0.04,0.06,0.25),new THREE.MeshLambertMaterial({color:0x1a1a1a})); rReceiver.position.set(0,0.01,-0.15);
        const rStock=new THREE.Mesh(new THREE.BoxGeometry(0.05,0.12,0.4),new THREE.MeshLambertMaterial({color:0x4a2e15})); rStock.position.set(0,-0.03,0.1);
        const rHandguard=new THREE.Mesh(new THREE.BoxGeometry(0.045,0.04,0.5),new THREE.MeshLambertMaterial({color:0x4a2e15})); rHandguard.position.set(0,-0.01,-0.4);
        const rTriggerGuard=new THREE.Mesh(new THREE.BoxGeometry(0.01,0.04,0.08),new THREE.MeshLambertMaterial({color:0x111111})); rTriggerGuard.position.set(0,-0.06,-0.05);
        const rBoltHandle=new THREE.Mesh(new THREE.CylinderGeometry(0.005,0.005,0.04),new THREE.MeshLambertMaterial({color:0x333333})); rBoltHandle.rotation.z=Math.PI/2; rBoltHandle.position.set(0.025,0.02,-0.1);
        const rFSight=new THREE.Mesh(new THREE.BoxGeometry(0.005,0.04,0.01),new THREE.MeshLambertMaterial({color:0x111111})); rFSight.position.set(0,0.04,-0.85); 
        const rRSightBase=new THREE.Mesh(new THREE.BoxGeometry(0.04,0.02,0.04),new THREE.MeshLambertMaterial({color:0x111111})); rRSightBase.position.set(0,0.03,-0.25); 
        const rRSightL=new THREE.Mesh(new THREE.BoxGeometry(0.01,0.02,0.02),new THREE.MeshLambertMaterial({color:0x111111})); rRSightL.position.set(-0.015,0.05,-0.25); 
        const rRSightR=new THREE.Mesh(new THREE.BoxGeometry(0.01,0.02,0.02),new THREE.MeshLambertMaterial({color:0x111111})); rRSightR.position.set(0.015,0.05,-0.25); 
        modelRifle.add(rBarrel,rReceiver,rStock,rHandguard,rTriggerGuard,rBoltHandle,rFSight,rRSightBase,rRSightL,rRSightR);

        const modelMG=new THREE.Group();
        const mgBarrel=new THREE.Mesh(new THREE.CylinderGeometry(0.018,0.02,0.9,8),new THREE.MeshLambertMaterial({color:0x1a1a1a})); mgBarrel.rotation.x=Math.PI/2; mgBarrel.position.set(0,0,-0.45);
        const mgReceiver=new THREE.Mesh(new THREE.BoxGeometry(0.06,0.08,0.35),new THREE.MeshLambertMaterial({color:0x111111})); mgReceiver.position.set(0,0.01,-0.1);
        const mgMag=new THREE.Mesh(new THREE.BoxGeometry(0.05,0.12,0.1),new THREE.MeshLambertMaterial({color:0x2a3a2a})); mgMag.position.set(-0.04,-0.05,-0.1);
        const mgStock=new THREE.Mesh(new THREE.BoxGeometry(0.05,0.1,0.3),new THREE.MeshLambertMaterial({color:0x3a2e15})); mgStock.position.set(0,-0.02,0.15);
        const mgBipod=new THREE.Mesh(new THREE.CylinderGeometry(0.005,0.005,0.15),new THREE.MeshLambertMaterial({color:0x111111})); mgBipod.position.set(0,-0.05,-0.8); mgBipod.rotation.x=Math.PI/4;
        const mgFSight=new THREE.Mesh(new THREE.BoxGeometry(0.005,0.062,0.01),new THREE.MeshLambertMaterial({color:0x111111})); mgFSight.position.set(0,0.049,-0.85); 
        modelMG.add(mgBarrel,mgReceiver,mgMag,mgStock,mgBipod,mgFSight);

        const modelSniper=new THREE.Group();
        const snBarrel=new THREE.Mesh(new THREE.CylinderGeometry(0.01,0.015,1.2,8),new THREE.MeshLambertMaterial({color:0x222222})); snBarrel.rotation.x=Math.PI/2; snBarrel.position.set(0,0,-0.6);
        const snReceiver=new THREE.Mesh(new THREE.BoxGeometry(0.03,0.05,0.3),new THREE.MeshLambertMaterial({color:0x1a1a1a})); snReceiver.position.set(0,0,-0.15);
        const snStock=new THREE.Mesh(new THREE.BoxGeometry(0.04,0.1,0.5),new THREE.MeshLambertMaterial({color:0x4a2e15})); snStock.position.set(0,-0.03,0.15);
        const snHandguard=new THREE.Mesh(new THREE.BoxGeometry(0.035,0.04,0.6),new THREE.MeshLambertMaterial({color:0x4a2e15})); snHandguard.position.set(0,-0.01,-0.45);
        const snTriggerGuard=new THREE.Mesh(new THREE.BoxGeometry(0.01,0.03,0.06),new THREE.MeshLambertMaterial({color:0x111111})); snTriggerGuard.position.set(0,-0.05,-0.05);
        const snScopeTube=new THREE.Mesh(new THREE.CylinderGeometry(0.015,0.015,0.35,12),new THREE.MeshLambertMaterial({color:0x111111})); snScopeTube.rotation.x=Math.PI/2; snScopeTube.position.set(0,0.06,-0.15);
        const snScopeObj=new THREE.Mesh(new THREE.CylinderGeometry(0.025,0.025,0.08,12),new THREE.MeshLambertMaterial({color:0x111111})); snScopeObj.rotation.x=Math.PI/2; snScopeObj.position.set(0,0.06,-0.32);
        const snScopeEye=new THREE.Mesh(new THREE.CylinderGeometry(0.02,0.02,0.06,12),new THREE.MeshLambertMaterial({color:0x111111})); snScopeEye.rotation.x=Math.PI/2; snScopeEye.position.set(0,0.06,0.02);
        const snScopeKnobT=new THREE.Mesh(new THREE.CylinderGeometry(0.008,0.008,0.02,8),new THREE.MeshLambertMaterial({color:0x222222})); snScopeKnobT.position.set(0,0.08,-0.15);
        const snScopeKnobR=new THREE.Mesh(new THREE.CylinderGeometry(0.008,0.008,0.02,8),new THREE.MeshLambertMaterial({color:0x222222})); snScopeKnobR.rotation.z=Math.PI/2; snScopeKnobR.position.set(0.02,0.06,-0.15);
        const snScopeMount1=new THREE.Mesh(new THREE.BoxGeometry(0.01,0.04,0.01),new THREE.MeshLambertMaterial({color:0x111111})); snScopeMount1.position.set(0,0.04,-0.05);
        const snScopeMount2=new THREE.Mesh(new THREE.BoxGeometry(0.01,0.04,0.01),new THREE.MeshLambertMaterial({color:0x111111})); snScopeMount2.position.set(0,0.04,-0.25);
        
        snBoltGroup=new THREE.Group(); snBoltGroup.position.set(0,0.015,-0.05); 
        const snBoltBody=new THREE.Mesh(new THREE.CylinderGeometry(0.008,0.008,0.18,8),new THREE.MeshLambertMaterial({color:0x555555})); snBoltBody.rotation.x=Math.PI/2; 
        const snBoltHandle=new THREE.Mesh(new THREE.CylinderGeometry(0.003,0.003,0.06),new THREE.MeshLambertMaterial({color:0x333333})); snBoltHandle.rotation.z=Math.PI/2; snBoltHandle.position.set(0.03,0,0.07); 
        const snBoltKnob=new THREE.Mesh(new THREE.SphereGeometry(0.008,8,8),new THREE.MeshLambertMaterial({color:0x111111})); snBoltKnob.position.set(0.06,0,0.07); 
        snBoltGroup.add(snBoltBody,snBoltHandle,snBoltKnob);
        modelSniper.add(snBarrel,snReceiver,snStock,snHandguard,snTriggerGuard,snScopeTube,snScopeObj,snScopeEye,snScopeKnobT,snScopeKnobR,snScopeMount1,snScopeMount2,snBoltGroup);
        weaponContainer.add(modelRifle,modelMG,modelSniper); modelMG.visible=false; modelSniper.visible=false;

        function switchWeapon(index) {
            if(index===currentWeaponIndex)return; currentWeaponIndex=index;
            modelRifle.visible=(index===0); modelMG.visible=(index===1); modelSniper.visible=(index===2);
            document.getElementById('weapon-indicator').innerText=weaponsData[index].name;
            fpFlashGroup.position.z=weaponsData[index].barrelLen-0.05; fpFlashLight.position.z=weaponsData[index].barrelLen-0.05;
            if(index===2&&sniperNeedsRechamber)sniperRechamberStartTime=performance.now();
        }

        const flashTexCanvas=document.createElement('canvas'); flashTexCanvas.width=16; flashTexCanvas.height=16; const fctx=flashTexCanvas.getContext('2d');
        fctx.fillStyle="rgba(200,50,0,0.5)"; fctx.fillRect(6,2,4,12); fctx.fillRect(2,6,12,4); fctx.fillStyle="rgba(255,120,0,0.8)"; fctx.fillRect(7,3,2,10); fctx.fillRect(3,7,10,2); fctx.fillRect(5,5,6,6); fctx.fillStyle="rgba(255,220,100,1)"; fctx.fillRect(6,6,4,4); fctx.fillStyle="rgba(255,255,255,1)"; fctx.fillRect(7,7,2,2);
        const flashTexture=new THREE.CanvasTexture(flashTexCanvas); flashTexture.magFilter=THREE.NearestFilter; flashTexture.minFilter=THREE.NearestFilter;
        const fpFlashMaterial=new THREE.MeshBasicMaterial({map:flashTexture,transparent:true,opacity:0,depthWrite:false,blending:THREE.AdditiveBlending});
        const fpFlashGroup=new THREE.Group(); fpFlashGroup.add(new THREE.Mesh(new THREE.PlaneGeometry(0.3,0.3),fpFlashMaterial),new THREE.Mesh(new THREE.PlaneGeometry(0.3,0.3),fpFlashMaterial));
        fpFlashGroup.children[0].rotation.z=Math.PI/4; fpFlashGroup.children[1].rotation.z=-Math.PI/4; fpFlashGroup.position.set(0,0,-0.85);
        const fpFlashLight=new THREE.PointLight(0xffddaa,0,5); fpFlashLight.position.set(0,0,-0.85); weaponContainer.add(fpFlashGroup,fpFlashLight);

        const flashes=[]; for(let i=0;i<20;i++){ const f=new THREE.Mesh(new THREE.PlaneGeometry(0.5,0.5),new THREE.MeshBasicMaterial({map:flashTexture,transparent:true,opacity:0,depthWrite:false,blending:THREE.AdditiveBlending,side:THREE.DoubleSide})); scene.add(f); flashes.push({mesh:f,life:0}); }
        function showMuzzleFlash(pos,dir){ const f=flashes.find(fl=>fl.life<=0); if(f){ f.life=0.05; f.mesh.position.copy(pos).add(dir.clone().multiplyScalar(0.4)); f.mesh.lookAt(f.mesh.position.clone().add(dir)); f.mesh.rotateZ(Math.random()*Math.PI*2); f.mesh.scale.set((Math.random()>0.5?1:-1)*(0.7+Math.random()*0.6),(Math.random()>0.5?1:-1)*(0.7+Math.random()*0.6),1); f.mesh.material.opacity=1; } }

        const explosions=[]; const expGeo=new THREE.SphereGeometry(1,16,16); const expMat=new THREE.MeshBasicMaterial({color:0xffaa00,transparent:true,opacity:1,depthWrite:false,blending:THREE.AdditiveBlending});
        for(let i=0;i<15;i++){ const m=new THREE.Mesh(expGeo,expMat.clone()); m.visible=false; const l=new THREE.PointLight(0xff6600,0,40); scene.add(m,l); explosions.push({mesh:m,light:l,life:0,maxLife:0.5}); }
        function createExplosion(pos){ const exp=explosions.find(e=>e.life<=0); if(exp){ exp.life=exp.maxLife; exp.mesh.position.copy(pos); exp.light.position.copy(pos); exp.visible=true; exp.mesh.visible=true; exp.mesh.material.opacity=1; exp.light.intensity=20.0; } }

        const impacts=[]; const impactGeo=new THREE.PlaneGeometry(0.3,0.3); const impactMat=new THREE.MeshBasicMaterial({color:0x887755,transparent:true,opacity:1,depthWrite:false});
        for(let i=0;i<40;i++){ const m=new THREE.Mesh(impactGeo,impactMat.clone()); m.visible=false; scene.add(m); impacts.push({mesh:m,life:0}); }
        function createImpact(pos,normal){ const imp=impacts.find(i=>i.life<=0); if(imp){ imp.life=0.2; imp.mesh.position.copy(pos).add(normal.clone().multiplyScalar(0.02)); imp.mesh.lookAt(pos.clone().add(normal)); imp.mesh.scale.set(0.1,0.1,0.1); imp.mesh.material.opacity=1; imp.mesh.visible=true; } }

        const tracers=[]; const tracerGeo=new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0),new THREE.Vector3(0,0,-8)]);
        for(let i=0;i<200;i++){ const t=new THREE.Line(tracerGeo,new THREE.LineBasicMaterial({color:0xffcc88})); t.visible=false; scene.add(t); tracers.push({mesh:t,life:0,dir:new THREE.Vector3(),traveled:0,maxDist:200}); }
        function createTracer(start,dir,maxDist=200){ const t=tracers.find(tr=>tr.life<=0); if(t){ t.life=0.8; t.mesh.position.copy(start); t.dir.copy(dir); t.mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0,0,-1),dir); t.mesh.visible=true; t.traveled=0; t.maxDist=maxDist; } }

        const keys={w:false,a:false,s:false,d:false,shift:false,z:false,c:false,q:false,e:false,space:false,lmb:false};
        let lastQPress=0, lastEPress=0, qToggled=false, eToggled=false, lmbJustPressed=false, isCrouched=false, isProne=false, slideTimer=0, slideSpeed=0, slideDir=new THREE.Vector3(), yaw=0, pitch=0, playerHp=10, initialized=false, mgHeat=0, mgOverheated=false, gameMode='endless', rollAngle=0, activeRollDir=0, rollCooldown=0, playerKills=0, devMode=false, tracerProbability=0.5, allyReserves=0, enemyReserves=0;

        document.getElementById('soldier-count').addEventListener('input', e=>document.getElementById('soldier-count-display').innerText=e.target.value);
        document.getElementById('active-count').addEventListener('input', e=>document.getElementById('active-count-display').innerText=e.target.value);
        document.getElementById('dev-mode-toggle').addEventListener('change', e=>devMode=e.target.checked);

        function startGame(mode) {
            gameMode=mode; if(!initialized){initAudio(); startAmbientBattle(); initialized=true;}
            playerHp=10; playerAI.dead=false; document.getElementById('healthbar').style.width='100%'; document.getElementById('hurt-overlay').style.opacity=0; document.getElementById('hurt-overlay').style.background='red'; document.getElementById('victory-screen').style.display='none';
            const spawnX=(Math.random()-0.5)*132; let spawnZ=Math.random()>0.5?(-55+Math.random()*5):(-75+Math.random()*10); let spawnPos2D={x:spawnX,z:spawnZ}; resolveObstacles(spawnPos2D,0.4);
            playerRoot.position.set(spawnPos2D.x,getTerrainHeight(spawnPos2D.x,spawnPos2D.z),spawnPos2D.z); 
            yaw=Math.PI; pitch=0; isCrouched=false; isProne=false; slideTimer=0; mgHeat=0; mgOverheated=false; qToggled=false; eToggled=false; rollAngle=0; activeRollDir=0; rollCooldown=0; playerKills=0; document.getElementById('kill-count-indicator').innerText='Kills: 0'; sniperNeedsRechamber=false; sniperZoomLevel=4;
            if(mountedTurret){ mountedTurret.user=null; mountedTurret=null; weaponContainer.visible=true; } turrets.forEach(t=>t.user=null);
            const totalCount=parseInt(document.getElementById('soldier-count').value,10)||500, activeCount=parseInt(document.getElementById('active-count').value,10)||25;
            tracerProbability=Math.min(1.0, 25/activeCount);
            if(mode==='elimination'){ const init=Math.min(totalCount,activeCount); allyReserves=totalCount-init; enemyReserves=totalCount-init; spawnSoldiers(init); document.getElementById('reserves-indicator').style.display='block'; } else { spawnSoldiers(activeCount); document.getElementById('reserves-indicator').style.display='none'; }
            if(!document.pointerLockElement) document.body.requestPointerLock().catch(err=>console.warn(err));
        }

        document.getElementById('btn-endless').addEventListener('click',()=>startGame('endless')); document.getElementById('btn-elimination').addEventListener('click',()=>startGame('elimination')); document.getElementById('btn-victory-menu').addEventListener('click',()=>{document.getElementById('victory-screen').style.display='none'; document.getElementById('instructions').style.display='flex';});
        document.addEventListener('pointerlockchange',()=>{if(document.getElementById('victory-screen').style.display==='flex')return; document.getElementById('instructions').style.display=document.pointerLockElement?'none':'flex';});
        document.addEventListener('mousemove', e=>{ if(document.pointerLockElement&&!playerAI.dead){ yaw-=e.movementX*0.002; pitch-=e.movementY*0.002; pitch=Math.max(-Math.PI/2,Math.min(Math.PI/2,pitch)); if(mountedTurret){ let diff=yaw-mountedTurret.baseYaw; while(diff<-Math.PI)diff+=Math.PI*2; while(diff>Math.PI)diff-=Math.PI*2; if(diff>Math.PI/2)diff=Math.PI/2; if(diff<-Math.PI/2)diff=-Math.PI/2; yaw=mountedTurret.baseYaw+diff; } playerRoot.rotation.y=yaw; pitchObject.rotation.x=pitch; } });

        document.addEventListener('keydown', e=>{
            const c=e.code; if(c==='KeyW')keys.w=true; if(c==='KeyA')keys.a=true; if(c==='KeyS')keys.s=true; if(c==='KeyD')keys.d=true; if(c==='ShiftLeft'||c==='ShiftRight')keys.shift=true; if(c==='Space')keys.space=true;
            if(c==='KeyQ'){ if(!keys.q){ const now=performance.now(); if(qToggled)qToggled=false; else if(now-lastQPress<300){qToggled=true;lastQPress=0;} else lastQPress=now; } keys.q=true; eToggled=false; }
            if(c==='KeyE'){ if(!keys.e){ const now=performance.now(); if(eToggled)eToggled=false; else if(now-lastEPress<300){eToggled=true;lastEPress=0;} else lastEPress=now; } keys.e=true; qToggled=false; }
            if(c==='KeyC'){ if(!keys.c){ let isSM=(keys.w||keys.a||keys.s||keys.d)&&keys.shift&&!isProne&&!isCrouched&&!mountedTurret; if(slideTimer>0){ slideTimer=0; isCrouched=false; } else if(isSM){ isCrouched=true; isProne=false; qToggled=false; eToggled=false; slideTimer=0.75; slideSpeed=16.0; let mDir=new THREE.Vector3(); if(keys.w)mDir.z-=1; if(keys.s)mDir.z+=1; if(keys.a)mDir.x-=1; if(keys.d)mDir.x+=1; if(mDir.lengthSq()>0)mDir.normalize(); mDir.applyAxisAngle(new THREE.Vector3(0,1,0),yaw); slideDir.copy(mDir); } else { if(isProne){isProne=false; isCrouched=true;} else if(isCrouched){isCrouched=false;} else {isCrouched=!isCrouched;} } } keys.c=true; }
            if(c==='KeyZ'){ if(!keys.z){ slideTimer=0; if(isProne){isProne=false; isCrouched=true;} else {isProne=true; isCrouched=false; qToggled=false; eToggled=false;} } keys.z=true; }
            if(c==='Digit1')switchWeapon(0); if(c==='Digit2')switchWeapon(1); if(c==='Digit3')switchWeapon(2); if(c==='KeyF'&&currentWeaponIndex===2&&(keys.rmb||keys.space))sniperZoomLevel=Math.min(10,sniperZoomLevel+1); if(c==='KeyG'&&currentWeaponIndex===2&&(keys.rmb||keys.space))sniperZoomLevel=Math.max(2,sniperZoomLevel-1);
            if(c==='KeyR'){ if(mountedTurret&&!mountedTurret.isReloading&&mountedTurret.ammo<mountedTurret.maxAmmo){ mountedTurret.isReloading=true; mountedTurret.reloadTimer=0.6; } }
            if(c==='KeyT'&&!playerAI.dead){ if(mountedTurret){ mountedTurret.user=null; mountedTurret=null; if(currentWeaponIndex===2)modelSniper.visible=true; weaponContainer.visible=true; } else { let n=null, mD=3.0; turrets.forEach(t=>{ const cC=!t.user||(t.user&&!t.user.isEnemy&&t.user!==playerAI); if(cC&&playerRoot.position.distanceTo(t.mesh.position)<mD){ n=t; mD=playerRoot.position.distanceTo(t.mesh.position); } }); if(n){ mountedTurret=n; n.user=playerAI; weaponContainer.visible=false; isCrouched=false; isProne=false; slideTimer=0; yaw=n.swivel.rotation.y; pitch=n.pitchGroup.rotation.x; } } }
        });

        document.addEventListener('keyup', e=>{ const c=e.code; if(c==='KeyW')keys.w=false; if(c==='KeyA')keys.a=false; if(c==='KeyS')keys.s=false; if(c==='KeyD')keys.d=false; if(c==='ShiftLeft'||c==='ShiftRight')keys.shift=false; if(c==='KeyQ')keys.q=false; if(c==='KeyE')keys.e=false; if(c==='Space')keys.space=false; if(c==='KeyZ')keys.z=false; if(c==='KeyC')keys.c=false; });
        document.addEventListener('mousedown', e=>{ if(!document.pointerLockElement)return; if(e.button===2)keys.rmb=true; if(e.button===0){keys.lmb=true; lmbJustPressed=true;} }); document.addEventListener('mouseup', e=>{ if(e.button===2)keys.rmb=false; if(e.button===0)keys.lmb=false; }); document.addEventListener('contextmenu', e=>e.preventDefault());

        const raycaster = new THREE.Raycaster(); const lastShotTimes = [0,0,0];

        function shootPlayer() {
            if(playerAI.dead||(currentWeaponIndex===1&&mgOverheated))return; const now=performance.now(), wep=weaponsData[currentWeaponIndex];
            if(currentWeaponIndex===2){ if(sniperNeedsRechamber)return; } else { if(now-lastShotTimes[currentWeaponIndex]<wep.fireRate)return; }
            lastShotTimes[currentWeaponIndex]=now; if(currentWeaponIndex===1){mgHeat+=8; if(mgHeat>=100){mgHeat=100; mgOverheated=true;}} if(currentWeaponIndex===2){sniperNeedsRechamber=true; sniperRechamberStartTime=now;}
            playSoundFile('gunshot',wep.soundPitch,wep.id==='sniper'?1.5:1.0);
            const barrelPos=new THREE.Vector3(0,0,wep.barrelLen).applyMatrix4(weaponContainer.matrixWorld), camDir=new THREE.Vector3(0,0,-1).applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
            if(wep.type==='auto'){ let sM=1.0; if(isProne)sM=0.25; else if(isCrouched)sM=0.6; if(keys.w||keys.a||keys.s||keys.d)sM*=1.5; let cS=(0.005+(mgHeat/100)*0.05)*sM; camDir.x+=(Math.random()-0.5)*cS; camDir.y+=(Math.random()-0.5)*cS; camDir.normalize(); }
            fpFlashMaterial.opacity=1.0; fpFlashLight.intensity=2.0; fpFlashGroup.rotation.z=Math.random()*Math.PI; fpFlashGroup.scale.set((Math.random()>0.5?1:-1)*(0.8+Math.random()*0.4),(Math.random()>0.5?1:-1)*(0.8+Math.random()*0.4),1);
            raycaster.setFromCamera(new THREE.Vector2(0,0),camera); if(wep.type==='auto')raycaster.set(camera.getWorldPosition(new THREE.Vector3()),camDir);
            const allAIMeshes=[...enemies.map(e=>e.mesh),...allies.map(a=>a.mesh)], intersectsDeep=raycaster.intersectObjects([...worldMeshes,...allAIMeshes],true);
            let hitDistance=200;
            if(intersectsDeep.length>0){
                const hit=intersectsDeep[0]; hitDistance=hit.distance; const hitObj=hit.object;
                if(hitObj.userData.ai){ const isHead=hitObj.name==="head"; hitObj.userData.ai.takeDamage(isHead?99:(currentWeaponIndex===2?5:1),playerAI); const marker=document.getElementById('hit-marker'); marker.style.opacity=1; marker.style.borderColor=isHead?'red':'white'; setTimeout(()=>marker.style.opacity=0,100); playPositionalSound(hit.point,'impact'); } 
                else { let n=new THREE.Vector3(0,1,0); if(hit.face)n.copy(hit.face.normal).applyMatrix3(new THREE.Matrix3().getNormalMatrix(hitObj.matrixWorld)).normalize(); createImpact(hit.point,n); playPositionalSound(hit.point,'impact'); if(Math.random()<0.6){ let ref=camDir.clone().sub(n.clone().multiplyScalar(2*camDir.dot(n))).normalize(); ref.x+=(Math.random()-0.5)*0.3; ref.y+=Math.random()*0.4; ref.z+=(Math.random()-0.5)*0.3; ref.normalize(); createTracer(hit.point,ref,60); if(camera.getWorldPosition(new THREE.Vector3()).distanceToSquared(hit.point)<64.0)playSoundFile('whiz',1.5+Math.random()*0.5,0.2); } }
            }
            if(Math.random()<tracerProbability)createTracer(barrelPos,camDir,hitDistance);
            const bulletRay=new THREE.Ray(barrelPos,camDir); let closestPt=new THREE.Vector3();
            [...enemies,...allies].forEach(e=>{ if(!e.dead){ const posOffset=e.crouchT*0.45+(e.crawlT*0.8||0); const ePos=e.mesh.position.clone().add(new THREE.Vector3(0,1.0-posOffset,0)); bulletRay.closestPointToPoint(ePos,closestPt); if(barrelPos.distanceTo(closestPt)<hitDistance+1.0){ if(closestPt.distanceToSquared(ePos)<16.0)e.alert(playerAI); } } });
            let aR=wep.recoilPitch*(0.8+Math.random()*0.4); pitch+=aR; pitch=Math.max(-Math.PI/2,Math.min(Math.PI/2,pitch)); pitchObject.rotation.x=pitch;
            if(wep.type==='auto'){ yaw+=(Math.random()-0.5)*aR*1.5; playerRoot.rotation.y=yaw; weaponContainer.rotation.z+=(Math.random()-0.5)*0.15; weaponContainer.rotation.x-=Math.random()*0.05; weaponContainer.rotation.y+=(Math.random()-0.5)*0.05; }
            weaponContainer.position.z+=wep.recoilZ;
        }

        function shootTurret(turret, shooter) {
            if(turret.isReloading||turret.ammo<=0)return; const now=performance.now(), cooldown=(shooter&&shooter.isPlayer)?600:1800; if(now-turret.lastShot<cooldown)return; turret.lastShot=now; turret.ammo--;
            const barrelPos=new THREE.Vector3(0,0,-1.1).applyMatrix4(turret.pitchGroup.matrixWorld), dir=new THREE.Vector3(0,0,-1).applyQuaternion(turret.pitchGroup.getWorldQuaternion(new THREE.Quaternion()));
            let spread=0.02; if(shooter&&!shooter.isPlayer)spread=0.15; dir.x+=(Math.random()-0.5)*spread; dir.y+=(Math.random()-0.5)*spread; dir.z+=(Math.random()-0.5)*spread; dir.normalize();
            showMuzzleFlash(barrelPos,dir); playPositionalSound(barrelPos,'gunshot'); turret.pitchGroup.position.z+=0.3;
            raycaster.set(barrelPos,dir); const allAIMeshes=[...enemies.map(e=>e.mesh),...allies.map(a=>a.mesh),playerAI.mesh], intersects=raycaster.intersectObjects([...worldMeshes,...allAIMeshes],true);
            let hitDistance=200;
            if(intersects.length>0){
                const hit=intersects[0]; hitDistance=hit.distance; let n=hit.face?hit.face.normal.clone().applyMatrix3(new THREE.Matrix3().getNormalMatrix(hit.object.matrixWorld)).normalize():new THREE.Vector3(0,1,0);
                createImpact(hit.point,n); for(let i=0;i<8;i++)createImpact(hit.point.clone().add(new THREE.Vector3((Math.random()-0.5)*5,Math.random()*4,(Math.random()-0.5)*5)),n);
                createExplosion(hit.point); playPositionalSound(hit.point,'artillery'); const dTP=camera.getWorldPosition(new THREE.Vector3()).distanceTo(hit.point); if(dTP<50)currentScreenShake=Math.max(currentScreenShake,(1.0-(dTP/50))*0.6);
                const hitPool=[...allies,...enemies,playerAI]; hitPool.forEach(t=>{ if(!t.dead){ const posOffset=t.isPlayer?((isProne||slideTimer>0)?0.15:(isCrouched?0.4:1.0)):(1.0-(t.crouchT*0.45)-(t.crawlT*0.6||0)); const pos=t.isPlayer?playerRoot.position.clone():t.mesh.position.clone(); pos.y+=posOffset; if(pos.distanceTo(hit.point)<4.0)t.takeDamage(10,shooter); } });
                if(dTP<8.0)triggerShellShock(1.5);
            }
            if(Math.random()<tracerProbability)createTracer(barrelPos,dir,hitDistance);
            const bulletRay=new THREE.Ray(barrelPos,dir); const hitPool=[...allies,...enemies,playerAI]; let closestPt=new THREE.Vector3();
            hitPool.forEach(t=>{ if(!t.dead){ const posOffset=t.isPlayer?((isProne||slideTimer>0)?0.15:(isCrouched?0.4:1.0)):(1.0-(t.crouchT*0.45)-(t.crawlT*0.6||0)); const pos=t.isPlayer?playerRoot.position.clone():t.mesh.position.clone(); pos.y+=posOffset; bulletRay.closestPointToPoint(pos,closestPt); if(barrelPos.distanceTo(closestPt)<hitDistance+1.0){ const distSq=closestPt.distanceToSquared(pos); if(!t.isPlayer){ if(distSq<16.0)t.alert(shooter); }else{ if(distSq<2.0)playNearMissSound(); } } } });
        }

        function isSpotVisibleToPlayer(spot) {
            const camPos=camera.getWorldPosition(new THREE.Vector3()), spotPos=new THREE.Vector3(spot.x,spot.y+1.0,spot.z), dir=spotPos.clone().sub(camPos).normalize(), dist=camPos.distanceTo(spotPos);
            if(new THREE.Vector3(0,0,-1).applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion())).dot(dir)<0.3)return false;
            const intersects=new THREE.Raycaster(camPos,dir).intersectObjects(worldMeshes,false); return !(intersects.length>0&&intersects[0].distance<dist);
        }

        const allyMat=new THREE.MeshLambertMaterial({color:0x3b5030}), enemyMat=new THREE.MeshLambertMaterial({color:0x5a3030}), skinMat=new THREE.MeshLambertMaterial({color:0xdcb897}), helmetMatEnemy=new THREE.MeshLambertMaterial({color:0x3a2a2a}), helmetMatAlly=new THREE.MeshLambertMaterial({color:0x3a4a30});

        class AI {
            constructor(isEnemy) {
                this.isEnemy=isEnemy; this.mesh=new THREE.Group(); const uMat=isEnemy?enemyMat:allyMat, hMat=isEnemy?helmetMatEnemy:helmetMatAlly;
                this.bodyRoot=new THREE.Group(); this.mesh.add(this.bodyRoot); this.torso=new THREE.Group(); this.torso.position.y=0.3; this.bodyRoot.add(this.torso);
                const torsoM=new THREE.Mesh(new THREE.BoxGeometry(0.4,0.6,0.25),uMat); torsoM.userData.ai=this; this.torso.add(torsoM);
                this.headGroup=new THREE.Group(); this.headGroup.position.y=0.35; this.torso.add(this.headGroup);
                const head=new THREE.Mesh(new THREE.BoxGeometry(0.2,0.25,0.2),skinMat); head.position.y=0.125; head.name="head"; head.userData.ai=this;
                const helm=new THREE.Mesh(new THREE.BoxGeometry(0.25,0.15,0.25),hMat); helm.position.y=0.3; helm.name="head"; helm.userData.ai=this;
                const eyeM=new THREE.MeshLambertMaterial({color:0x111111}), lEye=new THREE.Mesh(new THREE.BoxGeometry(0.04,0.04,0.02),eyeM); lEye.position.set(-0.04,0.16,0.101); lEye.name="head"; lEye.userData.ai=this;
                const rEye=new THREE.Mesh(new THREE.BoxGeometry(0.04,0.04,0.02),eyeM); rEye.position.set(0.04,0.16,0.101); rEye.name="head"; rEye.userData.ai=this;
                const stach=new THREE.Mesh(new THREE.BoxGeometry(0.12,0.03,0.04),new THREE.MeshLambertMaterial({color:0x221100})); stach.position.set(0,0.10,0.115); stach.name="head"; stach.userData.ai=this;
                const mo=new THREE.Mesh(new THREE.BoxGeometry(0.06,0.02,0.02),new THREE.MeshLambertMaterial({color:0x3a0505})); mo.position.set(0,0.06,0.101); mo.name="head"; mo.userData.ai=this;
                this.headGroup.add(head,helm,lEye,rEye,stach,mo);
                this.leftArm=new THREE.Group(); this.leftArm.position.set(-0.25,0.2,0); this.torso.add(this.leftArm); const luAm=new THREE.Mesh(new THREE.BoxGeometry(0.12,0.28,0.12),uMat); luAm.position.y=-0.14; luAm.userData.ai=this; this.leftArm.add(luAm);
                this.leftForearm=new THREE.Group(); this.leftForearm.position.set(0,-0.28,0); this.leftArm.add(this.leftForearm); const llAm=new THREE.Mesh(new THREE.BoxGeometry(0.1,0.25,0.1),uMat); llAm.position.y=-0.125; llAm.userData.ai=this; const lh=new THREE.Mesh(new THREE.BoxGeometry(0.08,0.12,0.08),skinMat); lh.position.set(0,-0.3,0); this.leftForearm.add(llAm,lh);
                this.rightArm=new THREE.Group(); this.rightArm.position.set(0.25,0.2,0); this.torso.add(this.rightArm); const ruAm=new THREE.Mesh(new THREE.BoxGeometry(0.12,0.28,0.12),uMat); ruAm.position.y=-0.14; ruAm.userData.ai=this; this.rightArm.add(ruAm);
                this.rightForearm=new THREE.Group(); this.rightForearm.position.set(0,-0.28,0); this.rightArm.add(this.rightForearm); const rlAm=new THREE.Mesh(new THREE.BoxGeometry(0.1,0.25,0.1),uMat); rlAm.position.y=-0.125; rlAm.userData.ai=this; const rh=new THREE.Mesh(new THREE.BoxGeometry(0.08,0.12,0.08),skinMat); rh.position.set(0,-0.3,0); this.rightForearm.add(rlAm,rh);
                this.weaponGroup=new THREE.Group(); const wb=new THREE.Mesh(new THREE.CylinderGeometry(0.012,0.015,0.9,8),new THREE.MeshLambertMaterial({color:0x222222})); wb.rotation.x=Math.PI/2; wb.position.set(0,0,0.45); const wr=new THREE.Mesh(new THREE.BoxGeometry(0.04,0.06,0.25),new THREE.MeshLambertMaterial({color:0x1a1a1a})); wr.position.set(0,0.01,0.15); const ws=new THREE.Mesh(new THREE.BoxGeometry(0.05,0.12,0.4),new THREE.MeshLambertMaterial({color:0x4a2e15})); ws.position.set(0,-0.03,-0.1); const wh=new THREE.Mesh(new THREE.BoxGeometry(0.045,0.04,0.5),new THREE.MeshLambertMaterial({color:0x4a2e15})); wh.position.set(0,-0.01,0.4); const wbl=new THREE.Mesh(new THREE.CylinderGeometry(0.005,0.005,0.04),new THREE.MeshLambertMaterial({color:0x333333})); wbl.rotation.z=Math.PI/2; wbl.position.set(0.025,0.02,0.1); this.weaponGroup.add(wb,wr,ws,wh,wbl); this.torso.add(this.weaponGroup);
                this.leftLeg=new THREE.Group(); this.leftLeg.position.set(-0.12,0,0); this.bodyRoot.add(this.leftLeg); const lt=new THREE.Mesh(new THREE.BoxGeometry(0.15,0.4,0.15),uMat); lt.position.y=-0.2; lt.userData.ai=this; this.leftLeg.add(lt); this.leftCalf=new THREE.Group(); this.leftCalf.position.set(0,-0.4,0); this.leftLeg.add(this.leftCalf); const lc=new THREE.Mesh(new THREE.BoxGeometry(0.13,0.45,0.13),uMat); lc.position.y=-0.2; lc.userData.ai=this; this.leftCalf.add(lc);
                this.rightLeg=new THREE.Group(); this.rightLeg.position.set(0.12,0,0); this.bodyRoot.add(this.rightLeg); const rt=new THREE.Mesh(new THREE.BoxGeometry(0.15,0.4,0.15),uMat); rt.position.y=-0.2; rt.userData.ai=this; this.rightLeg.add(rt); this.rightCalf=new THREE.Group(); this.rightCalf.position.set(0,-0.4,0); this.rightLeg.add(this.rightCalf); const rc=new THREE.Mesh(new THREE.BoxGeometry(0.13,0.45,0.13),uMat); rc.position.y=-0.2; rc.userData.ai=this; this.rightCalf.add(rc);
                scene.add(this.mesh); this.dead=true; this.timer=Math.random()*2; this.crouchT=1.0; this.aimT=0.0; this.walkTime=Math.random()*10; this.turretUseT=0.0; this.isCrawling=false; this.crawlT=0.0; this.retreatCooldown=0; this.respawn();
            }

            getDesiredCovers(tier=this.coverTier) {
                if(this.isEnemy){ if(tier===0)return enemyCovers[0]; if(tier===1)return enemyCovers[1]; if(tier===2)return enemyCovers[2]; if(tier===3)return enemyCovers[3]; if(tier===4)return allyCovers[3]; if(tier===5)return allyCovers[2]; if(tier===6)return allyCovers[1]; return allyCovers[0]; } 
                else { if(tier===0)return allyCovers[0]; if(tier===1)return allyCovers[1]; if(tier===2)return allyCovers[2]; if(tier===3)return allyCovers[3]; if(tier===4)return enemyCovers[3]; if(tier===5)return enemyCovers[2]; if(tier===6)return enemyCovers[1]; return enemyCovers[0]; }
            }

            pickCover(isSpawning=false) {
                const peers=this.isEnemy?enemies:allies; let foundCover=false, originalTier=this.coverTier, furthestFallback=null, furthDSq=-1;
                while(!foundCover&&this.coverTier<=7){
                    let myCovers=this.getDesiredCovers(this.coverTier);
                    let eTurrets=myCovers.filter(c=>{ if(!c.isTurret)return false; if(c.turret.user&&c.turret.user!==this&&!c.turret.user.dead)return false; if(peers.some(p=>p!==this&&!p.dead&&p.targetCover===c))return false; return true; });
                    let vT=eTurrets; if(isSpawning){ vT=eTurrets.filter(c=>{ let vis=isSpotVisibleToPlayer(c); if(vis){ let d=playerRoot.position.distanceToSquared(new THREE.Vector3(c.x,c.y,c.z)); if(d>furthDSq){furthDSq=d; furthestFallback=c;} } return !vis; }); }
                    if(vT.length>0&&(!this.isAdvancing||Math.random()<0.2)){ this.targetCover=vT[Math.floor(Math.random()*vT.length)]; foundCover=true; break; }
                    let av=myCovers.filter(c=>!c.isTurret&&!peers.some(p=>p!==this&&!p.dead&&p.targetCover===c));
                    if(isSpawning){ av=av.filter(c=>{ let vis=isSpotVisibleToPlayer(c); if(vis){ let d=playerRoot.position.distanceToSquared(new THREE.Vector3(c.x,c.y,c.z)); if(d>furthDSq){furthDSq=d; furthestFallback=c;} } return !vis; }); }
                    if(av.length>0){
                        av.sort((a,b)=>{ let dA=0,dB=0; deathHotspots.forEach(h=>{ let da=(a.x-h.x)**2+(a.z-h.z)**2; if(da<625)dA+=(625-da); let db=(b.x-h.x)**2+(b.z-h.z)**2; if(db<625)dB+=(625-db); }); return dA-dB; });
                        this.targetCover=av[Math.floor(Math.random()*Math.min(3,av.length))]; foundCover=true;
                    }else{ this.isAdvancing=true; this.coverTier++; }
                }
                if(!foundCover){ if(isSpawning&&furthestFallback)this.targetCover=furthestFallback; else{ this.coverTier=originalTier; let mc=this.getDesiredCovers(); if(mc&&mc.length>0)this.targetCover=mc[Math.floor(Math.random()*mc.length)]; } }
            }

            respawn() {
                this.hp=Math.floor(Math.random()*2)+1; this.dead=false; this.mesh.visible=true; this.state='hidden'; this.mesh.rotation.x=0; this.deathAnimT=0; this.crouchT=1.0; this.aimT=0.0; this.turretUseT=0.0;
                this.bodyRoot.position.y=0.85-(1.0*0.45); this.torso.rotation.x=1.0*0.4; this.headGroup.rotation.x=-this.torso.rotation.x; 
                this.rightArm.rotation.set(-0.4,-0.2,0.1); this.leftArm.rotation.set(-0.3,0.4,-0.2); this.rightForearm.rotation.x=-0.6; this.leftForearm.rotation.x=-1.2;
                this.rightLeg.rotation.set(-1.2,0,-0.15); this.leftLeg.rotation.set(-1.2,0,0.15); this.rightCalf.rotation.set(2.0,0,0); this.leftCalf.rotation.set(2.0,0,0);
                this.weaponGroup.position.set(0.05,-0.15,0.35); this.weaponGroup.rotation.set(0.4,0.5,-0.1);
                if(this.targetCover&&this.targetCover.isTurret&&this.targetCover.turret.user===this)this.targetCover.turret.user=null;
                this.isCrawling=false; this.crawlT=0.0; this.retreatCooldown=0; this.timer=0.5+Math.random(); this.target=null; this.targetCover=null; this.scanBaseYaw=this.isEnemy?Math.PI:0; this.shootDelay=0;
                const t=this.isEnemy?enemies:allies; let lC=0, adv=0; for(let i=0;i<t.length;i++){ if(!t[i].dead&&t[i]!==this){lC++; if(t[i].isAdvancing)adv++;} } lC++; 
                this.isAdvancing=(adv/lC)<0.6; this.coverTier=Math.floor(Math.random()*2); this.interruptedMove=false; this.pickCover(true);
                if(this.targetCover)this.mesh.position.set(this.targetCover.x,getTerrainHeight(this.targetCover.x,this.targetCover.z),this.targetCover.z);
            }

            alert(attacker) {
                if(this.dead||!attacker||attacker.dead)return;
                
                // Identify if the attacker is an actual enemy or a friend (like the player shooting near an ally)
                let isThreat = this.isEnemy ? (attacker.isPlayer || !attacker.isEnemy) : (!attacker.isPlayer && attacker.isEnemy);
                if (!isThreat) return;

                if(!this.target||Math.random()<0.8){ this.target=attacker; let tP=attacker.isPlayer?camera.getWorldPosition(new THREE.Vector3()):attacker.mesh.position.clone(); this.scanBaseYaw=Math.atan2(tP.x-this.mesh.position.x,tP.z-this.mesh.position.z); }
                if(this.state==='moving'){ if(Math.random()<0.5&&Math.abs(this.mesh.position.z)<40){this.isCrawling=true;}else{this.state='aiming'; this.timer=0.4+Math.random()*0.4; this.shootDelay=0; this.interruptedMove=true; this.isCrawling=false;} }
                else if(this.state==='hidden'&&Math.random()<0.8){this.state='popping'; this.timer=0.2;} else if(this.state==='aiming'||this.state==='shooting'){this.state='aiming'; this.timer=0.5+Math.random();}
            }

            takeDamage(amount, attacker) {
                if(this.dead||this.hp<=0)return; if(attacker&&!attacker.isPlayer&&attacker.isEnemy===this.isEnemy)return;
                if(attacker&&!attacker.isPlayer)amount=0.05; this.hp-=amount;
                if(this.hp<=0){
                    this.dead=true; if(this.targetCover&&this.targetCover.isTurret&&this.targetCover.turret.user===this)this.targetCover.turret.user=null;
                    this.deathAnimT=0.0; this.corpseDelay=2.0; this.timer=3+Math.random()*2; deathHotspots.push({x:this.mesh.position.x,z:this.mesh.position.z,time:performance.now()});
                    if(attacker===playerAI&&this.isEnemy){playerKills++; document.getElementById('kill-count-indicator').innerText=`Kills: ${playerKills}`;}
                }else if(attacker&&!attacker.dead){ 
                    let isThreat = this.isEnemy ? (attacker.isPlayer || !attacker.isEnemy) : (!attacker.isPlayer && attacker.isEnemy);
                    if(isThreat)this.alert(attacker); 
                    if(this.state==='aiming'||this.state==='popping')this.timer+=0.2; 
                }
            }

            update(dt) {
                if(this.dead){
                    if(this.deathAnimT<1.0){
                        this.deathAnimT+=dt*3.0; if(this.deathAnimT>1.0)this.deathAnimT=1.0; this.mesh.rotation.x=this.deathAnimT*(-Math.PI/2+0.1); this.bodyRoot.position.y=0.85-(this.crouchT*0.45)-(this.deathAnimT*0.6);
                        this.rightArm.rotation.x+=(0.1-this.rightArm.rotation.x)*10*dt; this.leftArm.rotation.x+=(0.1-this.leftArm.rotation.x)*10*dt; this.rightArm.rotation.z+=(0.2-this.rightArm.rotation.z)*10*dt; this.leftArm.rotation.z+=(-0.2-this.leftArm.rotation.z)*10*dt; this.leftArm.rotation.y+=(0-this.leftArm.rotation.y)*10*dt;
                        this.rightForearm.rotation.x+=(0-this.rightForearm.rotation.x)*10*dt; this.leftForearm.rotation.x+=(0-this.leftForearm.rotation.x)*10*dt;
                        this.weaponGroup.position.lerp(new THREE.Vector3(0.2,-0.4,0.1),10*dt); this.weaponGroup.rotation.x+=(Math.PI/2-this.weaponGroup.rotation.x)*10*dt;
                        this.leftLeg.rotation.x+=(0-this.leftLeg.rotation.x)*10*dt; this.rightLeg.rotation.x+=(0-this.rightLeg.rotation.x)*10*dt; this.leftCalf.rotation.x+=(0-this.leftCalf.rotation.x)*10*dt; this.rightCalf.rotation.x+=(0-this.rightCalf.rotation.x)*10*dt;
                        this.crouchT+=(0-this.crouchT)*5*dt; this.torso.rotation.x=this.crouchT*0.4; this.headGroup.rotation.x=-this.torso.rotation.x; this.mesh.position.y=getTerrainHeight(this.mesh.position.x,this.mesh.position.z);
                    }else if(this.corpseDelay>0){this.corpseDelay-=dt;}else{
                        if(this.mesh.visible)this.mesh.visible=false; this.timer-=dt;
                        if(this.timer<=0){ if(gameMode==='endless')this.respawn(); else if(gameMode==='elimination'){if(this.isEnemy&&enemyReserves>0){enemyReserves--;this.respawn();}else if(!this.isEnemy&&allyReserves>0){allyReserves--;this.respawn();}} }
                    } return;
                }

                this.timer-=dt; let stX=this.mesh.position.x, stZ=this.mesh.position.z, cTDSq=Infinity;
                if(this.target&&!this.target.dead)cTDSq=this.mesh.position.distanceToSquared(this.target.isPlayer?playerRoot.position:this.target.mesh.position);
                let cThreat=null, cDSq=Infinity, eN=0, aN=0, myFwd=new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0),this.mesh.rotation.y), opF=this.isEnemy?[...allies,playerAI]:enemies;
                for(let i=0;i<opF.length;i++){
                    const th=opF[i]; if(!th.dead){ const tp=th.isPlayer?playerRoot.position:th.mesh.position; let dSq=this.mesh.position.distanceToSquared(tp);
                    if(dSq<400)eN++; if(dSq>10000)continue; const toTh=tp.clone().sub(this.mesh.position).normalize(); const dot=myFwd.dot(toTh);
                    if(dot>-0.2||dSq<225){ if(dSq<cDSq){cDSq=dSq; cThreat=th;} } }
                }

                if(cThreat&&this.target!==cThreat){
                    let sw=false; if(!this.target||this.target.dead)sw=true; else if(cDSq<225&&cTDSq>225)sw=true; else if(cDSq<cTDSq*0.6)sw=true;
                    if(sw&&this.calculateExposure(cThreat)>0){
                        this.target=cThreat; const tP=cThreat.isPlayer?camera.getWorldPosition(new THREE.Vector3()):cThreat.mesh.position.clone(); this.scanBaseYaw=Math.atan2(tP.x-this.mesh.position.x,tP.z-this.mesh.position.z);
                        if(this.state==='moving')this.interruptedMove=true;
                        if(this.state!=='using_turret'){ if(this.state==='shooting'||this.state==='aiming'){this.state='aiming';this.shootDelay=0.1;}else{this.state='aiming';this.shootDelay=0.2+Math.random()*0.2;this.isCrawling=false;} }
                    }
                }

                if(this.retreatCooldown>0)this.retreatCooldown-=dt;
                if(this.state!=='using_turret'&&this.retreatCooldown<=0){
                    const p=this.isEnemy?enemies:allies; for(let i=0;i<p.length;i++){if(p[i]!==this&&!p[i].dead){let cdx=this.mesh.position.x-p[i].mesh.position.x, cdz=this.mesh.position.z-p[i].mesh.position.z; if(cdx*cdx+cdz*cdz<400)aN++;}}
                    if(aN===0&&eN>=2&&this.coverTier>0){ this.coverTier--; this.isAdvancing=false; this.isCrawling=false; this.pickCover(); this.state='moving'; this.timer=0; this.target=null; this.retreatCooldown=5.0; }
                }

                let tCr=0.0, tAm=0.0, tTu=0.0, isC=true;
                if(this.targetCover&&!this.targetCover.isTurret){ let cdx=this.targetCover.x-this.mesh.position.x, cdz=this.targetCover.z-this.mesh.position.z; if(cdx*cdx+cdz*cdz>2.25)isC=false; }

                switch(this.state){
                    case 'moving':
                        tCr=0.5; const mS=this.isCrawling?2.0:(this.isAdvancing?6.5:4.5); if(!this.targetCover){this.pickCover();if(!this.targetCover)break;}
                        let dX=this.targetCover.x, dZ=this.targetCover.z, cX=this.mesh.position.x, cZ=this.mesh.position.z, tX=dX, tZ=dZ;
                        const inZ=z=>{let az=Math.abs(z); if(az>=18&&az<=32)return Math.sign(z)*25; if(az>=38&&az<=52)return Math.sign(z)*45; if(az>=58&&az<=70)return Math.sign(z)*64; return 0;};
                        const gPX=x=>{const g=[-60,-20,20,60]; let c=g[0], md=Math.abs(x-c); for(let i=1;i<g.length;i++){if(Math.abs(x-g[i])<md){md=Math.abs(x-g[i]); c=g[i];}} return c;};
                        let cS=inZ(cZ); if(cS!==0){tX=gPX(cX);tZ=dZ;}else{ const crs=(c,d,s)=>(c<s&&d>s)||(c>s&&d<s), sC=[-64,-45,-25,25,45,64]; let sTC=0, mD=Infinity; for(let s of sC){if(crs(cZ,dZ,s)){let d=Math.abs(cZ-s);if(d<mD){mD=d;sTC=s;}}} if(sTC!==0){let px=gPX(cX); if(Math.abs(cX-px)>1.5){tX=px;tZ=cZ;}else{tX=px;tZ=sTC;}} }
                        let dx=tX-cX, dz=tZ-cZ, dist=Math.sqrt(dx*dx+dz*dz), fdX=dX-cX, fdZ=dZ-cZ, fDist=Math.sqrt(fdX*fdX+fdZ*fdZ);
                        if(fDist<0.2){ if(this.targetCover&&this.targetCover.isTurret){this.state='hidden'; this.timer=0.1;}else{this.state='hidden';this.timer=0.2+Math.random()*0.3;} this.isCrawling=false; }
                        else{ if(dist<0.1){dx=fdX; dz=fdZ; dist=fDist;} this.mesh.position.x+=(dx/dist)*mS*dt; this.mesh.position.z+=(dz/dist)*mS*dt; let dY=Math.atan2(dx,dz)-this.mesh.rotation.y; while(dY<-Math.PI)dY+=Math.PI*2; while(dY>Math.PI)dY-=Math.PI*2; this.mesh.rotation.y+=dY*10*dt; }
                        break;
                    case 'hidden':
                        tCr=1.0; this.isCrawling=false;
                        if(this.timer<=0){ if(this.targetCover&&this.targetCover.isTurret){ if(!this.targetCover.turret.user||this.targetCover.turret.user===this)this.state='using_turret'; else{this.pickCover();this.state='moving';} }else{ if(this.isAdvancing&&!this.target&&Math.random()<0.8&&this.coverTier<7){this.coverTier++;this.pickCover();this.state='moving';}else{this.state='popping';this.timer=this.isAdvancing?0.15:0.3;} } }
                        break;
                    case 'using_turret':
                        tCr=0.0; tAm=0.0; tTu=1.0; this.isCrawling=false; const tr=this.targetCover?this.targetCover.turret:null; if(!tr||(tr.user&&tr.user!==this)){this.state='hidden';break;} tr.user=this;
                        let bV=new THREE.Vector3(0,0,0.85); bV.applyAxisAngle(new THREE.Vector3(0,1,0),tr.swivel.rotation.y); this.mesh.position.x=tr.mesh.position.x+bV.x; this.mesh.position.z=tr.mesh.position.z+bV.z; this.mesh.position.y=getTerrainHeight(this.mesh.position.x,this.mesh.position.z); if(getTerrainHeight(this.mesh.position.x,this.mesh.position.z)<-0.5)this.mesh.position.y=-0.45+0.75;
                        if(tr.isReloading||tr.ammo<=0){ this.shootDelay=0.5+Math.random()*0.5; tr.swivel.rotation.y+=(this.scanBaseYaw-tr.swivel.rotation.y)*2*dt; tr.pitchGroup.rotation.x+=(0-tr.pitchGroup.rotation.x)*2*dt; this.mesh.rotation.y=tr.swivel.rotation.y+Math.PI; }
                        else if(this.target&&!this.target.dead&&this.checkLOS(this.target)){ let tP=new THREE.Vector3(); if(this.target.isPlayer)camera.getWorldPosition(tP); else tP.copy(this.target.mesh.position); let tTY=Math.atan2(tP.x-tr.mesh.position.x, tP.z-tr.mesh.position.z)+Math.PI, aYD=tTY-tr.baseYaw; while(aYD<-Math.PI)aYD+=Math.PI*2; while(aYD>Math.PI)aYD-=Math.PI*2; if(aYD>Math.PI/2)tTY=tr.baseYaw+Math.PI/2; if(aYD<-Math.PI/2)tTY=tr.baseYaw-Math.PI/2; let tD=tTY-tr.swivel.rotation.y; while(tD<-Math.PI)tD+=Math.PI*2; while(tD>Math.PI)tD-=Math.PI*2; tr.swivel.rotation.y+=tD*5*dt; const t2D=Math.sqrt((tP.x-tr.mesh.position.x)**2+(tP.z-tr.mesh.position.z)**2); tr.pitchGroup.rotation.x+=(Math.atan2(tP.y-(tr.mesh.position.y+0.3),t2D)-tr.pitchGroup.rotation.x)*5*dt; this.mesh.rotation.y=tr.swivel.rotation.y+Math.PI; if(this.shootDelay<=0){if(Math.abs(tD)<0.2){shootTurret(tr,this);this.shootDelay=1.8+Math.random()*0.4;}}else{this.shootDelay-=dt;} }
                        else { this.target=this.findTarget(); this.shootDelay=0.5+Math.random()*0.5; tr.swivel.rotation.y+=(this.scanBaseYaw-tr.swivel.rotation.y)*2*dt; tr.pitchGroup.rotation.x+=(0-tr.pitchGroup.rotation.x)*2*dt; this.mesh.rotation.y=tr.swivel.rotation.y+Math.PI; }
                        break;
                    case 'popping':
                        tCr=isC?0.0:1.0; tAm=1.0; if(this.target)this.aimAtTarget(dt); if(this.timer<=0){this.state='aiming'; this.timer=this.isAdvancing?(0.3+Math.random()*0.5):(0.5+Math.random()*1.0); if(!this.target||this.target.dead||!this.checkLOS(this.target))this.target=this.findTarget(); else this.shootDelay=0.1+Math.random()*0.2;}
                        break;
                    case 'aiming':
                        tCr=isC?0.0:1.0; tAm=1.0; if(this.target&&!this.target.dead&&this.checkLOS(this.target)){this.aimAtTarget(dt); if(this.shootDelay<=0){this.state='shooting'; this.shotsFired=0; this.shotsToFire=3+Math.floor(Math.random()*4); this.timer=0.1;}else this.shootDelay-=dt;}
                        else{ this.target=this.findTarget(); this.shootDelay=0.1+Math.random()*0.2; this.mesh.rotation.y=this.scanBaseYaw+Math.sin(performance.now()*0.002+this.mesh.id)*0.5; if(this.timer<=0){ if(this.isAdvancing&&this.coverTier<7&&Math.random()<0.7){this.coverTier++;this.pickCover();this.state='moving';}else{this.state='hidden';this.timer=this.isAdvancing?(0.2+Math.random()*0.4):(0.5+Math.random());} } }
                        break;
                    case 'shooting':
                        tCr=isC?0.0:1.0; tAm=1.0; if(!this.target||this.target.dead||!this.checkLOS(this.target)){this.state='hidden'; this.timer=0.5+Math.random(); break;} this.aimAtTarget(dt);
                        if(this.timer<=0){ this.shoot(); this.shotsFired++; this.timer=0.15+Math.random()*0.15; if(this.shotsFired>=this.shotsToFire){ if(this.interruptedMove){this.interruptedMove=false; this.state='moving';} else if(this.isAdvancing&&this.coverTier<7&&Math.random()<0.95){this.coverTier++; this.pickCover(); this.state='moving';} else if(this.isAdvancing&&Math.random()<0.2){this.pickCover(); this.state='moving';} else { if(!this.isAdvancing){ let lV=0, aV=0; (this.isEnemy?enemies:allies).forEach(s=>{if(!s.dead){lV++;if(s.isAdvancing)aV++;}}); if(aV/lV<0.6)this.isAdvancing=true; } this.state='hidden'; this.timer=this.isAdvancing?(0.2+Math.random()*0.4):(0.5+Math.random()*1.0); } } }
                        break;
                }

                this.crouchT+=(tCr-this.crouchT)*10*dt; this.aimT+=(tAm-this.aimT)*12*dt; this.turretUseT+=(tTu-this.turretUseT)*10*dt; this.crawlT+=((this.isCrawling?1.0:0.0)-this.crawlT)*10*dt;
                let eC=this.crouchT*(1.0-this.crawlT); this.bodyRoot.position.y=0.85-(eC*0.45)-(this.crawlT*0.65); this.torso.rotation.x=(eC*0.4)+(this.crawlT*(Math.PI/2)); this.headGroup.rotation.x=-this.torso.rotation.x+(this.crawlT*0.2); if(!this.dead)this.mesh.rotation.x=0;
                let lS=0, aS=0; if(this.state==='moving'){this.walkTime+=dt*(this.isCrawling?4:10); lS=Math.sin(this.walkTime)*(this.isCrawling?0.2:0.6); aS=Math.sin(this.walkTime)*(this.isCrawling?0.15:0.3);} else{this.walkTime=0;}
                const sTR=-1.2*eC+(this.crawlT*(-Math.PI/2+0.1)), sCR=2.0*eC+(this.crawlT*0.1); this.leftLeg.rotation.z=0.15*eC+(this.crawlT*0.2); this.rightLeg.rotation.z=-0.15*eC-(this.crawlT*0.2);
                this.leftLeg.rotation.x=sTR+lS; this.leftCalf.rotation.x=sCR; if(lS<0)this.leftCalf.rotation.x+=lS*-0.5; this.rightLeg.rotation.x=sTR-lS; this.rightCalf.rotation.x=sCR; if(lS>0)this.rightCalf.rotation.x+=-lS*-0.5;
                
                const iGP=new THREE.Vector3(0.05,-0.15,0.35), iGR=new THREE.Euler(0.4,0.5,-0.1), aGP=new THREE.Vector3(0.12,0.15,-0.05), aGR=new THREE.Euler(0,0,0), tGP=new THREE.Vector3(0.2,-0.6,0.2), tGR=new THREE.Euler(1.5,0,0), cGP=new THREE.Vector3(0.0,0.2,0.1), cGR=new THREE.Euler(-Math.PI/2+0.2,0,0);
                let cG=iGP.clone().lerp(aGP,this.aimT).lerp(tGP,this.turretUseT), eCB=this.crawlT*(1.0-this.aimT); cG.lerp(cGP,eCB); this.weaponGroup.position.copy(cG);
                const tCX=this.torso.rotation.x*this.aimT; let wgX=iGR.x+(aGR.x-iGR.x)*this.aimT; wgX+=(tGR.x-wgX)*this.turretUseT; wgX-=tCX; wgX+=(cGR.x-wgX)*eCB; let wgY=iGR.y+(aGR.y-iGR.y)*this.aimT; wgY+=(tGR.y-wgY)*this.turretUseT; wgY+=(cGR.y-wgY)*eCB; let wgZ=iGR.z+(aGR.z-iGR.z)*this.aimT; wgZ+=(tGR.z-wgZ)*this.turretUseT; wgZ+=(cGR.z-wgZ)*eCB; this.weaponGroup.rotation.set(wgX,wgY,wgZ);
                if(this.state==='moving'&&!this.isCrawling){this.weaponGroup.position.y+=Math.sin(this.walkTime*2)*0.02; this.weaponGroup.rotation.x+=Math.sin(this.walkTime)*0.05;}
                
                const iRA=new THREE.Euler(-0.4,-0.2,0.1), aRA=new THREE.Euler(-1.2,-0.2,0.3), tRA=new THREE.Euler(-0.9,-0.1,0), iRF=new THREE.Euler(-0.6,0,0), aRF=new THREE.Euler(-2.4,0,0), tRF=new THREE.Euler(-0.3,0,0), iLA=new THREE.Euler(-0.3,0.4,-0.2), aLA=new THREE.Euler(-1.4,0.8,0), tLA=new THREE.Euler(-0.9,0.1,0), iLF=new THREE.Euler(-1.2,0,0), aLF=new THREE.Euler(-0.2,0,0), tLF=new THREE.Euler(-0.3,0,0), cRA=new THREE.Euler(-1.5,0,0.5), cRF=new THREE.Euler(-1.0,0,0), cLA=new THREE.Euler(-1.5,0,-0.5), cLF=new THREE.Euler(-1.0,0,0);
                let rX=iRA.x+(aRA.x-iRA.x)*this.aimT+(aS*(1-this.aimT)*(1-this.turretUseT)); rX+=(tRA.x-rX)*this.turretUseT; rX-=tCX; rX+=(cRA.x-rX)*eCB; let rY=iRA.y+(aRA.y-iRA.y)*this.aimT; rY+=(tRA.y-rY)*this.turretUseT; rY+=(cRA.y-rY)*eCB; let rZ=iRA.z+(aRA.z-iRA.z)*this.aimT; rZ+=(tRA.z-rZ)*this.turretUseT; rZ+=(cRA.z-rZ)*eCB; this.rightArm.rotation.set(rX,rY,rZ);
                let rFX=iRF.x+(aRF.x-iRF.x)*this.aimT; rFX+=(tRF.x-rFX)*this.turretUseT; rFX+=(cRF.x-rFX)*eCB; this.rightForearm.rotation.x=rFX;
                let lX=iLA.x+(aLA.x-iLA.x)*this.aimT-(aS*(1-this.aimT)*(1-this.turretUseT)); lX+=(tLA.x-lX)*this.turretUseT; lX-=tCX; lX+=(cLA.x-lX)*eCB; let lY=iLA.y+(aLA.y-iLA.y)*this.aimT; lY+=(tLA.y-lY)*this.turretUseT; lY+=(cLA.y-lY)*eCB; let lZ=iLA.z+(aLA.z-iLA.z)*this.aimT; lZ+=(tLA.z-lZ)*this.turretUseT; lZ+=(cLA.z-lZ)*eCB; this.leftArm.rotation.set(lX,lY,lZ);
                let lFX=iLF.x+(aLF.x-iLF.x)*this.aimT; lFX+=(tLF.x-lFX)*this.turretUseT; lFX+=(cLF.x-lFX)*eCB; this.leftForearm.rotation.x=lFX;

                (this.isEnemy?enemies:allies).forEach(p=>{ if(p!==this&&!p.dead){let cdx=this.mesh.position.x-p.mesh.position.x, cdz=this.mesh.position.z-p.mesh.position.z, dSq=cdx*cdx+cdz*cdz; if(dSq<0.64&&dSq>0.0001){let d=Math.sqrt(dSq), o=0.8-d, nx=cdx/d, nz=cdz/d; this.mesh.position.x+=(nx*0.6-nz*0.8)*o*5*dt; this.mesh.position.z+=(nz*0.6+nx*0.8)*o*5*dt;}} });
                let p2={x:this.mesh.position.x,z:this.mesh.position.z}; resolveObstacles(p2,0.4); this.mesh.position.x=Math.max(-95,Math.min(95,p2.x)); this.mesh.position.z=Math.max(-98,Math.min(98,p2.z));
                if(this.state==='moving'){ let mSq=(this.mesh.position.x-stX)**2+(this.mesh.position.z-stZ)**2; if(mSq<Math.pow((this.isAdvancing?6.5:4.5)*dt,2)*0.05){ this.mesh.position.x+=(Math.random()-0.5)*6.0*dt; this.mesh.position.z+=(Math.random()-0.5)*6.0*dt; let fP={x:this.mesh.position.x,z:this.mesh.position.z}; resolveObstacles(fP,0.4); this.mesh.position.x=Math.max(-95,Math.min(95,fP.x)); this.mesh.position.z=Math.max(-98,Math.min(98,fP.z)); } }
                if(this.state!=='moving'&&this.state!=='using_turret'&&this.targetCover&&!this.targetCover.isTurret){ let dx=this.targetCover.x-this.mesh.position.x, dz=this.targetCover.z-this.mesh.position.z; if(dx*dx+dz*dz<4.0){this.mesh.position.x+=dx*2*dt; this.mesh.position.z+=dz*2*dt;} }
                if(this.state!=='using_turret')this.mesh.position.y=getTerrainHeight(this.mesh.position.x,this.mesh.position.z);
            }

            calculateExposure(target) {
                const ho=1.55-(this.crouchT*0.45)-(this.crawlT*1.2), eS=this.mesh.position.clone().add(new THREE.Vector3(0,ho,0)); let pt;
                if(target.isPlayer){ const pP=isProne||slideTimer>0; pt=playerRoot.position.clone().add(new THREE.Vector3(0,pP?0.3:(isCrouched?0.8:1.5),0)); } 
                else { const cO=target.crouchT*0.45+(target.crawlT*1.2); pt=target.mesh.position.clone().add(new THREE.Vector3(0,1.55-cO,0)); }
                const d=pt.clone().sub(eS).normalize(), dist=eS.distanceTo(pt); raycaster.set(eS,d);
                const inters=raycaster.intersectObjects(worldMeshes,false); return (inters.length>0&&inters[0].distance<dist)?0:1; 
            }
            checkLOS(t){return this.calculateExposure(t)>0;}

            findTarget() {
                let ts=(this.isEnemy?[...allies,playerAI]:enemies).filter(t=>!t.dead&&t.hp>0); if(ts.length===0)return null;
                const mP=this.mesh.position, mF=new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0),this.mesh.rotation.y); let pT=[];
                for(let i=0;i<ts.length;i++){ const t=ts[i], tp=t.isPlayer?playerRoot.position:t.mesh.position, dSq=tp.distanceToSquared(mP); if(dSq>10000)continue; const toT=tp.clone().sub(mP).normalize(), dot=mF.dot(toT); if(dot<-0.2&&dSq>225)continue; pT.push({target:t,distSq:dSq}); }
                pT.sort((a,b)=>a.distSq-b.distSq); const ch=Math.min(5,pT.length); for(let i=0;i<ch;i++){ if(this.calculateExposure(pT[i].target)>0)return pT[i].target; } return null;
            }
            aimAtTarget(dt) {
                if(!this.target)return; let tP=new THREE.Vector3(); if(this.target.isPlayer)camera.getWorldPosition(tP); else tP.copy(this.target.mesh.position);
                let d=Math.atan2(tP.x-this.mesh.position.x,tP.z-this.mesh.position.z)-this.mesh.rotation.y; while(d<-Math.PI)d+=Math.PI*2; while(d>Math.PI)d-=Math.PI*2; this.mesh.rotation.y+=d*8*dt;
            }
            shoot() {
                if(!this.target||this.target.dead)return; const ho=1.55-(this.crouchT*0.45)-(this.crawlT*1.2), eS=this.mesh.position.clone().add(new THREE.Vector3(0,ho,0));
                this.weaponGroup.updateMatrixWorld(true); const vS=new THREE.Vector3(0,0,0.9).applyMatrix4(this.weaponGroup.matrixWorld);
                let tP=new THREE.Vector3(); if(this.target.isPlayer){camera.getWorldPosition(tP);tP.y-=0.2;}else{const tHO=1.55-(this.target.crouchT*0.45)-(this.target.crawlT*1.2);tP.copy(this.target.mesh.position).add(new THREE.Vector3(0,tHO,0));}
                const dir=tP.clone().sub(eS).normalize(), dist=eS.distanceTo(tP); let sp=0.01+(dist*0.001); if(!this.target.isPlayer)sp*=12.0; dir.x+=(Math.random()-0.5)*sp; dir.y+=(Math.random()-0.5)*sp; dir.z+=(Math.random()-0.5)*sp; dir.normalize();
                showMuzzleFlash(vS,dir); raycaster.set(eS,dir); if(this.shotsFired%4===0)playPositionalSound(vS,'gunshot');
                const hits=raycaster.intersectObjects([...worldMeshes,playerAI.mesh,...allies.map(a=>a.mesh),...enemies.map(e=>e.mesh)],true); let hD=200;
                if(hits.length>0){ const h=hits[0]; hD=h.distance; playPositionalSound(h.point,'impact'); if(h.object.userData.ai){ const hAI=h.object.userData.ai; if(hAI.isPlayer)hAI.takeDamage(1,this); else hAI.takeDamage(h.object.name==="head"?99:1,this); } else{ let n=new THREE.Vector3(0,1,0); if(h.face)n.copy(h.face.normal).applyMatrix3(new THREE.Matrix3().getNormalMatrix(h.object.matrixWorld)).normalize(); createImpact(h.point,n); if(Math.random()<0.6){let ref=dir.clone().sub(n.clone().multiplyScalar(2*dir.dot(n))).normalize(); ref.x+=(Math.random()-0.5)*0.3; ref.y+=Math.random()*0.4; ref.z+=(Math.random()-0.5)*0.3; ref.normalize(); createTracer(h.point,ref,60); if(camera.getWorldPosition(new THREE.Vector3()).distanceToSquared(h.point)<64.0)playSoundFile('whiz',1.5+Math.random()*0.5,0.2);} } }
                if(Math.random()<tracerProbability)createTracer(vS,dir,hD);
                const bR=new THREE.Ray(eS,dir), hp=[...allies,...enemies,playerAI]; let cP=new THREE.Vector3();
                hp.forEach(t=>{ if(!t.dead){ const pO=t.isPlayer?((isProne||slideTimer>0)?0.15:(isCrouched?0.4:1.0)):(1.0-(t.crouchT*0.45)-(t.crawlT*0.6||0)), p=t.isPlayer?playerRoot.position.clone():t.mesh.position.clone(); p.y+=pO; bR.closestPointToPoint(p,cP); if(eS.distanceTo(cP)<hD+1.0){ const dSq=cP.distanceToSquared(p); if(!t.isPlayer){if(dSq<16.0)t.alert(this);}else{if(dSq<2.0)playNearMissSound();} } } });
            }
        }

        const allies=[], enemies=[];
        function spawnSoldiers(count) { allies.forEach(a=>scene.remove(a.mesh)); enemies.forEach(e=>scene.remove(e.mesh)); allies.length=0; enemies.length=0; for(let i=0;i<count;i++){ allies.push(new AI(false)); enemies.push(new AI(true)); } }
        spawnSoldiers(25);

        let lastTime=performance.now(), bobTime=0, breathTime=0, currentScreenShake=0;
        function animate() {
            requestAnimationFrame(animate); const now=performance.now(); let dt=(now-lastTime)/1000; lastTime=now; if(dt>0.1)dt=0.1; breathTime+=dt*1.5;
            if(!playerAI.dead&&document.pointerLockElement){
                if(gameMode==='elimination'){ const aE=enemies.filter(e=>!e.dead).length; document.getElementById('reserves-indicator').innerText=`Enemies Remaining: ${enemyReserves+aE}`; if(aE===0&&enemyReserves<=0){document.exitPointerLock(); document.getElementById('victory-screen').style.display='flex'; playerAI.dead=true; return;} }
                if(mgHeat>0){ mgHeat-=(mgOverheated?20:35)*dt; if(mgHeat<=0){mgHeat=0;mgOverheated=false;} }
                const hC=document.getElementById('heatbar-container'); if(currentWeaponIndex===1&&!mountedTurret){hC.style.display='block'; document.getElementById('heatbar').style.width=mgHeat+'%'; document.getElementById('heatbar').style.background=mgOverheated?'#ff0000':'#ff8800';} else hC.style.display='none';
                const wep=weaponsData[currentWeaponIndex]; if(keys.lmb){ if(mountedTurret)shootTurret(mountedTurret,playerAI); else if(wep.type==='auto'||lmbJustPressed)shootPlayer(); } lmbJustPressed=false;
                let iR=false, iAB=false, bP=0; if(currentWeaponIndex===2&&sniperNeedsRechamber&&!mountedTurret){ iR=true; const tS=now-sniperRechamberStartTime; if(tS>=wep.fireRate){sniperNeedsRechamber=false; iR=false;} else if(tS>=250){iAB=true; bP=(tS-250)/(wep.fireRate-250);} }
                const isAiming=(keys.rmb||keys.space)&&!iAB; let tFov=75; document.getElementById('scope-overlay').style.display=(isAiming&&currentWeaponIndex===2&&!mountedTurret)?'flex':'none'; document.getElementById('crosshair').style.display=(mountedTurret?isAiming:(isAiming||currentWeaponIndex===2))?'none':'block';
                const pEl=document.getElementById('action-prompt'); let cM=false; if(!mountedTurret)turrets.forEach(t=>{ if((!t.user||(t.user&&!t.user.isEnemy&&t.user!==playerAI))&&playerRoot.position.distanceTo(t.mesh.position)<3.0)cM=true; }); if(mountedTurret){pEl.style.display='block';pEl.innerText="Press T to leave turret";}else if(cM){pEl.style.display='block';pEl.innerText="Press T to use turret";}else{pEl.style.display='none';}
                
                let bOX=0, bOY=0, tWY=0, tWZ=0, tWX=0, tBRZ=0, tBPZ=-0.05, isM=(keys.w||keys.s||keys.a||keys.d)&&!mountedTurret;
                if(slideTimer>0&&!isAiming){ tWX-=0.15; tWZ+=0.15; bOX=Math.cos(bobTime)*0.01; bOY=Math.sin(bobTime)*0.01; }
                else if(isM){ let mM=isProne?1.2:(isCrouched?(keys.shift&&!isAiming?1.5:0.5):(keys.shift&&!isAiming?2.5:1.0)); if(isAiming)mM*=0.35; bOX=Math.cos(bobTime*0.5)*0.015*mM; bOY=Math.sin(bobTime)*0.015*mM; tWZ+=Math.cos(bobTime*0.5)*-0.05*mM; tWX+=Math.sin(bobTime)*0.02*mM; tWY+=Math.cos(bobTime*0.5)*0.04*mM; }
                else if(!mountedTurret){ let bM=isAiming?0.35:1.0; bOY=Math.sin(breathTime)*0.004*bM; bOX=Math.cos(breathTime*0.5)*0.002*bM; tWX+=Math.sin(breathTime)*0.005*bM; }

                if(isAiming&&!mountedTurret){ if(currentWeaponIndex===2){tFov=75/sniperZoomLevel; modelSniper.visible=false;}else{tFov=40; weaponContainer.position.lerp(new THREE.Vector3(bOX*0.8,wep.alignY+bOY*0.8,-0.25),15*dt);} }
                else if(!mountedTurret){ if(currentWeaponIndex===2)modelSniper.visible=true; weaponContainer.position.lerp(new THREE.Vector3(0.2+bOX,-0.2+bOY,-0.4),15*dt); } else if(mountedTurret)tFov=isAiming?40:75;

                let cSX=0, cSY=0; if(isAiming&&!mountedTurret){ let sI=currentWeaponIndex===2?sniperZoomLevel*0.8:1.5; cSX=bOY*sI; cSY=bOX*sI; }
                camera.rotation.x+=(cSX-(camera.rotation.x||0))*15*dt; camera.rotation.y+=(cSY-(camera.rotation.y||0))*15*dt;

                if(iAB&&!mountedTurret){ tWZ+=Math.sin(bP*Math.PI)*0.25; tWX+=Math.sin(bP*Math.PI)*-0.05; if(bP<0.15)tBRZ=(bP/0.15)*(-Math.PI/3); else if(bP<0.4){tBRZ=-Math.PI/3;tBPZ=-0.05+((bP-0.15)/0.25)*0.15;} else if(bP<0.65){tBRZ=-Math.PI/3;tBPZ=0.10-((bP-0.4)/0.25)*0.15;} else if(bP<0.8)tBRZ=-Math.PI/3+((bP-0.65)/0.15)*(Math.PI/3); }
                weaponContainer.rotation.z+=(tWZ-weaponContainer.rotation.z)*10*dt; weaponContainer.rotation.x+=(tWX-weaponContainer.rotation.x)*10*dt; weaponContainer.rotation.y+=(tWY-(weaponContainer.rotation.y||0))*10*dt;
                snBoltGroup.rotation.z+=(tBRZ-snBoltGroup.rotation.z)*25*dt; snBoltGroup.position.z+=(tBPZ-snBoltGroup.position.z)*25*dt; camera.fov+=(tFov-camera.fov)*15*dt; camera.updateProjectionMatrix(); weaponContainer.position.z+=(-0.4-weaponContainer.position.z)*10*dt;

                const iLL=(keys.q||qToggled)&&!mountedTurret&&!isProne, iLR=(keys.e||eToggled)&&!mountedTurret&&!iLL&&!isProne;
                if(rollCooldown>0)rollCooldown-=dt; if(isProne&&!mountedTurret){if(activeRollDir===0&&rollCooldown<=0){if(keys.q)activeRollDir=1;else if(keys.e)activeRollDir=-1;}}else{activeRollDir=0;}
                const iRL=activeRollDir===1, iRR=activeRollDir===-1;
                if(!isProne){ leanObject.rotation.z+=(iLL?0.25:(iLR?-0.25:0)-leanObject.rotation.z)*10*dt; if(typeof leanObject.userData.baseLocalX==='undefined')leanObject.userData.baseLocalX=0; leanObject.userData.baseLocalX+=(iLL?-0.5:(iLR?0.5:0)-leanObject.userData.baseLocalX)*10*dt; rollAngle=leanObject.rotation.z; }
                else{ if(iRL){rollAngle+=Math.PI*3*dt; if(rollAngle>=Math.PI*2){rollAngle=0;activeRollDir=0;rollCooldown=0.4;}} else if(iRR){rollAngle-=Math.PI*3*dt; if(rollAngle<=-Math.PI*2){rollAngle=0;activeRollDir=0;rollCooldown=0.4;}} else{rollAngle=rollAngle%(Math.PI*2); if(rollAngle>Math.PI)rollAngle-=Math.PI*2; if(rollAngle<-Math.PI)rollAngle+=Math.PI*2; rollAngle+=(0-rollAngle)*12*dt;} leanObject.rotation.z=rollAngle; if(typeof leanObject.userData.baseLocalX==='undefined')leanObject.userData.baseLocalX=0; leanObject.userData.baseLocalX+=(0-leanObject.userData.baseLocalX)*10*dt; }

                if(!mountedTurret){
                    let lLV=new THREE.Vector3(leanObject.userData.baseLocalX,0,0); lLV.applyAxisAngle(new THREE.Vector3(0,1,0),yaw); let lP2={x:playerRoot.position.x+lLV.x,z:playerRoot.position.z+lLV.z}; resolveObstacles(lP2,0.3);
                    let rLV=new THREE.Vector3(lP2.x-playerRoot.position.x,0,lP2.z-playerRoot.position.z); rLV.applyAxisAngle(new THREE.Vector3(0,1,0),-yaw); leanObject.position.x=rLV.x; leanObject.position.z=rLV.z;
                    const eP=isProne||slideTimer>0; let tEY=eP?0.3:(isCrouched?0.8:1.5); if(isProne&&(iRL||iRR))tEY=0.2; leanObject.position.y+=(tEY-leanObject.position.y)*10*dt; pitchObject.position.z+=(0-pitchObject.position.z)*15*dt;
                    playerAI.mesh.scale.y=eP?0.2:(isCrouched?0.5:1.0); playerAI.mesh.position.y=eP?0.18:(isCrouched?0.45:0.9); playerAI.mesh.position.x=leanObject.position.x; playerAI.mesh.position.z=leanObject.position.z;
                    const mDir=new THREE.Vector3(); if(iRL)mDir.x-=1; else if(iRR)mDir.x+=1; else{if(keys.w)mDir.z-=1;if(keys.s)mDir.z+=1;if(keys.a)mDir.x-=1;if(keys.d)mDir.x+=1;} if(mDir.lengthSq()>0)mDir.normalize(); mDir.applyAxisAngle(new THREE.Vector3(0,1,0),yaw);
                    let sp=5, bS=8, bA=0.05, sV=new THREE.Vector3(0,0,0);
                    if(slideTimer>0){slideTimer-=dt; slideSpeed=Math.max(0,slideSpeed-20*dt); sV.copy(slideDir).multiplyScalar(slideSpeed*dt); sp=1.5; bS=0; bA=0;}
                    else if(isProne){if(iRL||iRR){sp=4.0;bS=0;bA=0;}else if(keys.shift&&!isAiming){sp=3.0;bS=6;bA=0.05;}else{sp=1.125;bS=4;bA=0.03;}}
                    else if(isCrouched){if(keys.shift&&!isAiming){sp=6.5;bS=10;bA=0.035;}else{sp=3;bS=6;bA=0.02;}}
                    else{if(keys.shift&&!isAiming){sp=8;bS=12;bA=0.05;}else{sp=5;bS=8;bA=0.05;}}
                    const vel=mDir.multiplyScalar(sp*dt).add(sV);
                    if(mDir.lengthSq()>0){bobTime+=dt*bS; pitchObject.position.y=Math.sin(bobTime)*bA;} else{pitchObject.position.y+=(Math.sin(breathTime)*0.015-pitchObject.position.y)*5*dt;}
                    let nP=playerRoot.position.clone().add(vel); const pr=0.4; if(nP.z<-98+pr)nP.z=-98+pr; if(nP.z>98-pr)nP.z=98-pr; if(nP.x<-95+pr)nP.x=-95+pr; if(nP.x>95-pr)nP.x=95-pr;
                    let p2={x:nP.x,z:nP.z}; resolveObstacles(p2,pr); nP.x=p2.x; nP.z=p2.z;
                    [...allies,...enemies].filter(a=>!a.dead).forEach(ai=>{ let dx=nP.x-ai.mesh.position.x, dz=nP.z-ai.mesh.position.z, dSq=dx*dx+dz*dz; if(dSq<0.64&&dSq>0.0001){let d=Math.sqrt(dSq), o=0.8-d; nP.x+=(dx/d)*o; nP.z+=(dz/d)*o;} });
                    playerRoot.position.copy(nP); playerRoot.position.y=getTerrainHeight(playerRoot.position.x,playerRoot.position.z);
                } else {
                    leanObject.position.x+=(0-leanObject.position.x)*15*dt; leanObject.position.z+=(0-leanObject.position.z)*15*dt; leanObject.position.y+=(0.1-leanObject.position.y)*15*dt;
                    pitchObject.position.z+=(0-pitchObject.position.z)*15*dt; pitchObject.position.y+=(0-pitchObject.position.y)*15*dt;
                    camera.position.y+=(isAiming?0.14:0.35-camera.position.y)*15*dt; camera.position.z+=(isAiming?0.25:0.8-camera.position.z)*15*dt;
                    playerRoot.position.copy(mountedTurret.mesh.position); mountedTurret.swivel.rotation.y=yaw; mountedTurret.pitchGroup.rotation.x=pitch;
                }
                
                const wI=document.getElementById('weapon-indicator');
                if(mountedTurret){ wI.innerText=mountedTurret.isReloading?`Turret [RELOADING...] (${mountedTurret.ammo}/${mountedTurret.maxAmmo})`:`Turret (${mountedTurret.ammo}/${mountedTurret.maxAmmo})`; wI.style.color=mountedTurret.isReloading?'#ffffaa':(mountedTurret.ammo===0?'#ff5555':'white'); }
                else{ wI.innerText=weaponsData[currentWeaponIndex].name; wI.style.color='white'; }

                turrets.forEach(t=>{
                    t.pitchGroup.position.z+=(0-t.pitchGroup.position.z)*10*dt;
                    if(t.isReloading){ if(t.user){ t.reloadTimer-=dt; t.dummyShell.visible=true; let lP=1.0-(t.reloadTimer/0.6); if(lP>1)lP=1; if(lP<0)lP=0; t.dummyShell.position.set(0,0.4-(lP*0.3),0.1); if(t.reloadTimer<=0){t.ammo++; playSoundFile('gunshot',3.0,0.05); t.pitchGroup.rotation.z=(Math.random()-0.5)*0.15; if(t.ammo>=t.maxAmmo){t.isReloading=false; t.dummyShell.visible=false;}else{t.reloadTimer=0.6;} } }else{t.dummyShell.visible=false;} t.pitchGroup.rotation.z+=(0-t.pitchGroup.rotation.z)*10*dt; }
                    else{ t.dummyShell.visible=false; t.pitchGroup.rotation.z+=(0-t.pitchGroup.rotation.z)*10*dt; if(t.ammo<=0&&t.user){t.isReloading=true; t.reloadTimer=0.6;} }
                });
            }

            const hEl=document.getElementById('hurt-overlay'); if(!playerAI.dead&&parseFloat(hEl.style.opacity)>0)hEl.style.opacity=Math.max(0,parseFloat(hEl.style.opacity)-dt);
            if(fpFlashMaterial.opacity>0){fpFlashMaterial.opacity=Math.max(0,fpFlashMaterial.opacity-dt*20); fpFlashLight.intensity=Math.max(0,fpFlashLight.intensity-dt*40);}
            explosions.forEach(exp=>{ if(exp.life>0){ exp.life-=dt; let t=Math.min(1,1.0-(exp.life/exp.maxLife)); const s=0.5+(Math.pow(t,0.4)*9.0); exp.mesh.scale.set(s,s,s); exp.mesh.material.color.setHex(t<0.15?0xffffff:(t<0.4?0xff8800:0x330800)); exp.mesh.material.opacity=(1.0-t)*0.9; exp.light.intensity=Math.max(0,20.0*(1.0-(t*1.5))); if(exp.life<=0){exp.mesh.visible=false; exp.light.intensity=0;} } });
            impacts.forEach(imp=>{ if(imp.life>0){imp.life-=dt; imp.mesh.scale.addScalar(dt*10); imp.mesh.material.opacity=imp.life/0.2; if(imp.life<=0)imp.mesh.visible=false;} });
            allies.forEach(a=>a.update(dt)); enemies.forEach(e=>e.update(dt));
            flashes.forEach(f=>{ if(f.life>0){f.life-=dt; if(f.life<=0)f.mesh.material.opacity=0;} });
            tracers.forEach(t=>{ if(t.life>0){t.life-=dt; const mD=150*dt; t.traveled+=mD; if(t.traveled>=t.maxDist){t.life=0; t.mesh.visible=false;} else t.mesh.position.add(t.dir.clone().multiplyScalar(mD));} });
            const pA=ashParticles.geometry.attributes.position.array; for(let i=0;i<ashCount*3;i+=3){ pA[i]-=dt*1.5; pA[i+1]-=dt*0.8; if(pA[i]<-100)pA[i]=100; if(pA[i+1]<-2)pA[i+1]=10+Math.random()*5; } ashParticles.geometry.attributes.position.needsUpdate=true;
            while(deathHotspots.length>0&&now-deathHotspots[0].time>30000)deathHotspots.shift();
            horizonLights.forEach(hl=>{ if(hl.timer>0){hl.timer-=dt; if(hl.timer<=0)hl.light.intensity=0;}else hl.light.intensity=Math.max(0,hl.light.intensity-dt*20); });
            if(audioCtx&&masterFilter){ if(shellShockTimer>0){shellShockTimer-=dt; masterFilter.frequency.setTargetAtTime(300,audioCtx.currentTime,0.1); masterGain.gain.setTargetAtTime(0.4,audioCtx.currentTime,0.1);} else {masterFilter.frequency.setTargetAtTime(22000,audioCtx.currentTime,2.0); masterGain.gain.setTargetAtTime(1.0,audioCtx.currentTime,2.0);} }
            let sx=0, sy=0, sz=0; if(currentScreenShake>0){ currentScreenShake-=dt; sx=(Math.random()-0.5)*currentScreenShake; sy=(Math.random()-0.5)*currentScreenShake; sz=(Math.random()-0.5)*currentScreenShake; camera.position.x+=sx; camera.position.y+=sy; camera.position.z+=sz; }
            renderer.render(scene, camera);
            if(sx!==0||sy!==0||sz!==0){camera.position.x-=sx; camera.position.y-=sy; camera.position.z-=sz;}
        }

        window.addEventListener('resize', ()=>{camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight);});
        animate();
    </script>
</body>
</html>
