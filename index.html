<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Trench Warfare FPS</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: sans-serif;
            user-select: none;
        }
        #game-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 24px;
            font-weight: bold;
        }
        #healthbar-container {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 300px;
            height: 25px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #333;
        }
        #healthbar {
            width: 100%;
            height: 100%;
            background: #00aa00;
            transition: width 0.2s;
        }
        #heatbar-container {
            position: absolute;
            bottom: 60px;
            left: 30px;
            width: 300px;
            height: 10px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #333;
            display: none;
        }
        #heatbar {
            width: 0%;
            height: 100%;
            background: #ff8800;
            transition: width 0.1s;
        }
        #weapon-indicator {
            position: absolute;
            bottom: 30px;
            right: 30px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border: 2px solid #333;
        }
        #kill-count-indicator {
            position: absolute;
            bottom: 90px;
            right: 30px;
            color: white;
            font-size: 20px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 16px;
            border: 2px solid #333;
        }
        #reserves-indicator {
            position: absolute;
            top: 30px;
            right: 30px;
            color: white;
            font-size: 20px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 16px;
            border: 2px solid #333;
            display: none;
        }
        #scope-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(circle, transparent 35%, rgba(0,0,0,0.9) 55%, black 100%);
            align-items: center;
            justify-content: center;
        }
        .scope-line-h { width: 100%; height: 2px; background: rgba(0,0,0,0.8); position: absolute; }
        .scope-line-v { width: 2px; height: 100%; background: rgba(0,0,0,0.8); position: absolute; }
        .scope-dot { width: 4px; height: 4px; background: red; border-radius: 50%; position: absolute; }
        #instructions {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 10;
        }
        .menu-btn {
            background: #333; color: #fff; border: 2px solid #555;
            padding: 12px 24px; font-size: 18px; font-weight: bold;
            cursor: pointer; transition: 0.2s; border-radius: 4px;
            font-family: sans-serif;
        }
        .menu-btn:hover { background: #555; border-color: #888; }
        
        #victory-screen {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 50, 0, 0.85); color: white; z-index: 20;
            flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto;
        }
        .inst-text {
            max-width: 600px;
            text-align: center;
            line-height: 1.6;
            font-size: 18px;
        }
        #hurt-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: red;
            opacity: 0;
            transition: opacity 0.1s;
        }
        #hit-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border-top: 2px solid white;
            border-right: 2px solid white;
            opacity: 0;
            transform-origin: center;
            transform: translate(-50%, -50%) rotate(45deg);
            transition: opacity 0.1s;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="ui">
        <div id="hurt-overlay"></div>
        <div id="scope-overlay">
            <div class="scope-line-h"></div>
            <div class="scope-line-v"></div>
            <div class="scope-dot"></div>
        </div>
        <div id="crosshair">+</div>
        <div id="hit-marker"></div>
        <div id="healthbar-container">
            <div id="healthbar"></div>
        </div>
        <div id="heatbar-container">
            <div id="heatbar"></div>
        </div>
        <div id="reserves-indicator">Enemies Remaining: 0</div>
        <div id="kill-count-indicator">Kills: 0</div>
        <div id="weapon-indicator">1: Rifle</div>
        <div id="instructions">
            <div class="inst-text">
                <h2>TRENCH WARFARE</h2>
                <p>Select a mode to deploy and lock pointer.</p>
                <p>
                    <b>WASD</b>: Move &nbsp;|&nbsp; <b>Shift</b>: Sprint &nbsp;|&nbsp; <b>Z</b>: Toggle Crouch<br>
                    <b>Q / E</b>: Lean Left / Right<br>
                    <b>RMB / Space</b>: Aim Down Sights &nbsp;|&nbsp; <b>LMB</b>: Fire<br>
                    <b>1, 2, 3</b>: Switch Weapons &nbsp;|&nbsp; <b>+ / -</b>: Sniper Zoom
                </p>
                <p style="color:#aaa; font-size:14px;">Survive an endless onslaught or eliminate the enemy reinforcements.</p>
            </div>
            
            <div style="margin: 20px 0; display: flex; flex-direction: column; align-items: center; background: rgba(0,0,0,0.5); padding: 15px; border-radius: 8px; border: 1px solid #444; width: 340px;">
                <label for="soldier-count" style="font-size: 16px; font-weight: bold; margin-bottom: 5px;">
                    Total Forces (Elimination): <span id="soldier-count-display">100</span>
                </label>
                <input type="range" id="soldier-count" min="10" max="1000" value="100" style="width: 250px; cursor: pointer; margin-bottom: 15px;">

                <label for="active-count" style="font-size: 16px; font-weight: bold; margin-bottom: 5px;">
                    Max Active on Field: <span id="active-count-display">45</span>
                </label>
                <input type="range" id="active-count" min="10" max="100" value="45" style="width: 250px; cursor: pointer;">
            </div>

            <div style="display: flex; gap: 20px;">
                <button id="btn-endless" class="menu-btn">Play Endless Mode</button>
                <button id="btn-elimination" class="menu-btn">Play Elimination Mode</button>
            </div>
        </div>
        
        <div id="victory-screen">
            <h1 style="font-size: 72px; margin-bottom: 10px; text-shadow: 0 0 10px #0f0;">VICTORY</h1>
            <p style="font-size: 24px; margin-bottom: 30px;">The enemy line has been broken.</p>
            <button id="btn-victory-menu" class="menu-btn">Return to Menu</button>
        </div>
    </div>

    <script>
        // --- GLOBALS & SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x555555, 0.015);
        scene.background = new THREE.Color(0x555555);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- AUDIO SYSTEM ---
        let audioCtx;
        const audioBuffers = {};

        function createRealisticGunshot(ctx) {
            const buffer = ctx.createBuffer(1, ctx.sampleRate * 1.0, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            let lastOut = 0;
            for (let i = 0; i < data.length; i++) {
                const t = i / ctx.sampleRate;
                const crack = (Math.random() * 2 - 1) * Math.exp(-t * 50) * 1.5;
                const boomFreq = 40 + 140 * Math.exp(-t * 35);
                const boom = Math.sin(2 * Math.PI * boomFreq * t) * Math.exp(-t * 12) * 4.0;
                const sub = Math.sin(2 * Math.PI * 35 * t) * Math.exp(-t * 6) * 1.5;
                const noise = (Math.random() * 2 - 1) * Math.exp(-t * 18) * 0.8;
                let sample = crack + boom + sub + noise;
                lastOut = lastOut + 0.45 * (sample - lastOut);
                let saturated = Math.tanh(lastOut * 1.3);
                const tail = (Math.random() * 2 - 1) * Math.exp(-t * 2.5) * 0.12;
                data[i] = saturated + tail;
            }
            return buffer;
        }

        function createRealisticExplosion(ctx) {
            const buffer = ctx.createBuffer(1, ctx.sampleRate * 2.5, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            let lastOut = 0;
            for (let i = 0; i < data.length; i++) {
                const t = i / ctx.sampleRate;
                const noise = Math.random() * 2 - 1;
                const attack = Math.min(1.0, t * 20);
                const decay = Math.exp(-t * 1.5);
                const rumble = Math.sin(2 * Math.PI * (20 + 30 * Math.random()) * t);
                let sample = (noise * 0.6 + rumble * 0.4) * attack * decay;
                lastOut = lastOut + 0.05 * (sample - lastOut); 
                data[i] = lastOut * 3.0;
            }
            return buffer;
        }

        function createBulletWhiz(ctx) {
            const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.3, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            let lastOut = 0;
            for (let i = 0; i < data.length; i++) {
                const t = i / ctx.sampleRate;
                const freq = 1200 - 800 * (t / 0.3); 
                const tone = Math.sin(2 * Math.PI * freq * t);
                const noise = Math.random() * 2 - 1;
                const env = t < 0.1 ? (t / 0.1) : 1.0 - ((t - 0.1) / 0.2);
                let sample = (tone * 0.6 + noise * 0.4) * env;
                lastOut = lastOut + 0.4 * (sample - lastOut);
                data[i] = lastOut * 0.8;
            }
            return buffer;
        }

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                audioBuffers['gunshot'] = createRealisticGunshot(audioCtx);
                audioBuffers['artillery'] = createRealisticExplosion(audioCtx);
                audioBuffers['whiz'] = createBulletWhiz(audioCtx);
            }
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function playSoundFile(name, pitchShift = 1.0, volume = 1.0, isDistant = false) {
            if (!audioCtx || !audioBuffers[name]) return; 
            const source = audioCtx.createBufferSource();
            source.buffer = audioBuffers[name];
            source.playbackRate.value = pitchShift * (0.95 + Math.random() * 0.1);
            const gain = audioCtx.createGain();
            gain.gain.value = volume;
            if (isDistant) {
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 300 + Math.random() * 500;
                source.connect(filter);
                filter.connect(gain);
            } else {
                source.connect(gain);
            }
            gain.connect(audioCtx.destination);
            source.start(0);
        }

        function playPositionalSound(pos, type) {
            if (!audioCtx) return;
            const dist = camera.position.distanceTo(pos);
            if (dist > 100) return;
            let vol = 1.0 / (1 + dist * 0.05);
            playSoundFile('gunshot', 0.9 + Math.random() * 0.2, vol * 0.6);
        }

        let lastNearMissTime = 0;
        function playNearMissSound() {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;
            if (now - lastNearMissTime < 0.2) return; 
            lastNearMissTime = now;
            playSoundFile('whiz', 0.9 + Math.random() * 0.2, 1.5);
        }

        function startAmbientBattle() {
            setInterval(() => {
                if (Math.random() > 0.5) playSoundFile('artillery', 0.6 + Math.random() * 0.4, 0.7, true);
            }, 2500);
            setInterval(() => {
                if (Math.random() > 0.3) playSoundFile('gunshot', 0.5 + Math.random() * 0.8, 0.1, true);
            }, 150);
        }

        // --- WORLD GEOMETRY & TERRAIN ---
        const worldMeshes = [];
        const collisionObstacles = [];
        
        function getTerrainHeight(x, z) {
            const absZ = Math.abs(z);
            if (absZ < 22.0) return -1.2; 
            if (absZ >= 22.0 && absZ < 26.0) {
                const inGap = (Math.abs(x + 60) < 4.2) || (Math.abs(x + 20) < 4.2) || 
                              (Math.abs(x - 20) < 4.2) || (Math.abs(x - 60) < 4.2);
                if (inGap) {
                    return -1.2 + (2.2 * ((absZ - 22.0) / 4.0)); // Incline/Ramp
                } else {
                    return 1.0; 
                }
            }
            return 1.0; 
        }

        const groundMat = new THREE.MeshLambertMaterial({ color: 0x3a4530 });
        const wallMat = new THREE.MeshLambertMaterial({ color: 0x4a3c2b });
        const woodMat = new THREE.MeshLambertMaterial({ color: 0x3d2817 });

        const baseFloor = new THREE.Mesh(new THREE.PlaneGeometry(200, 100), groundMat);
        baseFloor.rotation.x = -Math.PI / 2;
        baseFloor.position.set(0, -1.2, 0);
        scene.add(baseFloor);
        worldMeshes.push(baseFloor);

        const nmlRegions = [
            { x: -71.5, w: 57, z: -9.75, d: 15.5 }, 
            { x: 0, w: 74, z: -9.75, d: 15.5 },     
            { x: 71.5, w: 57, z: -9.75, d: 15.5 },  
            { x: -71.5, w: 57, z: 9.75, d: 15.5 },  
            { x: 0, w: 74, z: 9.75, d: 15.5 },      
            { x: 71.5, w: 57, z: 9.75, d: 15.5 }    
        ];
        nmlRegions.forEach(reg => {
            const b = new THREE.Mesh(new THREE.BoxGeometry(reg.w, 1.2, reg.d), groundMat);
            b.position.set(reg.x, -0.6, reg.z);
            scene.add(b); worldMeshes.push(b);
            collisionObstacles.push({ minX: reg.x - reg.w/2, maxX: reg.x + reg.w/2, minZ: reg.z - reg.d/2, maxZ: reg.z + reg.d/2 });
        });

        const bfA = new THREE.Mesh(new THREE.PlaneGeometry(200, 10.75), wallMat);
        bfA.rotation.x = -Math.PI / 2; bfA.position.set(0, 1.0, -31.375);
        const bfE = new THREE.Mesh(new THREE.PlaneGeometry(200, 10.75), wallMat);
        bfE.rotation.x = -Math.PI / 2; bfE.position.set(0, 1.0, 31.375);
        scene.add(bfA, bfE); worldMeshes.push(bfA, bfE);

        const rampGeo = new THREE.PlaneGeometry(8, 4.565);
        const gapCenters = [-60, -20, 20, 60];
        const blockCenters = [-82, -40, 0, 40, 82];
        const blockWidths = [36, 32, 32, 32, 36];

        for (let i = 0; i < blockCenters.length; i++) {
            let cx = blockCenters[i];
            let w = blockWidths[i];
            
            let bA = new THREE.Mesh(new THREE.BoxGeometry(w, 2.2, 4.0), groundMat);
            bA.position.set(cx, -0.1, -24.0);
            scene.add(bA); worldMeshes.push(bA);
            collisionObstacles.push({ minX: cx - w/2, maxX: cx + w/2, minZ: -26.0, maxZ: -22.0 });
            
            let bE = new THREE.Mesh(new THREE.BoxGeometry(w, 2.2, 4.0), groundMat);
            bE.position.set(cx, -0.1, 24.0);
            scene.add(bE); worldMeshes.push(bE);
            collisionObstacles.push({ minX: cx - w/2, maxX: cx + w/2, minZ: 22.0, maxZ: 26.0 });
        }

        for (let i = 0; i < gapCenters.length; i++) {
            let rA = new THREE.Mesh(rampGeo, groundMat);
            rA.rotation.x = -Math.PI / 2 + 0.5028; 
            rA.position.set(gapCenters[i], -0.1, -24.0);
            scene.add(rA); worldMeshes.push(rA);

            let rE = new THREE.Mesh(rampGeo, groundMat);
            rE.rotation.x = -Math.PI / 2 - 0.5028; 
            rE.position.set(gapCenters[i], -0.1, 24.0);
            scene.add(rE); worldMeshes.push(rE);
        }

        function createWall(x, z, w, h, yCenter) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, 0.5), wallMat);
            mesh.position.set(x, yCenter, z);
            scene.add(mesh);
            worldMeshes.push(mesh);
            collisionObstacles.push({ minX: x - w/2, maxX: x + w/2, minZ: z - 0.25, maxZ: z + 0.25 });
        }

        createWall(-71.5, -17.75, 57, 1.4, -0.5);
        createWall(0, -17.75, 74, 1.4, -0.5);
        createWall(71.5, -17.75, 57, 1.4, -0.5);

        createWall(-71.5, 17.75, 57, 1.4, -0.5);
        createWall(0, 17.75, 74, 1.4, -0.5);
        createWall(71.5, 17.75, 57, 1.4, -0.5);

        createWall(0, -36.75, 200, 2.0, 2.0);  
        createWall(0, 36.75, 200, 2.0, 2.0);   

        const sideWallGeo = new THREE.BoxGeometry(2, 10, 80);
        const sw1 = new THREE.Mesh(sideWallGeo, wallMat); sw1.position.set(-100, 0, 0);
        const sw2 = new THREE.Mesh(sideWallGeo, wallMat); sw2.position.set(100, 0, 0);
        scene.add(sw1, sw2); worldMeshes.push(sw1, sw2);
        collisionObstacles.push({ minX: -101, maxX: -99, minZ: -40, maxZ: 40 });
        collisionObstacles.push({ minX: 99, maxX: 101, minZ: -40, maxZ: 40 });

        const allyCoversFront = [], allyCoversBack = [];
        const enemyCoversFront = [], enemyCoversBack = [];
        
        const allyPathCovers = [];
        const enemyPathCovers = [];
        const midCoversAlly = [];
        const midCoversEnemy = [];

        function addCover(x, z, arr, dirZ) {
            let mesh = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.4, 1), woodMat);
            mesh.position.set(x, -0.5, z);
            scene.add(mesh); worldMeshes.push(mesh);
            collisionObstacles.push({ minX: x - 0.75, maxX: x + 0.75, minZ: z - 0.5, maxZ: z + 0.5 });
            arr.push({ x: x, z: z + dirZ, y: -1.2 });
        }

        addCover(-41.5, -12, allyPathCovers, -1.2);
        addCover(-38.5, -6, allyPathCovers, -1.2);
        addCover(41.5, -12, allyPathCovers, -1.2);
        addCover(38.5, -6, allyPathCovers, -1.2);
        
        addCover(-41.5, 12, enemyPathCovers, 1.2);
        addCover(-38.5, 6, enemyPathCovers, 1.2);
        addCover(41.5, 12, enemyPathCovers, 1.2);
        addCover(38.5, 6, enemyPathCovers, 1.2);

        for (let x = -90; x <= 90; x += 6) {
            if (Math.abs(x + 40) < 4 || Math.abs(x - 40) < 4) continue; 
            if (x % 12 === 0) addCover(x, -0.5, midCoversAlly, -1.2);
            else addCover(x, 0.5, midCoversEnemy, 1.2);
        }

        function buildElevatedWallAndCovers(zPos, isEnemy) {
            for (let i = 0; i < blockCenters.length; i++) {
                const cx = blockCenters[i]; const w = blockWidths[i];
                createWall(cx, zPos, w, 0.8, 1.4);
                let startX = cx - w/2 + 2; let endX = cx + w/2 - 2; let count = 0;
                for (let x = startX; x <= endX; x += 4) {
                    if (count % 2 === 0) createWall(x, zPos, 3.5, 1.8, 1.9);
                    else {
                        const targetZ = isEnemy ? zPos + 1.2 : zPos - 1.2;
                        if (isEnemy) enemyCoversBack.push({ x: x, z: targetZ, y: 1.0 });
                        else allyCoversBack.push({ x: x, z: targetZ, y: 1.0 });
                    }
                    count++;
                }
            }
        }
        buildElevatedWallAndCovers(-26.25, false);
        buildElevatedWallAndCovers(26.25, true);

        for (let x = -96; x <= 96; x += 4) {
            if (Math.abs(x + 60) < 5 || Math.abs(x + 20) < 5 || Math.abs(x - 20) < 5 || Math.abs(x - 60) < 5) continue; 
            if (Math.abs(x + 40) < 4 || Math.abs(x - 40) < 4) continue; 

            let oxA = x + (Math.random() - 0.5);
            addCover(oxA, -18.5, allyCoversFront, -1.2);

            let oxE = x + (Math.random() - 0.5);
            addCover(oxE, 18.5, enemyCoversFront, 1.2);
        }

        for (let i = 0; i < 40; i++) {
            const x = (Math.random() - 0.5) * 160;
            const z = (Math.random() > 0.5 ? 1 : -1) * (2.0 + Math.random() * 15.5); 
            if (Math.abs(x + 40) < 3.5 || Math.abs(x - 40) < 3.5) continue;

            const mesh = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 1.5), woodMat);
            mesh.position.set(x, 0.75, z); 
            mesh.rotation.y = Math.random() * Math.PI;
            mesh.rotation.x = Math.random() * 0.5;
            scene.add(mesh);
            worldMeshes.push(mesh);
        }

        function resolveObstacles(pos, radius) {
            for (let obs of collisionObstacles) {
                let closestX = Math.max(obs.minX, Math.min(pos.x, obs.maxX));
                let closestZ = Math.max(obs.minZ, Math.min(pos.z, obs.maxZ));
                
                if (pos.x >= obs.minX && pos.x <= obs.maxX && pos.z >= obs.minZ && pos.z <= obs.maxZ) {
                    let dLeft = pos.x - obs.minX;
                    let dRight = obs.maxX - pos.x;
                    let dTop = pos.z - obs.minZ;
                    let dBottom = obs.maxZ - pos.z;

                    let minD = Math.min(dLeft, dRight, dTop, dBottom);
                    if (minD === dLeft) pos.x = obs.minX - radius;
                    else if (minD === dRight) pos.x = obs.maxX + radius;
                    else if (minD === dTop) pos.z = obs.minZ - radius;
                    else if (minD === dBottom) pos.z = obs.maxZ + radius;
                } else {
                    let dx = pos.x - closestX;
                    let dz = pos.z - closestZ;
                    let distSq = dx * dx + dz * dz;
                    if (distSq < radius * radius && distSq > 0.0001) {
                        let dist = Math.sqrt(distSq);
                        let overlap = radius - dist;
                        pos.x += (dx / dist) * overlap;
                        pos.z += (dz / dist) * overlap;
                    }
                }
            }
        }

        const ambient = new THREE.AmbientLight(0x404040, 1.5);
        scene.add(ambient);
        const dirLight = new THREE.DirectionalLight(0xffddbb, 0.8);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // --- PLAYER & CAMERA ---
        const playerRoot = new THREE.Group();
        playerRoot.position.set(0, getTerrainHeight(0, -20), -20);
        scene.add(playerRoot);
        const leanObject = new THREE.Group(); leanObject.position.y = 1.5; playerRoot.add(leanObject);
        const pitchObject = new THREE.Group(); leanObject.add(pitchObject); pitchObject.add(camera);

        const playerAI = {
            isPlayer: true, hp: 10, dead: false,
            mesh: new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.8, 0.8), new THREE.MeshBasicMaterial({ visible: false })),
            takeDamage: function(amt, attacker) {
                if (this.dead) return;
                playNearMissSound(); 
                playerHp -= amt;
                document.getElementById('healthbar').style.width = (playerHp * 10) + '%';
                document.getElementById('hurt-overlay').style.opacity = 0.5;
                if (playerHp <= 0) {
                    this.dead = true;
                    document.getElementById('hurt-overlay').style.background = 'black';
                    document.getElementById('hurt-overlay').style.opacity = 1.0;
                    setTimeout(() => {
                        if (document.pointerLockElement) document.exitPointerLock();
                    }, 2000);
                }
            }
        };
        playerAI.mesh.userData.ai = playerAI; playerAI.mesh.position.y = 0.9; playerRoot.add(playerAI.mesh);

        // --- WEAPON SYSTEM ---
        const weaponContainer = new THREE.Group(); camera.add(weaponContainer); weaponContainer.position.set(0.2, -0.2, -0.4);
        const weaponsData = [
            { id: 'rifle', name: '1: Rifle', type: 'semi', fireRate: 250, recoilPitch: 0.0066, recoilZ: 0.033, barrelLen: -0.8, soundPitch: 1.0, alignY: -0.06 },
            { id: 'mg', name: '2: Machine Gun', type: 'auto', fireRate: 100, recoilPitch: 0.0066, recoilZ: 0.033, barrelLen: -0.9, soundPitch: 1.1, alignY: -0.08 },
            { id: 'sniper', name: '3: Sniper Rifle', type: 'semi', fireRate: 800, recoilPitch: 0.0198, recoilZ: 0.1, barrelLen: -1.2, soundPitch: 0.7, alignY: 0 }
        ];
        let currentWeaponIndex = 0; let sniperZoomLevel = 4;

        const modelRifle = new THREE.Group();
        const rBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.015, 0.8, 8), new THREE.MeshLambertMaterial({ color: 0x222222 })); rBarrel.rotation.x = Math.PI / 2; rBarrel.position.set(0, 0, -0.4);
        const rReceiver = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.06, 0.25), new THREE.MeshLambertMaterial({ color: 0x1a1a1a })); rReceiver.position.set(0, 0.01, -0.15);
        const rStock = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.12, 0.4), new THREE.MeshLambertMaterial({ color: 0x4a2e15 })); rStock.position.set(0, -0.03, 0.1);
        const rFSight = new THREE.Mesh(new THREE.BoxGeometry(0.005, 0.04, 0.01), new THREE.MeshLambertMaterial({ color: 0x111111 })); rFSight.position.set(0, 0.04, -0.75); 
        const rRSightBase = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.02, 0.02), new THREE.MeshLambertMaterial({ color: 0x111111 })); rRSightBase.position.set(0, 0.03, -0.2); 
        const rRSightL = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.02, 0.02), new THREE.MeshLambertMaterial({ color: 0x111111 })); rRSightL.position.set(-0.015, 0.05, -0.2); 
        const rRSightR = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.02, 0.02), new THREE.MeshLambertMaterial({ color: 0x111111 })); rRSightR.position.set(0.015, 0.05, -0.2); 
        modelRifle.add(rBarrel, rReceiver, rStock, rFSight, rRSightBase, rRSightL, rRSightR);

        const modelMG = new THREE.Group();
        const mgBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.018, 0.02, 0.9, 8), new THREE.MeshLambertMaterial({ color: 0x1a1a1a })); mgBarrel.rotation.x = Math.PI / 2; mgBarrel.position.set(0, 0, -0.45);
        const mgReceiver = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.08, 0.35), new THREE.MeshLambertMaterial({ color: 0x111111 })); mgReceiver.position.set(0, 0.01, -0.1);
        const mgMag = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.12, 0.1), new THREE.MeshLambertMaterial({ color: 0x2a3a2a })); mgMag.position.set(-0.04, -0.05, -0.1);
        const mgStock = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.1, 0.3), new THREE.MeshLambertMaterial({ color: 0x3a2e15 })); mgStock.position.set(0, -0.02, 0.15);
        const mgBipod = new THREE.Mesh(new THREE.CylinderGeometry(0.005, 0.005, 0.15), new THREE.MeshLambertMaterial({color: 0x111111})); mgBipod.position.set(0, -0.05, -0.8); mgBipod.rotation.x = Math.PI/4;
        const mgFSight = new THREE.Mesh(new THREE.BoxGeometry(0.005, 0.04, 0.01), new THREE.MeshLambertMaterial({ color: 0x111111 })); mgFSight.position.set(0, 0.06, -0.85); 
        modelMG.add(mgBarrel, mgReceiver, mgMag, mgStock, mgBipod, mgFSight);

        const modelSniper = new THREE.Group();
        const snBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.015, 1.2, 8), new THREE.MeshLambertMaterial({ color: 0x222222 })); snBarrel.rotation.x = Math.PI / 2; snBarrel.position.set(0, 0, -0.6);
        const snReceiver = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.05, 0.3), new THREE.MeshLambertMaterial({ color: 0x1a1a1a })); snReceiver.position.set(0, 0, -0.15);
        const snStock = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.1, 0.5), new THREE.MeshLambertMaterial({ color: 0x4a2e15 })); snStock.position.set(0, -0.03, 0.15);
        const snScope = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.3, 12), new THREE.MeshLambertMaterial({ color: 0x111111 })); snScope.rotation.x = Math.PI / 2; snScope.position.set(0, 0.06, -0.15);
        modelSniper.add(snBarrel, snReceiver, snStock, snScope);

        weaponContainer.add(modelRifle, modelMG, modelSniper); modelMG.visible = false; modelSniper.visible = false;

        function switchWeapon(index) {
            currentWeaponIndex = index;
            modelRifle.visible = (index === 0); modelMG.visible = (index === 1); modelSniper.visible = (index === 2);
            document.getElementById('weapon-indicator').innerText = weaponsData[index].name;
            fpFlashGroup.position.z = weaponsData[index].barrelLen - 0.05; fpFlashLight.position.z = weaponsData[index].barrelLen - 0.05;
        }

        const fpFlashMaterial = new THREE.MeshBasicMaterial({ color: 0xffddaa, transparent: true, opacity: 0, depthWrite: false, blending: THREE.AdditiveBlending });
        const fpFlashGroup = new THREE.Group(); fpFlashGroup.add(new THREE.Mesh(new THREE.PlaneGeometry(0.3, 0.3), fpFlashMaterial), new THREE.Mesh(new THREE.PlaneGeometry(0.3, 0.3), fpFlashMaterial));
        fpFlashGroup.children[0].rotation.z = Math.PI / 4; fpFlashGroup.children[1].rotation.z = -Math.PI / 4; fpFlashGroup.position.set(0, 0, -0.85);
        const fpFlashLight = new THREE.PointLight(0xffddaa, 0, 5); fpFlashLight.position.set(0, 0, -0.85);
        weaponContainer.add(fpFlashGroup, fpFlashLight);

        // --- EFFECTS ---
        const flashes = [];
        for (let i = 0; i < 20; i++) {
            const f = new THREE.Mesh(new THREE.PlaneGeometry(0.6, 0.6), new THREE.MeshBasicMaterial({ color: 0xffddaa, transparent: true, opacity: 0, depthWrite: false, blending: THREE.AdditiveBlending }));
            scene.add(f); flashes.push({ mesh: f, life: 0 });
        }
        function showMuzzleFlash(pos, dir) {
            const f = flashes.find(fl => fl.life <= 0);
            if (f) { f.life = 0.05; f.mesh.position.copy(pos).add(dir.clone().multiplyScalar(0.4)); f.mesh.lookAt(camera.position); f.mesh.material.opacity = 1; }
        }

        const impacts = [];
        const impactGeo = new THREE.PlaneGeometry(0.3, 0.3); const impactMat = new THREE.MeshBasicMaterial({ color: 0x887755, transparent: true, opacity: 1, depthWrite: false });
        for (let i = 0; i < 40; i++) { const m = new THREE.Mesh(impactGeo, impactMat.clone()); m.visible = false; scene.add(m); impacts.push({ mesh: m, life: 0 }); }
        function createImpact(pos, normal) {
            const imp = impacts.find(i => i.life <= 0);
            if (imp) { imp.life = 0.2; imp.mesh.position.copy(pos).add(normal.clone().multiplyScalar(0.02)); imp.mesh.lookAt(pos.clone().add(normal)); imp.mesh.scale.set(0.1, 0.1, 0.1); imp.mesh.material.opacity = 1; imp.mesh.visible = true; }
        }

        const tracers = []; const tracerGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -8)]);
        for (let i = 0; i < 100; i++) { const t = new THREE.Line(tracerGeo, new THREE.LineBasicMaterial({ color: 0xffcc88 })); t.visible = false; scene.add(t); tracers.push({ mesh: t, life: 0, dir: new THREE.Vector3(), traveled: 0, maxDist: 200 }); }
        function createTracer(start, dir, maxDist = 200) {
            const t = tracers.find(tr => tr.life <= 0);
            if (t) { t.life = 0.8; t.mesh.position.copy(start); t.dir.copy(dir); t.mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, -1), dir); t.mesh.visible = true; t.traveled = 0; t.maxDist = maxDist; }
        }

        // --- INPUT & CONTROLS ---
        const keys = { w: false, a: false, s: false, d: false, shift: false, z: false, q: false, e: false, space: false, lmb: false };
        let lmbJustPressed = false; let isCrouched = false; let yaw = 0; let pitch = 0; let playerHp = 10; let initialized = false; let mgHeat = 0; let mgOverheated = false; let gameMode = 'endless';
        let playerKills = 0;
        
        let allyReserves = 0;
        let enemyReserves = 0;

        document.getElementById('soldier-count').addEventListener('input', (e) => { document.getElementById('soldier-count-display').innerText = e.target.value; });
        document.getElementById('active-count').addEventListener('input', (e) => { document.getElementById('active-count-display').innerText = e.target.value; });

        function startGame(mode) {
            gameMode = mode;
            if (!initialized) { initAudio(); startAmbientBattle(); initialized = true; }
            playerHp = 10; playerAI.dead = false; document.getElementById('healthbar').style.width = '100%'; document.getElementById('hurt-overlay').style.opacity = 0;
            document.getElementById('hurt-overlay').style.background = 'red'; document.getElementById('victory-screen').style.display = 'none';
            playerRoot.position.set(0, getTerrainHeight(0, -20), -20); yaw = 0; pitch = 0; isCrouched = false; mgHeat = 0; mgOverheated = false;
            
            playerKills = 0;
            document.getElementById('kill-count-indicator').innerText = 'Kills: 0';
            
            const totalCount = parseInt(document.getElementById('soldier-count').value, 10) || 100;
            const activeCount = parseInt(document.getElementById('active-count').value, 10) || 45;

            if (mode === 'elimination') {
                const initialSpawn = Math.min(totalCount, activeCount);
                allyReserves = totalCount - initialSpawn;
                enemyReserves = totalCount - initialSpawn;
                spawnSoldiers(initialSpawn);
                document.getElementById('reserves-indicator').style.display = 'block';
            } else {
                spawnSoldiers(activeCount);
                document.getElementById('reserves-indicator').style.display = 'none';
            }

            if (!document.pointerLockElement) document.body.requestPointerLock().catch(err => console.warn(err));
        }

        document.getElementById('btn-endless').addEventListener('click', () => startGame('endless'));
        document.getElementById('btn-elimination').addEventListener('click', () => startGame('elimination'));
        document.getElementById('btn-victory-menu').addEventListener('click', () => { document.getElementById('victory-screen').style.display = 'none'; document.getElementById('instructions').style.display = 'flex'; });
        document.addEventListener('pointerlockchange', () => { if (document.getElementById('victory-screen').style.display === 'flex') return; document.getElementById('instructions').style.display = document.pointerLockElement ? 'none' : 'flex'; });
        document.addEventListener('mousemove', (e) => { if (document.pointerLockElement && !playerAI.dead) { yaw -= e.movementX * 0.002; pitch -= e.movementY * 0.002; pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch)); playerRoot.rotation.y = yaw; pitchObject.rotation.x = pitch; } });

        document.addEventListener('keydown', e => {
            const code = e.code;
            if (code === 'KeyW') keys.w = true; if (code === 'KeyA') keys.a = true; if (code === 'KeyS') keys.s = true; if (code === 'KeyD') keys.d = true;
            if (code === 'ShiftLeft' || code === 'ShiftRight') keys.shift = true; if (code === 'KeyQ') keys.q = true; if (code === 'KeyE') keys.e = true; if (code === 'Space') keys.space = true;
            if (code === 'KeyZ') { if (!keys.z) isCrouched = !isCrouched; keys.z = true; }
            if (code === 'Digit1') switchWeapon(0); if (code === 'Digit2') switchWeapon(1); if (code === 'Digit3') switchWeapon(2);
            if ((code === 'Equal' || code === 'NumpadAdd') && currentWeaponIndex === 2 && (keys.rmb || keys.space)) sniperZoomLevel = Math.min(10, sniperZoomLevel + 1);
            if ((code === 'Minus' || code === 'NumpadSubtract') && currentWeaponIndex === 2 && (keys.rmb || keys.space)) sniperZoomLevel = Math.max(2, sniperZoomLevel - 1);
        });

        document.addEventListener('keyup', e => {
            const code = e.code;
            if (code === 'KeyW') keys.w = false; if (code === 'KeyA') keys.a = false; if (code === 'KeyS') keys.s = false; if (code === 'KeyD') keys.d = false;
            if (code === 'ShiftLeft' || code === 'ShiftRight') keys.shift = false; if (code === 'KeyQ') keys.q = false; if (code === 'KeyE') keys.e = false; if (code === 'Space') keys.space = false;
            if (code === 'KeyZ') keys.z = false;
        });

        document.addEventListener('mousedown', e => { if (!document.pointerLockElement) return; if (e.button === 2) keys.rmb = true; if (e.button === 0) { keys.lmb = true; lmbJustPressed = true; } });
        document.addEventListener('mouseup', e => { if (e.button === 2) keys.rmb = false; if (e.button === 0) keys.lmb = false; });
        document.addEventListener('contextmenu', e => e.preventDefault());

        const raycaster = new THREE.Raycaster(); let lastShotTime = 0;

        function shootPlayer() {
            if (playerAI.dead || (currentWeaponIndex === 1 && mgOverheated)) return;
            const now = performance.now(); const wep = weaponsData[currentWeaponIndex];
            if (now - lastShotTime < wep.fireRate) return;
            lastShotTime = now;
            if (currentWeaponIndex === 1) { mgHeat += 8; if (mgHeat >= 100) { mgHeat = 100; mgOverheated = true; } }

            playSoundFile('gunshot', wep.soundPitch, wep.id === 'sniper' ? 1.5 : 1.0);
            
            const barrelPos = new THREE.Vector3(0, 0, wep.barrelLen).applyMatrix4(weaponContainer.matrixWorld);
            const camDir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
            if (wep.type === 'auto') { camDir.x += (Math.random() - 0.5) * 0.015; camDir.y += (Math.random() - 0.5) * 0.015; camDir.normalize(); }

            fpFlashMaterial.opacity = 1.0; fpFlashLight.intensity = 2.0; fpFlashGroup.rotation.z = Math.random() * Math.PI;

            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            if (wep.type === 'auto') raycaster.set(camera.getWorldPosition(new THREE.Vector3()), camDir);
            
            const intersects = raycaster.intersectObjects([...worldMeshes, ...enemies.map(e => e.mesh)], true);
            let hitDistance = 200;
            if (intersects.length > 0) {
                const hit = intersects[0]; hitDistance = hit.distance; const hitObj = hit.object;
                if (hitObj.userData.ai && hitObj.userData.ai.isEnemy) {
                    const isHead = hitObj.name === "head";
                    hitObj.userData.ai.takeDamage(isHead ? 99 : (1 * (currentWeaponIndex === 2 ? 5 : 1)), playerAI);
                    const marker = document.getElementById('hit-marker'); marker.style.opacity = 1; marker.style.borderColor = isHead ? 'red' : 'white';
                    setTimeout(() => marker.style.opacity = 0, 100);
                } else {
                    let normal = new THREE.Vector3(0, 1, 0);
                    if (hit.face) normal.copy(hit.face.normal).applyMatrix3(new THREE.Matrix3().getNormalMatrix(hitObj.matrixWorld)).normalize();
                    createImpact(hit.point, normal);
                }
            }

            if (Math.random() < 0.25) createTracer(barrelPos, camDir, hitDistance);
            const bulletRay = new THREE.Ray(barrelPos, camDir);
            enemies.forEach(e => { if (!e.dead && bulletRay.distanceSqToPoint(e.mesh.position.clone().add(new THREE.Vector3(0, 1.0, 0))) < 16.0) e.alert(playerAI); });

            pitch += wep.recoilPitch; pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch)); pitchObject.rotation.x = pitch;
            weaponContainer.position.z += wep.recoilZ;
        }

        // Helper function to prevent AI from spawning in the player's field of view
        function isSpotVisibleToPlayer(spot) {
            const camPos = camera.getWorldPosition(new THREE.Vector3());
            const spotPos = new THREE.Vector3(spot.x, spot.y + 1.0, spot.z); // Target chest/head height
            const dir = spotPos.clone().sub(camPos).normalize();
            const dist = camPos.distanceTo(spotPos);

            const camForward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
            if (camForward.dot(dir) < 0.2) return false; // Out of FOV / Behind player

            const tempRaycaster = new THREE.Raycaster(camPos, dir);
            const intersects = tempRaycaster.intersectObjects(worldMeshes, false);
            return !(intersects.length > 0 && intersects[0].distance < dist);
        }

        // --- AI SYSTEM ---
        const allyMat = new THREE.MeshLambertMaterial({ color: 0x3b5030 }); const enemyMat = new THREE.MeshLambertMaterial({ color: 0x5a3030 });
        const skinMat = new THREE.MeshLambertMaterial({ color: 0xdcb897 }); const helmetMatEnemy = new THREE.MeshLambertMaterial({ color: 0x3a2a2a }); const helmetMatAlly = new THREE.MeshLambertMaterial({ color: 0x3a4a30 });

        class AI {
            constructor(isEnemy) {
                this.isEnemy = isEnemy; this.mesh = new THREE.Group(); 
                
                const uniformMat = isEnemy ? enemyMat : allyMat; const helmetMat = isEnemy ? helmetMatEnemy : helmetMatAlly;
                this.bodyRoot = new THREE.Group(); this.mesh.add(this.bodyRoot);
                this.torso = new THREE.Group(); this.torso.position.y = 0.3; this.bodyRoot.add(this.torso);

                const torsoMesh = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.6, 0.25), uniformMat); torsoMesh.userData.ai = this; this.torso.add(torsoMesh);
                const backpack = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.4, 0.15), new THREE.MeshLambertMaterial({ color: 0x4a3a2a })); backpack.position.set(0, 0, 0.2); backpack.userData.ai = this; this.torso.add(backpack);

                this.headGroup = new THREE.Group(); this.headGroup.position.y = 0.35; this.torso.add(this.headGroup);
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.25, 0.2), skinMat); head.position.y = 0.125; head.name = "head"; head.userData.ai = this;
                const helmet = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.15, 0.25), helmetMat); helmet.position.y = 0.3; helmet.name = "head"; helmet.userData.ai = this;
                this.headGroup.add(head, helmet);

                this.leftArm = new THREE.Group(); this.leftArm.position.set(-0.25, 0.2, 0); this.torso.add(this.leftArm);
                const lArmMesh = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.5, 0.12), uniformMat); lArmMesh.position.y = -0.2; lArmMesh.userData.ai = this; this.leftArm.add(lArmMesh);
                this.rightArm = new THREE.Group(); this.rightArm.position.set(0.25, 0.2, 0); this.torso.add(this.rightArm);
                const rArmMesh = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.5, 0.12), uniformMat); rArmMesh.position.y = -0.2; rArmMesh.userData.ai = this; this.rightArm.add(rArmMesh);

                const aiGun = new THREE.Group();
                const gunBody = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.08, 0.6), new THREE.MeshLambertMaterial({color: 0x222222}));
                const gunWood = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.06, 0.4), new THREE.MeshLambertMaterial({color: 0x4a2e15})); gunWood.position.z = 0.1;
                aiGun.add(gunBody, gunWood); aiGun.position.set(-0.05, -0.35, -0.2); this.rightArm.add(aiGun);

                this.leftLeg = new THREE.Group(); this.leftLeg.position.set(-0.12, 0, 0); this.bodyRoot.add(this.leftLeg);
                const lThighMesh = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.4, 0.15), uniformMat); lThighMesh.position.y = -0.2; lThighMesh.userData.ai = this; this.leftLeg.add(lThighMesh);
                this.leftCalf = new THREE.Group(); this.leftCalf.position.set(0, -0.4, 0); this.leftLeg.add(this.leftCalf);
                const lCalfMesh = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.45, 0.13), uniformMat); lCalfMesh.position.y = -0.2; lCalfMesh.userData.ai = this; this.leftCalf.add(lCalfMesh);

                this.rightLeg = new THREE.Group(); this.rightLeg.position.set(0.12, 0, 0); this.bodyRoot.add(this.rightLeg);
                const rThighMesh = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.4, 0.15), uniformMat); rThighMesh.position.y = -0.2; rThighMesh.userData.ai = this; this.rightLeg.add(rThighMesh);
                this.rightCalf = new THREE.Group(); this.rightCalf.position.set(0, -0.4, 0); this.rightLeg.add(this.rightCalf);
                const rCalfMesh = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.45, 0.13), uniformMat); rCalfMesh.position.y = -0.2; rCalfMesh.userData.ai = this; this.rightCalf.add(rCalfMesh);

                scene.add(this.mesh);
                this.dead = true; this.timer = Math.random() * 2; this.crouchT = 1.0; this.aimT = 0.0; this.walkTime = Math.random() * 10;
                
                this.respawn();
            }

            getDesiredCovers() {
                if (this.isEnemy) {
                    if (this.coverTier === 1) return enemyPathCovers;
                    if (this.coverTier === 2) return midCoversEnemy;
                    return this.trenchLevel === 'front' ? enemyCoversFront : enemyCoversBack;
                } else {
                    if (this.coverTier === 1) return allyPathCovers;
                    if (this.coverTier === 2) return midCoversAlly;
                    return this.trenchLevel === 'front' ? allyCoversFront : allyCoversBack;
                }
            }

            pickCover(isSpawning = false) {
                let covers = this.getDesiredCovers();
                const peers = this.isEnemy ? enemies : allies;
                let available = covers.filter(c => !peers.some(p => p !== this && !p.dead && p.targetCover === c));
                
                if (available.length === 0) available = covers; // fallback if crowded
                
                if (isSpawning) {
                    // Filter out spots the player is actively looking at to prevent pop-in ONLY when spawning
                    let safeAvailable = available.filter(c => !isSpotVisibleToPlayer(c));
                    
                    // Only use the safe list if there are actually hidden spots available. 
                    // Otherwise, fallback to exposed spots so they don't break.
                    if (safeAvailable.length > 0) {
                        available = safeAvailable;
                    }
                }
                
                this.targetCover = available[Math.floor(Math.random() * available.length)];
            }

            respawn() {
                this.hp = Math.floor(Math.random() * 2) + 1; 
                this.dead = false; this.mesh.visible = true; this.state = 'hidden';
                this.timer = 0.5 + Math.random(); this.target = null; this.targetCover = null; this.scanBaseYaw = this.isEnemy ? Math.PI : 0;
                this.shootDelay = 0; this.trenchLevel = Math.random() > 0.5 ? 'front' : 'back'; this.crouchT = 1.0; this.aimT = 0.0;
                
                const team = this.isEnemy ? enemies : allies;
                let livingCount = 0;
                let advancers = 0;
                for (let i = 0; i < team.length; i++) {
                    if (!team[i].dead && team[i] !== this) {
                        livingCount++;
                        if (team[i].isAdvancing) advancers++;
                    }
                }
                livingCount++; 
                
                this.isAdvancing = (advancers / livingCount) < 0.25;
                this.coverTier = 0;
                this.interruptedMove = false;

                this.pickCover(true);
                this.mesh.position.set(this.targetCover.x, getTerrainHeight(this.targetCover.x, this.targetCover.z), this.targetCover.z);
            }

            alert(attacker) {
                if (this.dead || !attacker || attacker.dead) return;
                
                if (!this.target || Math.random() < 0.8) {
                    this.target = attacker;
                    let targetPos = attacker.isPlayer ? camera.getWorldPosition(new THREE.Vector3()) : attacker.mesh.position.clone();
                    this.scanBaseYaw = Math.atan2(targetPos.x - this.mesh.position.x, targetPos.z - this.mesh.position.z);
                }
                
                if (this.state === 'moving') {
                    this.state = 'aiming';
                    this.timer = 0.4 + Math.random() * 0.4;
                    this.shootDelay = 0;
                    this.interruptedMove = true; 
                } else if (this.state === 'hidden' && Math.random() < 0.8) {
                    this.state = 'popping';
                    this.timer = 0.2;
                } else if (this.state === 'aiming' || this.state === 'shooting') {
                    this.state = 'aiming';
                    this.timer = 0.5 + Math.random();
                }
            }

            takeDamage(amount, attacker) {
                if (this.dead || this.hp <= 0) return;
                
                this.hp -= amount;
                
                if (this.hp <= 0) {
                    if (attacker === playerAI && this.isEnemy) {
                        playerKills++;
                        document.getElementById('kill-count-indicator').innerText = `Kills: ${playerKills}`;
                    }
                } else if (attacker && !attacker.dead) {
                    this.alert(attacker);
                    if (this.state === 'aiming' || this.state === 'popping') this.timer += 0.2;
                }
            }

            update(dt) {
                if (this.hp <= 0) {
                    if (!this.dead) { 
                        this.dead = true; 
                        this.mesh.visible = false; 
                        this.timer = 3 + Math.random() * 2; 
                    } else {
                        this.timer -= dt;
                        if (this.timer <= 0) {
                            if (gameMode === 'endless') {
                                this.respawn();
                            } else if (gameMode === 'elimination') {
                                if (this.isEnemy && enemyReserves > 0) {
                                    enemyReserves--;
                                    this.respawn();
                                } else if (!this.isEnemy && allyReserves > 0) {
                                    allyReserves--;
                                    this.respawn();
                                }
                            }
                        }
                    }
                    return;
                }

                this.timer -= dt;
                
                let closestThreat = null;
                let closestDistSq = 25; 
                
                const myForward = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), this.mesh.rotation.y);
                const opposingForce = this.isEnemy ? [...allies, playerAI] : enemies;
                
                for (let i = 0; i < opposingForce.length; i++) {
                    const threat = opposingForce[i];
                    if (!threat.dead) {
                        const tPos = threat.isPlayer ? playerRoot.position : threat.mesh.position;
                        let perceivedDistSq = this.mesh.position.distanceToSquared(tPos);
                        
                        const toThreat = tPos.clone().sub(this.mesh.position).normalize();
                        const dot = myForward.dot(toThreat);
                        
                        const isExposed = threat.isPlayer ? !isCrouched : (threat.state === 'moving' || threat.crouchT < 0.5);
                        
                        if (dot > 0.5) perceivedDistSq *= 0.4; 
                        if (isExposed) perceivedDistSq *= 0.4; 
                        
                        if (perceivedDistSq < closestDistSq) {
                            closestDistSq = perceivedDistSq;
                            closestThreat = threat;
                        }
                    }
                }

                if (closestThreat && this.target !== closestThreat) {
                    if (this.calculateExposure(closestThreat) > 0) {
                        this.target = closestThreat;
                        const tPos = closestThreat.isPlayer ? camera.getWorldPosition(new THREE.Vector3()) : closestThreat.mesh.position.clone();
                        this.scanBaseYaw = Math.atan2(tPos.x - this.mesh.position.x, tPos.z - this.mesh.position.z);
                        
                        if (this.state === 'moving') this.interruptedMove = true;
                        
                        this.state = 'aiming';
                        this.shootDelay = 0.2 + Math.random() * 0.2; 
                    }
                }

                let targetCrouch = 0.0; let targetAim = 0.0;

                switch (this.state) {
                    case 'moving':
                        targetCrouch = 0.5; 
                        const moveSpeed = 4.5;
                        
                        let destX = this.targetCover.x;
                        let destZ = this.targetCover.z;
                        let curX = this.mesh.position.x;
                        let curZ = this.mesh.position.z;
                        
                        let tempX = destX;
                        let tempZ = destZ;

                        const isHome = (z) => Math.abs(z) >= 17;
                        const isMid = (z) => Math.abs(z) <= 5;
                        const isPath = (z) => Math.abs(z) > 5 && Math.abs(z) < 17;
                        const getPathX = (x) => (Math.abs(x - (-40)) < Math.abs(x - 40)) ? -40 : 40;
                        
                        if (isHome(curZ) && !isHome(destZ)) {
                            let px = getPathX(curX);
                            if (Math.abs(curX - px) > 1.0) { tempX = px; tempZ = curZ; } 
                            else { tempX = px; tempZ = destZ; }
                        } else if (isMid(curZ) && !isMid(destZ)) {
                            let px = getPathX(curX);
                            if (Math.abs(curX - px) > 1.0) { tempX = px; tempZ = curZ; } 
                            else { tempX = px; tempZ = destZ; }
                        } else if (isPath(curZ)) {
                            if (isHome(destZ)) {
                                let safeZ = destZ > 0 ? 19.5 : -19.5;
                                if (Math.abs(destZ) > 26) safeZ = destZ > 0 ? 28 : -28; 
                                if (Math.abs(curZ - safeZ) > 1.0) { tempX = curX; tempZ = safeZ; } 
                                else { tempX = destX; tempZ = destZ; }
                            } else if (isMid(destZ)) {
                                if (Math.abs(curZ) > 1.0) { tempX = curX; tempZ = 0; } 
                                else { tempX = destX; tempZ = destZ; }
                            }
                        }
                        
                        let dx = tempX - curX;
                        let dz = tempZ - curZ;
                        let dist = Math.sqrt(dx*dx + dz*dz);
                        
                        let finalDx = destX - curX;
                        let finalDz = destZ - curZ;
                        let finalDist = Math.sqrt(finalDx*finalDx + finalDz*finalDz);
                        
                        if (finalDist < 0.2) {
                            this.state = 'hidden';
                            this.timer = 0.2 + Math.random() * 0.3;
                        } else {
                            if (dist < 0.1) { dx = finalDx; dz = finalDz; dist = finalDist; } 
                            this.mesh.position.x += (dx/dist) * moveSpeed * dt;
                            this.mesh.position.z += (dz/dist) * moveSpeed * dt;
                            
                            const targetYaw = Math.atan2(dx, dz);
                            let diff = targetYaw - this.mesh.rotation.y;
                            while (diff < -Math.PI) diff += Math.PI * 2; while (diff > Math.PI) diff -= Math.PI * 2;
                            this.mesh.rotation.y += diff * 10 * dt;
                        }
                        break;
                    case 'hidden':
                        targetCrouch = 1.0; 
                        if (this.timer <= 0) { this.state = 'popping'; this.timer = 0.3; }
                        break;
                    case 'popping':
                        targetCrouch = 0.0; targetAim = 1.0;
                        if (this.target) this.aimAtTarget(dt);
                        if (this.timer <= 0) {
                            this.state = 'aiming'; this.timer = 0.5 + Math.random() * 1.0;
                            if (!this.target || this.target.dead || !this.checkLOS(this.target)) {
                                this.target = this.findTarget();
                            } else { this.shootDelay = 0.1 + Math.random() * 0.2; }
                        }
                        break;
                    case 'aiming':
                        targetCrouch = 0.0; targetAim = 1.0;
                        if (this.target && !this.target.dead && this.checkLOS(this.target)) {
                            this.aimAtTarget(dt);
                            if (this.shootDelay <= 0) {
                                this.state = 'shooting'; this.shotsFired = 0; this.shotsToFire = 3 + Math.floor(Math.random() * 4); this.timer = 0.1;
                            } else this.shootDelay -= dt;
                        } else {
                            this.target = this.findTarget(); this.shootDelay = 0.1 + Math.random() * 0.2;
                            this.mesh.rotation.y = this.scanBaseYaw + Math.sin(performance.now() * 0.002 + this.mesh.id) * 0.5;
                            if (this.timer <= 0) { this.state = 'hidden'; this.timer = 0.5 + Math.random(); }
                        }
                        break;
                    case 'shooting':
                        targetCrouch = 0.0; targetAim = 1.0;
                        if (!this.target || this.target.dead || !this.checkLOS(this.target)) { this.state = 'hidden'; this.timer = 0.5 + Math.random(); break; }
                        this.aimAtTarget(dt);
                        if (this.timer <= 0) {
                            this.shoot();
                            this.shotsFired++;
                            this.timer = 0.15 + Math.random() * 0.15;
                            if (this.shotsFired >= this.shotsToFire) {
                                if (this.interruptedMove) {
                                    this.interruptedMove = false;
                                    this.state = 'moving';
                                } else if (this.isAdvancing && this.coverTier < 2 && Math.random() < 0.8) {
                                    this.coverTier++;
                                    this.pickCover();
                                    this.state = 'moving';
                                } else if (this.isAdvancing && Math.random() < 0.2) {
                                    this.pickCover();
                                    this.state = 'moving';
                                } else {
                                    if (!this.isAdvancing) {
                                        const team = this.isEnemy ? enemies : allies;
                                        let living = 0, adv = 0;
                                        team.forEach(s => { if (!s.dead) { living++; if (s.isAdvancing) adv++; } });
                                        if (adv / living < 0.25) {
                                            this.isAdvancing = true; 
                                        }
                                    }
                                    
                                    this.state = 'hidden'; 
                                    this.timer = 0.5 + Math.random() * 1.0;
                                }
                            }
                        }
                        break;
                }

                this.crouchT += (targetCrouch - this.crouchT) * 10 * dt;
                this.aimT += (targetAim - this.aimT) * 12 * dt;

                this.bodyRoot.position.y = 0.85 - (this.crouchT * 0.45); 
                this.torso.rotation.x = this.crouchT * 0.4; this.headGroup.rotation.x = -this.torso.rotation.x; 

                let legSwing = 0; let armSwing = 0;
                if (this.state === 'moving') { this.walkTime += dt * 10; legSwing = Math.sin(this.walkTime) * 0.6; armSwing = Math.sin(this.walkTime) * 0.3; } else { this.walkTime = 0; }

                const squatThighRot = -1.2 * this.crouchT; const squatCalfRot = 2.0 * this.crouchT;
                this.leftLeg.rotation.z = 0.15 * this.crouchT; this.rightLeg.rotation.z = -0.15 * this.crouchT;
                this.leftLeg.rotation.x = squatThighRot + legSwing; this.leftCalf.rotation.x = squatCalfRot; if (legSwing < 0) this.leftCalf.rotation.x += legSwing * -0.5;
                this.rightLeg.rotation.x = squatThighRot - legSwing; this.rightCalf.rotation.x = squatCalfRot; if (legSwing > 0) this.rightCalf.rotation.x += -legSwing * -0.5;

                const aimRotRightX = -Math.PI / 2 + 0.1; const idleRotRightX = (this.crouchT * -0.2) + armSwing; this.rightArm.rotation.x = idleRotRightX + (aimRotRightX - idleRotRightX) * this.aimT;
                const aimRotLeftX = -Math.PI / 2 + 0.2; const idleRotLeftX = (this.crouchT * -0.2) - armSwing; this.leftArm.rotation.x = idleRotLeftX + (aimRotLeftX - idleRotLeftX) * this.aimT;
                this.rightArm.rotation.z = 0.15 * this.aimT; this.leftArm.rotation.z = -0.3 * this.aimT; this.leftArm.rotation.y = 0.4 * this.aimT;

                const peers = this.isEnemy ? enemies : allies;
                peers.forEach(peer => {
                    if (peer !== this && !peer.dead) {
                        const cdx = this.mesh.position.x - peer.mesh.position.x; const cdz = this.mesh.position.z - peer.mesh.position.z; const distSq = cdx*cdx + cdz*cdz;
                        if (distSq < 0.64 && distSq > 0.0001) {
                            const cDist = Math.sqrt(distSq); const overlap = 0.8 - cDist;
                            let nx = cdx / cDist; let nz = cdz / cDist; let tx = -nz; let tz = nx;
                            this.mesh.position.x += (nx * 0.6 + tx * 0.8) * overlap * 5 * dt; this.mesh.position.z += (nz * 0.6 + tz * 0.8) * overlap * 5 * dt;
                        }
                    }
                });

                let aiPos2D = { x: this.mesh.position.x, z: this.mesh.position.z };
                resolveObstacles(aiPos2D, 0.4);
                this.mesh.position.x = aiPos2D.x;
                this.mesh.position.z = aiPos2D.z;

                let minZ, maxZ;
                if (this.isEnemy) {
                    if (this.coverTier > 0) { minZ = -5.0; maxZ = 36.2; } 
                    else if (this.trenchLevel === 'front') { minZ = 18.2; maxZ = 21.8; }
                    else { minZ = 26.8; maxZ = 36.2; }
                } else {
                    if (this.coverTier > 0) { minZ = -36.2; maxZ = 5.0; }
                    else if (this.trenchLevel === 'front') { minZ = -21.8; maxZ = -18.2; }
                    else { minZ = -36.2; maxZ = -26.8; }
                }
                this.mesh.position.z = Math.max(minZ, Math.min(maxZ, this.mesh.position.z));

                if (this.state !== 'moving' && this.targetCover) {
                    this.mesh.position.x += (this.targetCover.x - this.mesh.position.x) * 2 * dt;
                    this.mesh.position.z += (this.targetCover.z - this.mesh.position.z) * 2 * dt;
                }

                this.mesh.position.y = getTerrainHeight(this.mesh.position.x, this.mesh.position.z);
            }

            calculateExposure(target) {
                const heightOffset = 1.55 - (this.crouchT * 0.45);
                const eyeStart = this.mesh.position.clone().add(new THREE.Vector3(0, heightOffset, 0));
                const pointsToCheck = [];
                
                if (target.isPlayer) {
                    const base = playerRoot.position.clone();
                    pointsToCheck.push(base.clone().add(new THREE.Vector3(0, isCrouched ? 0.8 : 1.5, 0))); 
                    pointsToCheck.push(base.clone().add(new THREE.Vector3(0, isCrouched ? 0.4 : 1.0, 0))); 
                    pointsToCheck.push(base.clone().add(new THREE.Vector3(0, 0.2, 0)));                    
                } else {
                    const base = target.mesh.position.clone();
                    const cOffset = target.crouchT * 0.45;
                    pointsToCheck.push(base.clone().add(new THREE.Vector3(0, 1.55 - cOffset, 0)));         
                    pointsToCheck.push(base.clone().add(new THREE.Vector3(0, 1.0 - (cOffset * 0.5), 0)));  
                    pointsToCheck.push(base.clone().add(new THREE.Vector3(0, 0.3, 0)));                    
                }

                let hits = 0;
                
                for (let pt of pointsToCheck) {
                    const dir = pt.clone().sub(eyeStart).normalize();
                    const dist = eyeStart.distanceTo(pt);
                    raycaster.set(eyeStart, dir);
                    const intersects = raycaster.intersectObjects(worldMeshes, false);
                    
                    if (!(intersects.length > 0 && intersects[0].distance < dist)) {
                        hits++;
                    }
                }
                
                return hits / pointsToCheck.length; 
            }

            checkLOS(target) {
                return this.calculateExposure(target) > 0;
            }

            findTarget() {
                let targets = this.isEnemy ? [...allies, playerAI] : enemies;
                targets = targets.filter(t => !t.dead && t.hp > 0);
                if (targets.length === 0) return null;
                
                const myPos = this.mesh.position;
                const myForward = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), this.mesh.rotation.y);
                
                let bestTarget = null;
                let bestScore = Infinity;

                for (let i = 0; i < targets.length; i++) {
                    const target = targets[i];
                    const tPos = target.isPlayer ? playerRoot.position : target.mesh.position;
                    let score = tPos.distanceToSquared(myPos);
                    
                    if (score > 10000) continue; 
                    
                    const exposure = this.calculateExposure(target);
                    if (exposure === 0) continue; 

                    const toTarget = tPos.clone().sub(myPos).normalize();
                    const dot = myForward.dot(toTarget);
                    
                    if (dot > 0.5) score *= 0.3; 
                    else if (dot < 0) score *= 2.5;
                    
                    score /= exposure; 
                    
                    score *= (0.8 + Math.random() * 0.4); 

                    if (score < bestScore) {
                        bestScore = score;
                        bestTarget = target;
                    }
                }
                
                return bestTarget;
            }

            aimAtTarget(dt) {
                if (!this.target) return;
                let targetPos = new THREE.Vector3();
                if (this.target.isPlayer) camera.getWorldPosition(targetPos);
                else targetPos.copy(this.target.mesh.position);
                
                const targetYaw = Math.atan2(targetPos.x - this.mesh.position.x, targetPos.z - this.mesh.position.z);
                let diff = targetYaw - this.mesh.rotation.y;
                while (diff < -Math.PI) diff += Math.PI * 2; while (diff > Math.PI) diff -= Math.PI * 2;
                this.mesh.rotation.y += diff * 8 * dt;
            }

            shoot() {
                if (!this.target || this.target.dead) return;
                const heightOffset = 1.55 - (this.crouchT * 0.45);
                const eyeStart = this.mesh.position.clone().add(new THREE.Vector3(0, heightOffset, 0));
                const visualStart = this.mesh.position.clone().add(new THREE.Vector3(0, heightOffset - 0.2, 0));

                let targetPos = new THREE.Vector3();
                if (this.target.isPlayer) { camera.getWorldPosition(targetPos); targetPos.y -= 0.2; } 
                else { const targetHeightOffset = 1.55 - (this.target.crouchT * 0.45); targetPos.copy(this.target.mesh.position).add(new THREE.Vector3(0, targetHeightOffset, 0)); }
                
                const dir = targetPos.clone().sub(eyeStart).normalize(); const dist = eyeStart.distanceTo(targetPos);
                const spread = 0.05 + (dist * 0.002); dir.x += (Math.random() - 0.5) * spread; dir.y += (Math.random() - 0.5) * spread; dir.z += (Math.random() - 0.5) * spread; dir.normalize();

                showMuzzleFlash(visualStart, dir); raycaster.set(eyeStart, dir);
                const hitTargets = this.isEnemy ? [playerAI.mesh, ...allies.map(a => a.mesh)] : enemies.map(e => e.mesh);
                const intersects = raycaster.intersectObjects([...worldMeshes, ...hitTargets], true);

                let hitDistance = 200;
                if (intersects.length > 0) {
                    const hit = intersects[0]; hitDistance = hit.distance;
                    if (hit.object.userData.ai) {
                        const hitObj = hit.object.userData.ai;
                        if (hitObj.isPlayer) hitObj.takeDamage(1, this);
                        else if (hitObj.isEnemy !== this.isEnemy) hitObj.takeDamage(hit.object.name === "head" ? 99 : 1, this);
                    } else {
                        let normal = new THREE.Vector3(0, 1, 0);
                        if (hit.face) { normal.copy(hit.face.normal).applyMatrix3(new THREE.Matrix3().getNormalMatrix(hit.object.matrixWorld)).normalize(); }
                        createImpact(hit.point, normal);
                    }
                }

                if (Math.random() < 0.25) createTracer(visualStart, dir, hitDistance);

                const bulletRay = new THREE.Ray(eyeStart, dir);
                const hitPool = this.isEnemy ? [...allies, playerAI] : enemies;
                hitPool.forEach(t => {
                    if (!t.dead) {
                        const posOffset = t.isPlayer ? (isCrouched ? 0.4 : 1.0) : (1.0 - (t.crouchT * 0.45));
                        const pos = t.isPlayer ? playerRoot.position.clone() : t.mesh.position.clone(); pos.y += posOffset;
                        const distSq = bulletRay.distanceSqToPoint(pos);
                        if (distSq < 16.0) { if (!t.isPlayer) t.alert(this); else if (distSq < 0.25) playNearMissSound(); }
                    }
                });
            }
        }

        const allies = [];
        const enemies = [];
        
        function spawnSoldiers(count) {
            allies.forEach(a => scene.remove(a.mesh)); enemies.forEach(e => scene.remove(e.mesh));
            allies.length = 0; enemies.length = 0;
            for (let i = 0; i < count; i++) { allies.push(new AI(false)); enemies.push(new AI(true)); }
        }
        spawnSoldiers(45);

        // --- GAME LOOP ---
        let lastTime = performance.now();
        let bobTime = 0;

        function animate() {
            requestAnimationFrame(animate);

            const now = performance.now();
            let dt = (now - lastTime) / 1000;
            lastTime = now;
            if (dt > 0.1) dt = 0.1;

            if (!playerAI.dead && document.pointerLockElement) {
                if (gameMode === 'elimination') {
                    const aliveEnemies = enemies.filter(e => !e.dead).length;
                    document.getElementById('reserves-indicator').innerText = `Enemies Remaining: ${enemyReserves + aliveEnemies}`;
                    
                    if (aliveEnemies === 0 && enemyReserves <= 0) {
                        document.exitPointerLock();
                        document.getElementById('victory-screen').style.display = 'flex';
                        playerAI.dead = true; 
                        return; 
                    }
                }

                if (mgHeat > 0) {
                    mgHeat -= (mgOverheated ? 20 : 35) * dt;
                    if (mgHeat <= 0) { mgHeat = 0; mgOverheated = false; }
                }
                
                const heatContainer = document.getElementById('heatbar-container');
                if (currentWeaponIndex === 1) {
                    heatContainer.style.display = 'block';
                    document.getElementById('heatbar').style.width = mgHeat + '%';
                    document.getElementById('heatbar').style.background = mgOverheated ? '#ff0000' : '#ff8800';
                } else heatContainer.style.display = 'none';

                const wep = weaponsData[currentWeaponIndex];
                if (keys.lmb) { if (wep.type === 'auto' || lmbJustPressed) shootPlayer(); }
                lmbJustPressed = false;

                const isAiming = keys.rmb || keys.space; let targetFov = 75;
                document.getElementById('scope-overlay').style.display = (isAiming && currentWeaponIndex === 2) ? 'flex' : 'none';
                document.getElementById('crosshair').style.display = (isAiming || currentWeaponIndex === 2) ? 'none' : 'block';

                if (isAiming) {
                    if (currentWeaponIndex === 2) { targetFov = 75 / sniperZoomLevel; modelSniper.visible = false; } 
                    else { targetFov = 40; weaponContainer.position.lerp(new THREE.Vector3(0, wep.alignY, -0.25), 15 * dt); }
                } else {
                    if (currentWeaponIndex === 2) modelSniper.visible = true;
                    weaponContainer.position.lerp(new THREE.Vector3(0.2, -0.2, -0.4), 15 * dt);
                }

                camera.fov += (targetFov - camera.fov) * 15 * dt; camera.updateProjectionMatrix();
                weaponContainer.position.z += (-0.4 - weaponContainer.position.z) * 10 * dt;

                const targetLeanZ = keys.q ? 0.25 : (keys.e ? -0.25 : 0); 
                const targetLeanX = keys.q ? -0.5 : (keys.e ? 0.5 : 0);
                
                leanObject.rotation.z += (targetLeanZ - leanObject.rotation.z) * 10 * dt; 
                
                if (typeof leanObject.userData.baseLocalX === 'undefined') leanObject.userData.baseLocalX = 0;
                leanObject.userData.baseLocalX += (targetLeanX - leanObject.userData.baseLocalX) * 10 * dt;

                let leanLocalVec = new THREE.Vector3(leanObject.userData.baseLocalX, 0, 0);
                leanLocalVec.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
                let leanPos2D = { x: playerRoot.position.x + leanLocalVec.x, z: playerRoot.position.z + leanLocalVec.z };
                
                resolveObstacles(leanPos2D, 0.3); 
                
                let resolvedLocalVec = new THREE.Vector3(leanPos2D.x - playerRoot.position.x, 0, leanPos2D.z - playerRoot.position.z);
                resolvedLocalVec.applyAxisAngle(new THREE.Vector3(0, 1, 0), -yaw);
                
                leanObject.position.x = resolvedLocalVec.x;
                leanObject.position.z = resolvedLocalVec.z; 

                const targetEyeY = isCrouched ? 0.8 : 1.5; leanObject.position.y += (targetEyeY - leanObject.position.y) * 10 * dt;
                
                playerAI.mesh.scale.y = isCrouched ? 0.5 : 1.0; 
                playerAI.mesh.position.y = isCrouched ? 0.45 : 0.9; 
                playerAI.mesh.position.x = leanObject.position.x; 
                playerAI.mesh.position.z = leanObject.position.z; 

                const moveDir = new THREE.Vector3();
                if (keys.w) moveDir.z -= 1; if (keys.s) moveDir.z += 1; if (keys.a) moveDir.x -= 1; if (keys.d) moveDir.x += 1;
                if (moveDir.lengthSq() > 0) moveDir.normalize(); moveDir.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);

                const speed = (keys.shift && !isCrouched && !isAiming) ? 8 : (isCrouched ? 3 : 5);
                const velocity = moveDir.multiplyScalar(speed * dt);

                if (moveDir.lengthSq() > 0 && document.pointerLockElement && !isCrouched) {
                    bobTime += dt * (keys.shift ? 12 : 8); pitchObject.position.y = Math.sin(bobTime) * 0.05;
                } else pitchObject.position.y += (0 - pitchObject.position.y) * 10 * dt;

                let nextPos = playerRoot.position.clone().add(velocity); const pr = 0.4; 
                
                if (nextPos.z < -36.3 + pr) nextPos.z = -36.3 + pr; if (nextPos.z > 36.3 - pr) nextPos.z = 36.3 - pr;
                if (nextPos.x < -95 + pr) nextPos.x = -95 + pr; if (nextPos.x > 95 - pr) nextPos.x = 95 - pr;

                let pPos2D = { x: nextPos.x, z: nextPos.z };
                resolveObstacles(pPos2D, pr);
                nextPos.x = pPos2D.x; nextPos.z = pPos2D.z;

                const allLivingAI = [...allies, ...enemies].filter(a => !a.dead);
                allLivingAI.forEach(ai => {
                    let dx = nextPos.x - ai.mesh.position.x; let dz = nextPos.z - ai.mesh.position.z; let distSq = dx * dx + dz * dz;
                    let minDist = 0.8; 
                    if (distSq < minDist * minDist && distSq > 0.0001) {
                        let dist = Math.sqrt(distSq); let overlap = minDist - dist;
                        nextPos.x += (dx / dist) * overlap; nextPos.z += (dz / dist) * overlap;
                    }
                });

                playerRoot.position.copy(nextPos);
                playerRoot.position.y = getTerrainHeight(playerRoot.position.x, playerRoot.position.z);
            }

            const hurtEl = document.getElementById('hurt-overlay');
            if (!playerAI.dead && parseFloat(hurtEl.style.opacity) > 0) hurtEl.style.opacity = Math.max(0, parseFloat(hurtEl.style.opacity) - dt);

            if (fpFlashMaterial.opacity > 0) { fpFlashMaterial.opacity = Math.max(0, fpFlashMaterial.opacity - dt * 20); fpFlashLight.intensity = Math.max(0, fpFlashLight.intensity - dt * 40); }

            impacts.forEach(imp => {
                if (imp.life > 0) { imp.life -= dt; imp.mesh.scale.addScalar(dt * 10); imp.mesh.material.opacity = (imp.life / 0.2); if (imp.life <= 0) imp.mesh.visible = false; }
            });

            allies.forEach(a => a.update(dt)); enemies.forEach(e => e.update(dt));

            flashes.forEach(f => { if (f.life > 0) { f.life -= dt; if (f.life <= 0) f.mesh.material.opacity = 0; } });

            tracers.forEach(t => {
                if (t.life > 0) {
                    t.life -= dt; const moveDist = 150 * dt; t.traveled += moveDist;
                    if (t.traveled >= t.maxDist) { t.life = 0; t.mesh.visible = false; } 
                    else { t.mesh.position.add(t.dir.clone().multiplyScalar(moveDist)); }
                }
            });

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        animate();

    </script>
</body>
</html>
