<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Trench Warfare FPS</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: sans-serif;
            user-select: none;
        }
        #game-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 24px;
            font-weight: bold;
        }
        #action-prompt {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 20px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border: 2px solid #333;
            display: none;
        }
        #healthbar-container {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 300px;
            height: 25px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #333;
        }
        #healthbar {
            width: 100%;
            height: 100%;
            background: #00aa00;
            transition: width 0.2s;
        }
        #heatbar-container {
            position: absolute;
            bottom: 60px;
            left: 30px;
            width: 300px;
            height: 10px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #333;
            display: none;
        }
        #heatbar {
            width: 0%;
            height: 100%;
            background: #ff8800;
            transition: width 0.1s;
        }
        #weapon-indicator {
            position: absolute;
            bottom: 30px;
            right: 30px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border: 2px solid #333;
        }
        #kill-count-indicator {
            position: absolute;
            bottom: 90px;
            right: 30px;
            color: white;
            font-size: 20px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 16px;
            border: 2px solid #333;
        }
        #reserves-indicator {
            position: absolute;
            top: 30px;
            right: 30px;
            color: white;
            font-size: 20px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 16px;
            border: 2px solid #333;
            display: none;
        }
        #scope-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(circle, transparent 35%, rgba(0,0,0,0.9) 55%, black 100%);
            align-items: center;
            justify-content: center;
        }
        .scope-line-h { width: 100%; height: 2px; background: rgba(0,0,0,0.8); position: absolute; }
        .scope-line-v { width: 2px; height: 100%; background: rgba(0,0,0,0.8); position: absolute; }
        .scope-dot { width: 4px; height: 4px; background: red; border-radius: 50%; position: absolute; }
        #instructions {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 10;
        }
        .menu-btn {
            background: #333;
            color: #fff;
            border: 2px solid #555;
            padding: 12px 24px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
            border-radius: 4px;
            font-family: sans-serif;
        }
        .menu-btn:hover { background: #555; border-color: #888; }
        #victory-screen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 50, 0, 0.85);
            color: white;
            z-index: 20;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }
        .inst-text {
            max-width: 600px;
            text-align: center;
            line-height: 1.6;
            font-size: 18px;
        }
        #hurt-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: red;
            opacity: 0;
            transition: opacity 0.1s;
        }
        #hit-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border-top: 2px solid white;
            border-right: 2px solid white;
            opacity: 0;
            transform-origin: center;
            transform: translate(-50%, -50%) rotate(45deg);
            transition: opacity 0.1s;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="ui">
        <div id="hurt-overlay"></div>
        <div id="scope-overlay">
            <div class="scope-line-h"></div>
            <div class="scope-line-v"></div>
            <div class="scope-dot"></div>
        </div>
        <div id="crosshair">+</div>
        <div id="action-prompt">Press T to use turret</div>
        <div id="hit-marker"></div>
        <div id="healthbar-container">
            <div id="healthbar"></div>
        </div>
        <div id="heatbar-container">
            <div id="heatbar"></div>
        </div>
        <div id="reserves-indicator">Enemies Remaining: 0</div>
        <div id="kill-count-indicator">Kills: 0</div>
        <div id="weapon-indicator">1: Rifle</div>
        <div id="instructions">
            <div class="inst-text">
                <h2>TRENCH WARFARE</h2>
                <p>Select a mode to deploy and lock pointer.</p>
                <p>
                    <b>WASD</b>: Move &nbsp;|&nbsp; <b>Shift</b>: Sprint &nbsp;|&nbsp; <b>C</b>: Toggle Crouch / Slide<br>
                    <b>Q / E</b>: Lean (Roll while Prone) &nbsp;|&nbsp; <b>T</b>: Mount Turret &nbsp;|&nbsp; <b>R</b>: Reload Turret &nbsp;|&nbsp; <b>Z</b>: Go Prone<br>
                    <b>RMB / Space</b>: Aim Down Sights &nbsp;|&nbsp; <b>LMB</b>: Fire<br>
                    <b>1, 2, 3</b>: Switch Weapons &nbsp;|&nbsp; <b>F / G</b>: Sniper Zoom
                </p>
                <p style="color:#aaa; font-size:14px;">Survive an endless onslaught or eliminate the enemy reinforcements.</p>
            </div>
            <div style="margin: 20px 0; display: flex; flex-direction: column; align-items: center; background: rgba(0,0,0,0.5); padding: 15px; border-radius: 8px; border: 1px solid #444; width: 340px;">
                <label for="soldier-count" style="font-size: 16px; font-weight: bold; margin-bottom: 5px;">
                    Total Forces (Elimination): <span id="soldier-count-display">500</span>
                </label>
                <input type="range" id="soldier-count" min="10" max="1000" value="500" style="width: 250px; cursor: pointer; margin-bottom: 15px;">
                <label for="active-count" style="font-size: 16px; font-weight: bold; margin-bottom: 5px;">
                    Max Active on Field: <span id="active-count-display">25</span>
                </label>
                <input type="range" id="active-count" min="10" max="100" value="25" style="width: 250px; cursor: pointer;">
            </div>
            <div style="display: flex; gap: 20px;">
                <button id="btn-endless" class="menu-btn">Play Endless Mode</button>
                <button id="btn-elimination" class="menu-btn">Play Elimination Mode</button>
            </div>
        </div>
        <div id="victory-screen">
            <h1 style="font-size: 72px; margin-bottom: 10px; text-shadow: 0 0 10px #0f0;">VICTORY</h1>
            <p style="font-size: 24px; margin-bottom: 30px;">The enemy line has been broken.</p>
            <button id="btn-victory-menu" class="menu-btn">Return to Menu</button>
        </div>
    </div>

    <script>

        // ================================================================
        // SECTION 1: CONFIGURATION CONSTANTS
        // ================================================================

        // --- Scene ---
        const FOG_COLOR    = 0x555555;
        const FOG_DENSITY  = 0.015;

        // --- Player ---
        const PLAYER_RADIUS        = 0.4;
        const PLAYER_HP_MAX        = 10;
        const EYE_HEIGHT_STAND     = 1.5;
        const EYE_HEIGHT_CROUCH    = 0.8;
        const EYE_HEIGHT_PRONE     = 0.3;

        // --- Movement speeds ---
        const SPEED_STAND_WALK     = 5;
        const SPEED_STAND_SPRINT   = 8;
        const SPEED_CROUCH_WALK    = 3;
        const SPEED_CROUCH_SPRINT  = 6.5;
        const SPEED_PRONE          = 1.125;
        const SPEED_PRONE_SPRINT   = 3.0;
        const SPEED_PRONE_ROLL     = 4.0;
        const SLIDE_INITIAL_SPEED  = 16.0;
        const SLIDE_DURATION       = 0.75;
        const SLIDE_FRICTION       = 20;

        // --- Machine gun heat ---
        const MG_HEAT_PER_SHOT     = 8;
        const MG_OVERHEAT_CAP      = 100;
        const MG_COOL_NORMAL       = 35;
        const MG_COOL_OVERHEAT     = 20;

        // --- Sniper bolt action ---
        const SNIPER_PRE_BOLT_DELAY  = 250;   // ms before bolt animation begins
        const SNIPER_ZOOM_DEFAULT    = 4;
        const SNIPER_ZOOM_MIN        = 2;
        const SNIPER_ZOOM_MAX        = 10;

        // --- Audio ---
        const AUDIO_PROXIMITY_RANGE  = 25;    // metres, positional audio cutoff
        const NEAR_MISS_THROTTLE     = 0.3;   // seconds between bullet-whiz sounds

        // --- Turret ---
        const TURRET_MOUNT_RANGE          = 3.0;
        const TURRET_PLAYER_FIRE_COOLDOWN = 600;   // ms
        const TURRET_AI_FIRE_COOLDOWN     = 1800;  // ms
        const TURRET_EXPLOSION_RADIUS     = 4.0;
        const TURRET_EXPLOSION_DAMAGE     = 10;

        // --- AI ---
        const AI_MOVE_SPEED          = 4.5;
        const AI_DAMAGE_FROM_AI      = 0.05;  // flat damage when AI shoots AI
        const AI_PEER_SEPARATION     = 0.8;   // metres, crowd-separation radius

        // ================================================================
        // SECTION 2: THREE.JS SCENE SETUP
        // ================================================================

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(FOG_COLOR, FOG_DENSITY);
        scene.background = new THREE.Color(FOG_COLOR);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // ================================================================
        // SECTION 3: AUDIO SYSTEM
        // ================================================================

        // --- Audio state ---
        let audioCtx;
        let masterFilter;
        let masterGain;
        let shellShockTimer = 0;
        const audioBuffers = {};

        function triggerShellShock(duration) {
            shellShockTimer = Math.max(shellShockTimer, duration);
        }

        function createRealisticGunshot(ctx) {
            const buffer = ctx.createBuffer(1, ctx.sampleRate * 1.0, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            let lastOut = 0;
            for (let i = 0; i < data.length; i++) {
                const t = i / ctx.sampleRate;
                const crack = (Math.random() * 2 - 1) * Math.exp(-t * 50) * 1.5;
                const boomFreq = 40 + 140 * Math.exp(-t * 35);
                const boom = Math.sin(2 * Math.PI * boomFreq * t) * Math.exp(-t * 12) * 4.0;
                const sub = Math.sin(2 * Math.PI * 35 * t) * Math.exp(-t * 6) * 1.5;
                const noise = (Math.random() * 2 - 1) * Math.exp(-t * 18) * 0.8;
                let sample = crack + boom + sub + noise;
                lastOut = lastOut + 0.45 * (sample - lastOut);
                let saturated = Math.tanh(lastOut * 1.3);
                const tail = (Math.random() * 2 - 1) * Math.exp(-t * 2.5) * 0.12;
                data[i] = saturated + tail;
            }
            return buffer;
        }

        function createRealisticExplosion(ctx) {
            const buffer = ctx.createBuffer(1, ctx.sampleRate * 2.5, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            let lastOut = 0;
            for (let i = 0; i < data.length; i++) {
                const t = i / ctx.sampleRate;
                const noise = Math.random() * 2 - 1;
                const attack = Math.min(1.0, t * 20);
                const decay = Math.exp(-t * 1.5);
                const rumble = Math.sin(2 * Math.PI * (20 + 30 * Math.random()) * t);
                let sample = (noise * 0.6 + rumble * 0.4) * attack * decay;
                lastOut = lastOut + 0.05 * (sample - lastOut);
                data[i] = lastOut * 3.0;
            }
            return buffer;
        }

        function createBulletWhiz(ctx) {
            const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.3, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            let lastOut = 0;
            for (let i = 0; i < data.length; i++) {
                const t = i / ctx.sampleRate;
                const freq = 1200 - 800 * (t / 0.3);
                const tone = Math.sin(2 * Math.PI * freq * t);
                const noise = Math.random() * 2 - 1;
                const env = t < 0.1 ? (t / 0.1) : 1.0 - ((t - 0.1) / 0.2);
                let sample = (tone * 0.6 + noise * 0.4) * env;
                lastOut = lastOut + 0.4 * (sample - lastOut);
                data[i] = lastOut * 0.8;
            }
            return buffer;
        }

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();

                masterFilter = audioCtx.createBiquadFilter();
                masterFilter.type = 'lowpass';
                masterFilter.frequency.value = 22000;

                masterGain = audioCtx.createGain();
                masterGain.gain.value = 1.0;

                masterFilter.connect(masterGain);
                masterGain.connect(audioCtx.destination);

                audioBuffers['gunshot']   = createRealisticGunshot(audioCtx);
                audioBuffers['artillery'] = createRealisticExplosion(audioCtx);
                audioBuffers['whiz']      = createBulletWhiz(audioCtx);
            }
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function playSoundFile(name, pitchShift = 1.0, volume = 1.0, isDistant = false) {
            if (!audioCtx || !audioBuffers[name]) return;
            const source = audioCtx.createBufferSource();
            source.buffer = audioBuffers[name];
            source.playbackRate.value = pitchShift * (0.95 + Math.random() * 0.1);
            const gain = audioCtx.createGain();
            gain.gain.value = volume;
            if (isDistant) {
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 300 + Math.random() * 500;
                source.connect(filter);
                filter.connect(gain);
            } else {
                source.connect(gain);
            }
            gain.connect(masterFilter);
            source.start(0);
        }

        function playPositionalSound(pos, type = 'gunshot') {
            if (!audioCtx) return;
            const camPos = camera.getWorldPosition(new THREE.Vector3());
            const dist = camPos.distanceTo(pos);
            if (dist > AUDIO_PROXIMITY_RANGE) return;
            let vol = 2.0 / (2.0 + dist);
            if (type === 'impact') {
                playSoundFile('gunshot', 1.5 + Math.random() * 0.5, vol * 0.3);
            } else if (type === 'artillery') {
                playSoundFile('artillery', 1.2 + Math.random() * 0.3, vol * 1.5);
            } else {
                playSoundFile('gunshot', 0.9 + Math.random() * 0.2, vol * 0.525);
            }
        }

        let lastNearMissTime = 0;
        function playNearMissSound() {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;
            if (now - lastNearMissTime < NEAR_MISS_THROTTLE) return;
            lastNearMissTime = now;
            playSoundFile('whiz', 0.9 + Math.random() * 0.2, 0.8);
        }

        function startAmbientBattle() {
            setInterval(() => {
                if (Math.random() > 0.5) {
                    const isCloseHit = Math.random() < 0.15;
                    playSoundFile('artillery', 0.6 + Math.random() * 0.4, isCloseHit ? 1.5 : 0.7, !isCloseHit);
                    let hl = horizonLights[Math.floor(Math.random() * horizonLights.length)];
                    hl.light.intensity = 5.0 + Math.random() * 15.0;
                    hl.timer = 0.2 + Math.random() * 0.4;
                    if (isCloseHit) triggerShellShock(2.5);
                }
            }, 2500);

            setInterval(() => {
                if (Math.random() > 0.3) playSoundFile('gunshot', 0.25 + Math.random() * 0.2, 0.1125, true);
            }, 150);
        }

        // ================================================================
        // SECTION 4: WORLD GEOMETRY & TERRAIN
        // ================================================================

        // --- Shared state ---
        const worldMeshes        = [];
        const collisionObstacles = [];
        const turrets            = [];
        let mountedTurret        = null;

        // --- Terrain height function ---
        function getTerrainHeight(x, z) {
            const absZ = Math.abs(z);
            if (absZ < 22.0) return -1.2;
            if (absZ >= 22.0 && absZ < 26.0) {
                const inGap = (Math.abs(x + 60) < 4.2) || (Math.abs(x + 20) < 4.2) ||
                              (Math.abs(x - 20) < 4.2) || (Math.abs(x - 60) < 4.2);
                if (inGap) {
                    return -1.2 + (2.2 * ((absZ - 22.0) / 4.0));
                } else {
                    return 1.0;
                }
            }
            return 1.0;
        }

        // --- Collision resolution ---
        function resolveObstacles(pos, radius) {
            for (let obs of collisionObstacles) {
                let closestX = Math.max(obs.minX, Math.min(pos.x, obs.maxX));
                let closestZ = Math.max(obs.minZ, Math.min(pos.z, obs.maxZ));
                if (pos.x >= obs.minX && pos.x <= obs.maxX && pos.z >= obs.minZ && pos.z <= obs.maxZ) {
                    let dLeft   = pos.x - obs.minX;
                    let dRight  = obs.maxX - pos.x;
                    let dTop    = pos.z - obs.minZ;
                    let dBottom = obs.maxZ - pos.z;
                    let minD = Math.min(dLeft, dRight, dTop, dBottom);
                    if (minD === dLeft)   pos.x = obs.minX - radius;
                    else if (minD === dRight)  pos.x = obs.maxX + radius;
                    else if (minD === dTop)    pos.z = obs.minZ - radius;
                    else if (minD === dBottom) pos.z = obs.maxZ + radius;
                } else {
                    let dx = pos.x - closestX;
                    let dz = pos.z - closestZ;
                    let distSq = dx * dx + dz * dz;
                    if (distSq < radius * radius && distSq > 0.0001) {
                        let dist = Math.sqrt(distSq);
                        let overlap = radius - dist;
                        pos.x += (dx / dist) * overlap;
                        pos.z += (dz / dist) * overlap;
                    }
                }
            }
        }

        // --- Materials ---
        const groundMat = new THREE.MeshLambertMaterial({ color: 0x3a4530 });
        const wallMat   = new THREE.MeshLambertMaterial({ color: 0x4a3c2b });
        const woodMat   = new THREE.MeshLambertMaterial({ color: 0x3d2817 });

        // --- Base ground plane ---
        const baseFloor = new THREE.Mesh(new THREE.PlaneGeometry(200, 100), groundMat);
        baseFloor.rotation.x = -Math.PI / 2;
        baseFloor.position.set(0, -1.2, 0);
        scene.add(baseFloor);
        worldMeshes.push(baseFloor);

        // --- No Man's Land raised platform regions ---
        const nmlRegions = [
            { x: -71.5, w: 57, z: -9.75, d: 15.5 },
            { x:    0,  w: 74, z: -9.75, d: 15.5 },
            { x:  71.5, w: 57, z: -9.75, d: 15.5 },
            { x: -71.5, w: 57, z:  9.75, d: 15.5 },
            { x:    0,  w: 74, z:  9.75, d: 15.5 },
            { x:  71.5, w: 57, z:  9.75, d: 15.5 },
        ];
        nmlRegions.forEach(reg => {
            const b = new THREE.Mesh(new THREE.BoxGeometry(reg.w, 1.2, reg.d), groundMat);
            b.position.set(reg.x, -0.6, reg.z);
            scene.add(b);
            worldMeshes.push(b);
            collisionObstacles.push({ minX: reg.x - reg.w/2, maxX: reg.x + reg.w/2, minZ: reg.z - reg.d/2, maxZ: reg.z + reg.d/2 });
        });

        // --- Battlefield floor planes ---
        const bfA = new THREE.Mesh(new THREE.PlaneGeometry(200, 10.75), wallMat);
        bfA.rotation.x = -Math.PI / 2;
        bfA.position.set(0, 1.0, -31.375);
        const bfE = new THREE.Mesh(new THREE.PlaneGeometry(200, 10.75), wallMat);
        bfE.rotation.x = -Math.PI / 2;
        bfE.position.set(0, 1.0, 31.375);
        scene.add(bfA, bfE);
        worldMeshes.push(bfA, bfE);

        // --- Ramps and trench-lip blocks ---
        const rampGeo     = new THREE.PlaneGeometry(8, 4.565);
        const gapCenters  = [-60, -20, 20, 60];
        const blockCenters = [-82, -40, 0, 40, 82];
        const blockWidths  = [36, 32, 32, 32, 36];

        for (let i = 0; i < blockCenters.length; i++) {
            let cx = blockCenters[i];
            let w  = blockWidths[i];

            let bA = new THREE.Mesh(new THREE.BoxGeometry(w, 2.2, 4.0), groundMat);
            bA.position.set(cx, -0.1, -24.0);
            scene.add(bA);
            worldMeshes.push(bA);
            collisionObstacles.push({ minX: cx - w/2, maxX: cx + w/2, minZ: -26.0, maxZ: -22.0 });

            let bE = new THREE.Mesh(new THREE.BoxGeometry(w, 2.2, 4.0), groundMat);
            bE.position.set(cx, -0.1, 24.0);
            scene.add(bE);
            worldMeshes.push(bE);
            collisionObstacles.push({ minX: cx - w/2, maxX: cx + w/2, minZ: 22.0, maxZ: 26.0 });
        }

        for (let i = 0; i < gapCenters.length; i++) {
            let rA = new THREE.Mesh(rampGeo, groundMat);
            rA.rotation.x = -Math.PI / 2 + 0.5028;
            rA.position.set(gapCenters[i], -0.1, -24.0);
            scene.add(rA);
            worldMeshes.push(rA);

            let rE = new THREE.Mesh(rampGeo, groundMat);
            rE.rotation.x = -Math.PI / 2 - 0.5028;
            rE.position.set(gapCenters[i], -0.1, 24.0);
            scene.add(rE);
            worldMeshes.push(rE);
        }

        // --- Trench wall builder ---
        function createWall(x, z, w, h, yCenter) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, 0.5), wallMat);
            mesh.position.set(x, yCenter, z);
            scene.add(mesh);
            worldMeshes.push(mesh);
            collisionObstacles.push({ minX: x - w/2, maxX: x + w/2, minZ: z - 0.25, maxZ: z + 0.25 });
        }

        // Inner trench walls (front)
        createWall(-71.5, -17.75, 57, 1.4, -0.5);
        createWall(   0,  -17.75, 74, 1.4, -0.5);
        createWall( 71.5, -17.75, 57, 1.4, -0.5);
        // Inner trench walls (back)
        createWall(-71.5,  17.75, 57, 1.4, -0.5);
        createWall(   0,   17.75, 74, 1.4, -0.5);
        createWall( 71.5,  17.75, 57, 1.4, -0.5);
        // Outer boundary walls
        createWall(0, -36.75, 200, 2.0, 2.0);
        createWall(0,  36.75, 200, 2.0, 2.0);

        // --- Random jagged buttresses along trench walls ---
        for (let i = 0; i < 50; i++) {
            let bx = (Math.random() - 0.5) * 190;
            let bz = Math.random() > 0.5 ? (-17.5 + (Math.random() * 1.5)) : (17.5 - (Math.random() * 1.5));
            if (Math.abs(bx + 60) < 5 || Math.abs(bx + 20) < 5 || Math.abs(bx - 20) < 5 || Math.abs(bx - 60) < 5) continue;
            let bw = 1.0 + Math.random() * 4.0;
            let bh = 1.0 + Math.random() * 1.5;
            let bm = new THREE.Mesh(
                new THREE.BoxGeometry(bw, bh, 0.8 + Math.random()),
                Math.random() > 0.5 ? wallMat : groundMat
            );
            bm.position.set(bx, -1.2 + bh / 2, bz);
            bm.rotation.y = (Math.random() - 0.5) * 0.4;
            scene.add(bm);
            worldMeshes.push(bm);
            collisionObstacles.push({ minX: bx - bw/2, maxX: bx + bw/2, minZ: bz - 0.6, maxZ: bz + 0.6 });
        }

        // --- Side boundary walls ---
        const sideWallGeo = new THREE.BoxGeometry(2, 10, 80);
        const sw1 = new THREE.Mesh(sideWallGeo, wallMat); sw1.position.set(-100, 0, 0);
        const sw2 = new THREE.Mesh(sideWallGeo, wallMat); sw2.position.set( 100, 0, 0);
        scene.add(sw1, sw2);
        worldMeshes.push(sw1, sw2);
        collisionObstacles.push({ minX: -101, maxX:  -99, minZ: -40, maxZ: 40 });
        collisionObstacles.push({ minX:   99, maxX:  101, minZ: -40, maxZ: 40 });

        // --- Cover position arrays ---
        const allyCoversFront  = [];
        const allyCoversBack   = [];
        const enemyCoversFront = [];
        const enemyCoversBack  = [];
        const allyPathCovers   = [];
        const enemyPathCovers  = [];
        const midCoversAlly    = [];
        const midCoversEnemy   = [];

        // --- Cover box builder ---
        function addCover(x, z, arr, dirZ) {
            let bw   = 1.2 + Math.random() * 0.8;
            let bd   = 0.8 + Math.random() * 0.4;
            let mesh = new THREE.Mesh(new THREE.BoxGeometry(bw, 1.2 + Math.random() * 0.5, bd), woodMat);
            mesh.position.set(x, -0.6, z);
            mesh.rotation.y = (Math.random() - 0.5) * 1.5;
            scene.add(mesh);
            worldMeshes.push(mesh);
            let maxR = Math.max(bw, bd) / 1.5;
            collisionObstacles.push({ minX: x - maxR, maxX: x + maxR, minZ: z - maxR, maxZ: z + maxR });
            arr.push({ x: x, z: z + dirZ, y: -1.2 });
        }

        // Path covers (jittered)
        addCover(-41.5 + Math.random()*2, -12 + (Math.random()-0.5)*3, allyPathCovers, -1.2);
        addCover(-38.5 - Math.random()*2,  -6 + (Math.random()-0.5)*3, allyPathCovers, -1.2);
        addCover( 41.5 + Math.random()*2, -12 + (Math.random()-0.5)*3, allyPathCovers, -1.2);
        addCover( 38.5 - Math.random()*2,  -6 + (Math.random()-0.5)*3, allyPathCovers, -1.2);
        addCover(-41.5 + Math.random()*2,  12 + (Math.random()-0.5)*3, enemyPathCovers, 1.2);
        addCover(-38.5 - Math.random()*2,   6 + (Math.random()-0.5)*3, enemyPathCovers, 1.2);
        addCover( 41.5 + Math.random()*2,  12 + (Math.random()-0.5)*3, enemyPathCovers, 1.2);
        addCover( 38.5 - Math.random()*2,   6 + (Math.random()-0.5)*3, enemyPathCovers, 1.2);

        // Randomized mid-field skirmish covers
        for (let x = -90; x <= 90; x += 5 + Math.random() * 6) {
            if (Math.abs(x + 40) < 5 || Math.abs(x - 40) < 5) continue;
            let zOff = (Math.random() - 0.5) * 12;
            if (Math.random() > 0.5) addCover(x, -2.5 + zOff, midCoversAlly,  -1.2);
            else                     addCover(x,  2.5 + zOff, midCoversEnemy,  1.2);
        }

        // --- Random chaotic debris ---
        for (let i = 0; i < 60; i++) {
            const x = (Math.random() - 0.5) * 180;
            const z = (Math.random() - 0.5) * 35;
            if (Math.abs(x + 40) < 4 || Math.abs(x - 40) < 4) continue;
            let bw = 0.8 + Math.random();
            let bh = 0.5 + Math.random();
            let bd = 0.8 + Math.random();
            const mesh = new THREE.Mesh(
                new THREE.BoxGeometry(bw, bh, bd),
                Math.random() > 0.5 ? woodMat : wallMat
            );
            mesh.position.set(x, getTerrainHeight(x, z) + 0.2, z);
            mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            scene.add(mesh);
            worldMeshes.push(mesh);
            let maxR = Math.max(bw, bh, bd) / 1.8;
            collisionObstacles.push({ minX: x - maxR, maxX: x + maxR, minZ: z - maxR, maxZ: z + maxR });
        }

        // --- Ground craters / scorch marks ---
        const craterGeo = new THREE.PlaneGeometry(3, 3);
        const craterMat = new THREE.MeshBasicMaterial({ color: 0x1a1c14, depthWrite: false, transparent: true, opacity: 0.8 });
        for (let i = 0; i < 120; i++) {
            let cr = new THREE.Mesh(craterGeo, craterMat);
            let cx = (Math.random() - 0.5) * 190;
            let cz = (Math.random() - 0.5) * 36;
            let s  = 0.5 + Math.random() * 2;
            cr.scale.set(s, s, s);
            cr.rotation.x = -Math.PI / 2;
            cr.rotation.z = Math.random() * Math.PI;
            cr.position.set(cx, getTerrainHeight(cx, cz) + 0.02, cz);
            scene.add(cr);
        }

        // --- Lighting ---
        const ambient  = new THREE.AmbientLight(0x404040, 1.5);
        scene.add(ambient);
        const dirLight = new THREE.DirectionalLight(0xffddbb, 0.8);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // ================================================================
        // SECTION 5: TURRET CLASS & PLACEMENT
        // ================================================================

        class Turret {
            constructor(x, y, z, isEnemy) {
                this.isEnemy = isEnemy;
                this.mesh    = new THREE.Group();
                this.mesh.position.set(x, y, z);

                // Ammo state
                this.ammo       = 5;
                this.maxAmmo    = 5;
                this.isReloading = false;
                this.reloadTimer = 0;

                // --- Geometry ---
                const base = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 0.6, 8), wallMat);
                base.position.y = -0.3;
                this.mesh.add(base);

                this.swivel = new THREE.Group();
                this.swivel.position.y = 0.1;
                this.baseYaw = isEnemy ? 0 : Math.PI;
                this.swivel.rotation.y = this.baseYaw;
                this.mesh.add(this.swivel);

                this.pitchGroup = new THREE.Group();
                this.swivel.add(this.pitchGroup);

                const receiver = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, 0.2, 0.5),
                    new THREE.MeshLambertMaterial({ color: 0x1a1a1a })
                );
                this.pitchGroup.add(receiver);

                const waterJacket = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.08, 0.08, 0.8, 12),
                    new THREE.MeshLambertMaterial({ color: 0x2a2a2a })
                );
                waterJacket.rotation.x = Math.PI / 2;
                waterJacket.position.set(0, 0, -0.65);
                this.pitchGroup.add(waterJacket);

                const barrel = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.025, 0.03, 0.2, 8),
                    new THREE.MeshLambertMaterial({ color: 0x111111 })
                );
                barrel.rotation.x = Math.PI / 2;
                barrel.position.z = -1.15;
                this.pitchGroup.add(barrel);

                const gripBar = new THREE.Mesh(
                    new THREE.BoxGeometry(0.18, 0.02, 0.02),
                    new THREE.MeshLambertMaterial({ color: 0x111111 })
                );
                gripBar.position.set(0, 0, 0.26);

                const lGrip = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.015, 0.015, 0.1),
                    new THREE.MeshLambertMaterial({ color: 0x3a2e15 })
                );
                lGrip.rotation.x = Math.PI / 2;
                lGrip.position.set(-0.09, 0, 0.3);

                const rGrip = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.015, 0.015, 0.1),
                    new THREE.MeshLambertMaterial({ color: 0x3a2e15 })
                );
                rGrip.rotation.x = Math.PI / 2;
                rGrip.position.set(0.09, 0, 0.3);

                const triggerThumb = new THREE.Mesh(
                    new THREE.BoxGeometry(0.04, 0.02, 0.02),
                    new THREE.MeshLambertMaterial({ color: 0x555555 })
                );
                triggerThumb.position.set(0, 0, 0.28);
                this.pitchGroup.add(gripBar, lGrip, rGrip, triggerThumb);

                const ammoBox = new THREE.Mesh(
                    new THREE.BoxGeometry(0.15, 0.2, 0.25),
                    new THREE.MeshLambertMaterial({ color: 0x3a4530 })
                );
                ammoBox.position.set(-0.18, -0.05, 0);
                this.pitchGroup.add(ammoBox);

                for (let b = 0; b < 4; b++) {
                    let bullet = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.008, 0.008, 0.04, 6),
                        new THREE.MeshLambertMaterial({ color: 0xccaa44 })
                    );
                    bullet.rotation.z = Math.PI / 2;
                    bullet.position.set(-0.12 + (b * 0.02), 0.05, 0);
                    this.pitchGroup.add(bullet);
                }

                const shieldL = new THREE.Mesh(
                    new THREE.BoxGeometry(0.35, 0.5, 0.05),
                    new THREE.MeshLambertMaterial({ color: 0x3a4530 })
                );
                shieldL.position.set(-0.25, -0.15, -0.2);

                const shieldR = new THREE.Mesh(
                    new THREE.BoxGeometry(0.35, 0.5, 0.05),
                    new THREE.MeshLambertMaterial({ color: 0x3a4530 })
                );
                shieldR.position.set(0.25, -0.15, -0.2);

                const shieldB = new THREE.Mesh(
                    new THREE.BoxGeometry(0.15, 0.2, 0.05),
                    new THREE.MeshLambertMaterial({ color: 0x3a4530 })
                );
                shieldB.position.set(0, -0.3, -0.2);
                this.pitchGroup.add(shieldL, shieldR, shieldB);

                const tRSightBase = new THREE.Mesh(
                    new THREE.BoxGeometry(0.12, 0.02, 0.04),
                    new THREE.MeshLambertMaterial({ color: 0x111111 })
                );
                tRSightBase.position.set(0, 0.11, 0.15);

                const tRSightL = new THREE.Mesh(
                    new THREE.BoxGeometry(0.02, 0.04, 0.04),
                    new THREE.MeshLambertMaterial({ color: 0x111111 })
                );
                tRSightL.position.set(-0.04, 0.14, 0.15);

                const tRSightR = new THREE.Mesh(
                    new THREE.BoxGeometry(0.02, 0.04, 0.04),
                    new THREE.MeshLambertMaterial({ color: 0x111111 })
                );
                tRSightR.position.set(0.04, 0.14, 0.15);

                const tFSight = new THREE.Mesh(
                    new THREE.BoxGeometry(0.01, 0.08, 0.02),
                    new THREE.MeshLambertMaterial({ color: 0x111111 })
                );
                tFSight.position.set(0, 0.12, -1.0);
                this.pitchGroup.add(tRSightBase, tRSightL, tRSightR, tFSight);

                this.dummyShell = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.015, 0.015, 0.1, 8),
                    new THREE.MeshLambertMaterial({ color: 0xccaa44 })
                );
                this.dummyShell.rotation.x = Math.PI / 2;
                this.dummyShell.visible = false;
                this.pitchGroup.add(this.dummyShell);

                scene.add(this.mesh);
                worldMeshes.push(base, shieldL, shieldR, shieldB, receiver, waterJacket, ammoBox);
                collisionObstacles.push({ minX: x - 0.5, maxX: x + 0.5, minZ: z - 0.5, maxZ: z + 0.5 });
                turrets.push(this);

                this.user     = null;
                this.lastShot = 0;

                const zOffset = this.isEnemy ? 1.0 : -1.0;
                this.coverPos = { x: this.mesh.position.x, z: this.mesh.position.z + zOffset, isTurret: true, turret: this };
                if (this.isEnemy) enemyCoversBack.push(this.coverPos);
                else              allyCoversBack.push(this.coverPos);
            }
        }

        function buildElevatedWallAndCovers(zPos, isEnemy) {
            const leftBlock  = 1;
            const rightBlock = 3;
            const turretBlocks = [leftBlock, rightBlock];
            const turretCounts = {};
            turretBlocks.forEach(b => {
                const possibleCounts = [1, 3, 5, 7];
                turretCounts[b] = possibleCounts[Math.floor(Math.random() * possibleCounts.length)];
            });

            for (let i = 0; i < blockCenters.length; i++) {
                const cx = blockCenters[i];
                const w  = blockWidths[i];
                createWall(cx, zPos, w, 0.8, 1.4);
                let startX = cx - w/2 + 2;
                let endX   = cx + w/2 - 2;
                let count  = 0;
                for (let x = startX; x <= endX; x += 4) {
                    if (count % 2 === 0) {
                        createWall(x, zPos, 3.5, 1.8, 1.9);
                    } else {
                        const targetZ = isEnemy ? zPos + 1.2 : zPos - 1.2;
                        if (turretCounts[i] === count) {
                            new Turret(x, 2.0, zPos, isEnemy);
                        } else {
                            if (isEnemy) enemyCoversBack.push({ x: x, z: targetZ, y: 1.0 });
                            else         allyCoversBack.push({ x: x, z: targetZ, y: 1.0 });
                        }
                    }
                    count++;
                }
            }
        }

        buildElevatedWallAndCovers(-26.25, false);
        buildElevatedWallAndCovers( 26.25, true);

        // Scattered front-line cover
        for (let x = -96; x <= 96; x += 4 + Math.random() * 3) {
            if (Math.abs(x + 60) < 5 || Math.abs(x + 20) < 5 || Math.abs(x - 20) < 5 || Math.abs(x - 60) < 5) continue;
            if (Math.abs(x + 40) < 4 || Math.abs(x - 40) < 4) continue;
            let oxA = x + (Math.random() - 0.5) * 2;
            addCover(oxA, -18.5 + (Math.random() - 0.5), allyCoversFront, -1.2);
            let oxE = x + (Math.random() - 0.5) * 2;
            addCover(oxE,  18.5 + (Math.random() - 0.5), enemyCoversFront, 1.2);
        }

        // ================================================================
        // SECTION 6: ATMOSPHERIC VISUALS
        // ================================================================

        // --- Ash particle system ---
        const ashGeo   = new THREE.BufferGeometry();
        const ashCount = 1000;
        const ashPos   = new Float32Array(ashCount * 3);
        for (let i = 0; i < ashCount * 3; i += 3) {
            ashPos[i]   = (Math.random() - 0.5) * 200;
            ashPos[i+1] = Math.random() * 10;
            ashPos[i+2] = (Math.random() - 0.5) * 100;
        }
        ashGeo.setAttribute('position', new THREE.BufferAttribute(ashPos, 3));
        const ashMat       = new THREE.PointsMaterial({ color: 0x666666, size: 0.15, transparent: true, opacity: 0.5 });
        const ashParticles = new THREE.Points(ashGeo, ashMat);
        scene.add(ashParticles);

        // --- Distant artillery flash lights ---
        const horizonLights = [];
        for (let i = 0; i < 6; i++) {
            let l = new THREE.PointLight(0xffaa55, 0, 150);
            l.position.set(
                (Math.random() - 0.5) * 180,
                5,
                (i % 2 === 0 ? 1 : -1) * (40 + Math.random() * 20)
            );
            scene.add(l);
            horizonLights.push({ light: l, timer: 0 });
        }


        // ================================================================
        // SECTION 7: PLAYER SETUP
        // ================================================================

        const playerRoot   = new THREE.Group();
        playerRoot.position.set(0, getTerrainHeight(0, -20), -20);
        scene.add(playerRoot);

        const leanObject = new THREE.Group();
        leanObject.position.y = 1.5;
        playerRoot.add(leanObject);

        const pitchObject = new THREE.Group();
        leanObject.add(pitchObject);
        pitchObject.add(camera);

        // Player entity (used by AI targeting and damage system)
        const playerAI = {
            isPlayer: true,
            hp: 10,
            dead: false,
            takeDamage: function(amt, attacker) {
                if (this.dead) return;
                playNearMissSound();
                triggerShellShock(1.0);
                playerHp -= amt;
                document.getElementById('healthbar').style.width = (playerHp * 10) + '%';
                document.getElementById('hurt-overlay').style.opacity = 0.5;
                if (playerHp <= 0) {
                    this.dead = true;
                    if (mountedTurret) {
                        mountedTurret.user = null;
                        mountedTurret = null;
                        weaponContainer.visible = true;
                    }
                    document.getElementById('hurt-overlay').style.background = 'black';
                    document.getElementById('hurt-overlay').style.opacity = 1.0;
                    setTimeout(() => {
                        if (document.pointerLockElement) document.exitPointerLock();
                    }, 2000);
                }
            }
        };
        playerAI.mesh = new THREE.Mesh(
            new THREE.BoxGeometry(0.8, 1.8, 0.8),
            new THREE.MeshBasicMaterial({ visible: false })
        );
        playerAI.mesh.userData.ai = playerAI;
        playerAI.mesh.position.y  = 0.9;
        playerRoot.add(playerAI.mesh);

        // ================================================================
        // SECTION 8: WEAPON SYSTEM
        // ================================================================

        const weaponContainer = new THREE.Group();
        camera.add(weaponContainer);
        weaponContainer.position.set(0.2, -0.2, -0.4);

        // --- Weapon data definitions ---
        const weaponsData = [
            { id: 'rifle',  name: '1: Rifle',        type: 'semi', fireRate: 250,  recoilPitch: 0.0066, recoilZ: 0.033, barrelLen: -0.8, soundPitch: 1.0, alignY: -0.06 },
            { id: 'mg',     name: '2: Machine Gun',  type: 'auto', fireRate: 100,  recoilPitch: 0.012,  recoilZ: 0.05,  barrelLen: -0.9, soundPitch: 1.1, alignY: -0.08 },
            { id: 'sniper', name: '3: Sniper Rifle', type: 'semi', fireRate: 1500, recoilPitch: 0.0198, recoilZ: 0.1,   barrelLen: -1.2, soundPitch: 0.7, alignY:  0    },
        ];

        let currentWeaponIndex       = 0;
        let sniperZoomLevel          = SNIPER_ZOOM_DEFAULT;
        let snBoltGroup;
        let sniperNeedsRechamber     = false;
        let sniperRechamberStartTime = 0;

        // --- Rifle model ---
        const modelRifle   = new THREE.Group();
        const rBarrel      = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.015, 0.9, 8), new THREE.MeshLambertMaterial({ color: 0x222222 }));
        rBarrel.rotation.x = Math.PI / 2;
        rBarrel.position.set(0, 0, -0.45);
        const rReceiver    = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.06, 0.25), new THREE.MeshLambertMaterial({ color: 0x1a1a1a }));
        rReceiver.position.set(0, 0.01, -0.15);
        const rStock       = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.12, 0.4), new THREE.MeshLambertMaterial({ color: 0x4a2e15 }));
        rStock.position.set(0, -0.03, 0.1);
        const rHandguard   = new THREE.Mesh(new THREE.BoxGeometry(0.045, 0.04, 0.5), new THREE.MeshLambertMaterial({ color: 0x4a2e15 }));
        rHandguard.position.set(0, -0.01, -0.4);
        const rTriggerGuard = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.04, 0.08), new THREE.MeshLambertMaterial({ color: 0x111111 }));
        rTriggerGuard.position.set(0, -0.06, -0.05);
        const rBoltHandle  = new THREE.Mesh(new THREE.CylinderGeometry(0.005, 0.005, 0.04), new THREE.MeshLambertMaterial({ color: 0x333333 }));
        rBoltHandle.rotation.z = Math.PI / 2;
        rBoltHandle.position.set(0.025, 0.02, -0.1);
        const rFSight      = new THREE.Mesh(new THREE.BoxGeometry(0.005, 0.04, 0.01), new THREE.MeshLambertMaterial({ color: 0x111111 }));
        rFSight.position.set(0, 0.04, -0.85);
        const rRSightBase  = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.02, 0.04), new THREE.MeshLambertMaterial({ color: 0x111111 }));
        rRSightBase.position.set(0, 0.03, -0.25);
        const rRSightL     = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.02, 0.02), new THREE.MeshLambertMaterial({ color: 0x111111 }));
        rRSightL.position.set(-0.015, 0.05, -0.25);
        const rRSightR     = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.02, 0.02), new THREE.MeshLambertMaterial({ color: 0x111111 }));
        rRSightR.position.set(0.015, 0.05, -0.25);
        modelRifle.add(rBarrel, rReceiver, rStock, rHandguard, rTriggerGuard, rBoltHandle, rFSight, rRSightBase, rRSightL, rRSightR);

        // --- Machine gun model ---
        const modelMG  = new THREE.Group();
        const mgBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.018, 0.02, 0.9, 8), new THREE.MeshLambertMaterial({ color: 0x1a1a1a }));
        mgBarrel.rotation.x = Math.PI / 2;
        mgBarrel.position.set(0, 0, -0.45);
        const mgReceiver = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.08, 0.35), new THREE.MeshLambertMaterial({ color: 0x111111 }));
        mgReceiver.position.set(0, 0.01, -0.1);
        const mgMag    = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.12, 0.1), new THREE.MeshLambertMaterial({ color: 0x2a3a2a }));
        mgMag.position.set(-0.04, -0.05, -0.1);
        const mgStock  = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.1, 0.3), new THREE.MeshLambertMaterial({ color: 0x3a2e15 }));
        mgStock.position.set(0, -0.02, 0.15);
        const mgBipod  = new THREE.Mesh(new THREE.CylinderGeometry(0.005, 0.005, 0.15), new THREE.MeshLambertMaterial({ color: 0x111111 }));
        mgBipod.position.set(0, -0.05, -0.8);
        mgBipod.rotation.x = Math.PI / 4;
        const mgFSight = new THREE.Mesh(new THREE.BoxGeometry(0.005, 0.062, 0.01), new THREE.MeshLambertMaterial({ color: 0x111111 }));
        mgFSight.position.set(0, 0.049, -0.85);
        modelMG.add(mgBarrel, mgReceiver, mgMag, mgStock, mgBipod, mgFSight);

        // --- Sniper rifle model ---
        const modelSniper  = new THREE.Group();
        const snBarrel     = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.015, 1.2, 8), new THREE.MeshLambertMaterial({ color: 0x222222 }));
        snBarrel.rotation.x = Math.PI / 2;
        snBarrel.position.set(0, 0, -0.6);
        const snReceiver   = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.05, 0.3), new THREE.MeshLambertMaterial({ color: 0x1a1a1a }));
        snReceiver.position.set(0, 0, -0.15);
        const snStock      = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.1, 0.5), new THREE.MeshLambertMaterial({ color: 0x4a2e15 }));
        snStock.position.set(0, -0.03, 0.15);
        const snHandguard  = new THREE.Mesh(new THREE.BoxGeometry(0.035, 0.04, 0.6), new THREE.MeshLambertMaterial({ color: 0x4a2e15 }));
        snHandguard.position.set(0, -0.01, -0.45);
        const snTriggerGuard = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.03, 0.06), new THREE.MeshLambertMaterial({ color: 0x111111 }));
        snTriggerGuard.position.set(0, -0.05, -0.05);
        const snScopeTube  = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.35, 12), new THREE.MeshLambertMaterial({ color: 0x111111 }));
        snScopeTube.rotation.x = Math.PI / 2;
        snScopeTube.position.set(0, 0.06, -0.15);
        const snScopeObj   = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.025, 0.08, 12), new THREE.MeshLambertMaterial({ color: 0x111111 }));
        snScopeObj.rotation.x = Math.PI / 2;
        snScopeObj.position.set(0, 0.06, -0.32);
        const snScopeEye   = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.06, 12), new THREE.MeshLambertMaterial({ color: 0x111111 }));
        snScopeEye.rotation.x = Math.PI / 2;
        snScopeEye.position.set(0, 0.06, 0.02);
        const snScopeKnobT = new THREE.Mesh(new THREE.CylinderGeometry(0.008, 0.008, 0.02, 8), new THREE.MeshLambertMaterial({ color: 0x222222 }));
        snScopeKnobT.position.set(0, 0.08, -0.15);
        const snScopeKnobR = new THREE.Mesh(new THREE.CylinderGeometry(0.008, 0.008, 0.02, 8), new THREE.MeshLambertMaterial({ color: 0x222222 }));
        snScopeKnobR.rotation.z = Math.PI / 2;
        snScopeKnobR.position.set(0.02, 0.06, -0.15);
        const snScopeMount1 = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.04, 0.01), new THREE.MeshLambertMaterial({ color: 0x111111 }));
        snScopeMount1.position.set(0, 0.04, -0.05);
        const snScopeMount2 = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.04, 0.01), new THREE.MeshLambertMaterial({ color: 0x111111 }));
        snScopeMount2.position.set(0, 0.04, -0.25);

        // Bolt action assembly
        snBoltGroup = new THREE.Group();
        snBoltGroup.position.set(0, 0.015, -0.05);
        const snBoltBody   = new THREE.Mesh(new THREE.CylinderGeometry(0.008, 0.008, 0.18, 8), new THREE.MeshLambertMaterial({ color: 0x555555 }));
        snBoltBody.rotation.x = Math.PI / 2;
        const snBoltHandle = new THREE.Mesh(new THREE.CylinderGeometry(0.003, 0.003, 0.06), new THREE.MeshLambertMaterial({ color: 0x333333 }));
        snBoltHandle.rotation.z = Math.PI / 2;
        snBoltHandle.position.set(0.03, 0, 0.07);
        const snBoltKnob   = new THREE.Mesh(new THREE.SphereGeometry(0.008, 8, 8), new THREE.MeshLambertMaterial({ color: 0x111111 }));
        snBoltKnob.position.set(0.06, 0, 0.07);
        snBoltGroup.add(snBoltBody, snBoltHandle, snBoltKnob);

        modelSniper.add(
            snBarrel, snReceiver, snStock, snHandguard, snTriggerGuard,
            snScopeTube, snScopeObj, snScopeEye, snScopeKnobT, snScopeKnobR,
            snScopeMount1, snScopeMount2, snBoltGroup
        );

        weaponContainer.add(modelRifle, modelMG, modelSniper);
        modelMG.visible     = false;
        modelSniper.visible = false;

        function switchWeapon(index) {
            if (index === currentWeaponIndex) return;
            currentWeaponIndex  = index;
            modelRifle.visible  = (index === 0);
            modelMG.visible     = (index === 1);
            modelSniper.visible = (index === 2);
            document.getElementById('weapon-indicator').innerText = weaponsData[index].name;
            fpFlashGroup.position.z  = weaponsData[index].barrelLen - 0.05;
            fpFlashLight.position.z  = weaponsData[index].barrelLen - 0.05;
            if (index === 2 && sniperNeedsRechamber) {
                sniperRechamberStartTime = performance.now();
            }
        }

        // --- Procedural muzzle flash texture ---
        const flashTexCanvas  = document.createElement('canvas');
        flashTexCanvas.width  = 16;
        flashTexCanvas.height = 16;
        const fctx = flashTexCanvas.getContext('2d');
        fctx.fillStyle = "rgba(200, 50, 0, 0.5)";
        fctx.fillRect(6, 2, 4, 12);
        fctx.fillRect(2, 6, 12, 4);
        fctx.fillStyle = "rgba(255, 120, 0, 0.8)";
        fctx.fillRect(7, 3, 2, 10);
        fctx.fillRect(3, 7, 10, 2);
        fctx.fillRect(5, 5, 6, 6);
        fctx.fillStyle = "rgba(255, 220, 100, 1)";
        fctx.fillRect(6, 6, 4, 4);
        fctx.fillStyle = "rgba(255, 255, 255, 1)";
        fctx.fillRect(7, 7, 2, 2);
        const flashTexture = new THREE.CanvasTexture(flashTexCanvas);
        flashTexture.magFilter = THREE.NearestFilter;
        flashTexture.minFilter = THREE.NearestFilter;

        // First-person muzzle flash
        const fpFlashMaterial = new THREE.MeshBasicMaterial({
            map: flashTexture, transparent: true, opacity: 0,
            depthWrite: false, blending: THREE.AdditiveBlending
        });
        const fpFlashGroup = new THREE.Group();
        fpFlashGroup.add(
            new THREE.Mesh(new THREE.PlaneGeometry(0.3, 0.3), fpFlashMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(0.3, 0.3), fpFlashMaterial)
        );
        fpFlashGroup.children[0].rotation.z =  Math.PI / 4;
        fpFlashGroup.children[1].rotation.z = -Math.PI / 4;
        fpFlashGroup.position.set(0, 0, -0.85);
        const fpFlashLight = new THREE.PointLight(0xffddaa, 0, 5);
        fpFlashLight.position.set(0, 0, -0.85);
        weaponContainer.add(fpFlashGroup, fpFlashLight);

        // ================================================================
        // SECTION 9: VISUAL EFFECTS POOLS
        // ================================================================

        // --- World muzzle flashes ---
        const flashes = [];
        for (let i = 0; i < 20; i++) {
            const f = new THREE.Mesh(
                new THREE.PlaneGeometry(0.5, 0.5),
                new THREE.MeshBasicMaterial({ map: flashTexture, transparent: true, opacity: 0, depthWrite: false, blending: THREE.AdditiveBlending, side: THREE.DoubleSide })
            );
            scene.add(f);
            flashes.push({ mesh: f, life: 0 });
        }

        function showMuzzleFlash(pos, dir) {
            const f = flashes.find(fl => fl.life <= 0);
            if (f) {
                f.life = 0.05;
                f.mesh.position.copy(pos).add(dir.clone().multiplyScalar(0.4));
                f.mesh.lookAt(f.mesh.position.clone().add(dir));
                f.mesh.rotateZ(Math.random() * Math.PI * 2);
                const sx = (Math.random() > 0.5 ? 1 : -1) * (0.7 + Math.random() * 0.6);
                const sy = (Math.random() > 0.5 ? 1 : -1) * (0.7 + Math.random() * 0.6);
                f.mesh.scale.set(sx, sy, 1);
                f.mesh.material.opacity = 1;
            }
        }

        // --- Explosion pool ---
        const explosions = [];
        const expGeo     = new THREE.SphereGeometry(1, 16, 16);
        const expMat     = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 1, depthWrite: false, blending: THREE.AdditiveBlending });
        for (let i = 0; i < 15; i++) {
            const m = new THREE.Mesh(expGeo, expMat.clone());
            m.visible = false;
            const l = new THREE.PointLight(0xff6600, 0, 40);
            scene.add(m);
            scene.add(l);
            explosions.push({ mesh: m, light: l, life: 0, maxLife: 0.5 });
        }

        function createExplosion(pos) {
            const exp = explosions.find(e => e.life <= 0);
            if (exp) {
                exp.life = exp.maxLife;
                exp.mesh.position.copy(pos);
                exp.light.position.copy(pos);
                exp.visible = true;
                exp.mesh.visible = true;
                exp.mesh.material.opacity = 1;
                exp.light.intensity = 20.0;
            }
        }

        // --- Bullet impact pool ---
        const impacts   = [];
        const impactGeo = new THREE.PlaneGeometry(0.3, 0.3);
        const impactMat = new THREE.MeshBasicMaterial({ color: 0x887755, transparent: true, opacity: 1, depthWrite: false });
        for (let i = 0; i < 40; i++) {
            const m = new THREE.Mesh(impactGeo, impactMat.clone());
            m.visible = false;
            scene.add(m);
            impacts.push({ mesh: m, life: 0 });
        }

        function createImpact(pos, normal) {
            const imp = impacts.find(i => i.life <= 0);
            if (imp) {
                imp.life = 0.2;
                imp.mesh.position.copy(pos).add(normal.clone().multiplyScalar(0.02));
                imp.mesh.lookAt(pos.clone().add(normal));
                imp.mesh.scale.set(0.1, 0.1, 0.1);
                imp.mesh.material.opacity = 1;
                imp.mesh.visible = true;
            }
        }

        // --- Tracer pool ---
        const tracers   = [];
        const tracerGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -8)]);
        for (let i = 0; i < 100; i++) {
            const t = new THREE.Line(tracerGeo, new THREE.LineBasicMaterial({ color: 0xffcc88 }));
            t.visible = false;
            scene.add(t);
            tracers.push({ mesh: t, life: 0, dir: new THREE.Vector3(), traveled: 0, maxDist: 200 });
        }

        function createTracer(start, dir, maxDist = 200) {
            const t = tracers.find(tr => tr.life <= 0);
            if (t) {
                t.life = 0.8;
                t.mesh.position.copy(start);
                t.dir.copy(dir);
                t.mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, -1), dir);
                t.mesh.visible = true;
                t.traveled = 0;
                t.maxDist   = maxDist;
            }
        }

        // ================================================================
        // SECTION 10: INPUT & CONTROLS
        // ================================================================

        // --- Input state ---
        const keys = {
            w: false, a: false, s: false, d: false,
            shift: false, z: false, c: false,
            q: false, e: false, space: false,
            lmb: false, rmb: false
        };

        // --- Player state ---
        let lastQPress   = 0;
        let lastEPress   = 0;
        let qToggled     = false;
        let eToggled     = false;
        let lmbJustPressed = false;
        let isCrouched   = false;
        let isProne      = false;
        let slideTimer   = 0;
        let slideSpeed   = 0;
        let slideDir     = new THREE.Vector3();
        let yaw          = 0;
        let pitch        = 0;
        let playerHp     = PLAYER_HP_MAX;
        let initialized  = false;
        let mgHeat       = 0;
        let mgOverheated = false;
        let gameMode     = 'endless';
        let rollAngle    = 0;
        let activeRollDir = 0;
        let rollCooldown  = 0;
        let playerKills   = 0;
        let allyReserves  = 0;
        let enemyReserves = 0;

        // --- Slider UI listeners ---
        document.getElementById('soldier-count').addEventListener('input', (e) => {
            document.getElementById('soldier-count-display').innerText = e.target.value;
        });
        document.getElementById('active-count').addEventListener('input', (e) => {
            document.getElementById('active-count-display').innerText = e.target.value;
        });

        // --- Mouse move ---
        document.addEventListener('mousemove', (e) => {
            if (!document.pointerLockElement || playerAI.dead) return;
            yaw   -= e.movementX * 0.002;
            pitch -= e.movementY * 0.002;
            pitch  = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));

            if (mountedTurret) {
                let diff = yaw - mountedTurret.baseYaw;
                while (diff < -Math.PI) diff += Math.PI * 2;
                while (diff >  Math.PI) diff -= Math.PI * 2;
                if (diff >  Math.PI / 2) diff =  Math.PI / 2;
                if (diff < -Math.PI / 2) diff = -Math.PI / 2;
                yaw = mountedTurret.baseYaw + diff;
            }

            playerRoot.rotation.y = yaw;
            pitchObject.rotation.x = pitch;
        });

        // --- Key down ---
        document.addEventListener('keydown', e => {
            const code = e.code;
            if (code === 'KeyW') keys.w = true;
            if (code === 'KeyA') keys.a = true;
            if (code === 'KeyS') keys.s = true;
            if (code === 'KeyD') keys.d = true;
            if (code === 'ShiftLeft' || code === 'ShiftRight') keys.shift = true;

            if (code === 'KeyQ') {
                if (!keys.q) {
                    const now = performance.now();
                    if (qToggled) qToggled = false;
                    else if (now - lastQPress < 300) { qToggled = true; lastQPress = 0; }
                    else lastQPress = now;
                }
                keys.q = true;
                eToggled = false;
            }
            if (code === 'KeyE') {
                if (!keys.e) {
                    const now = performance.now();
                    if (eToggled) eToggled = false;
                    else if (now - lastEPress < 300) { eToggled = true; lastEPress = 0; }
                    else lastEPress = now;
                }
                keys.e = true;
                qToggled = false;
            }
            if (code === 'Space') keys.space = true;

            if (code === 'KeyC') {
                if (!keys.c) {
                    let isSprintMoving = (keys.w || keys.a || keys.s || keys.d) && keys.shift && !isProne && !isCrouched && !mountedTurret;
                    if (slideTimer > 0) {
                        slideTimer = 0;
                        isCrouched = false;
                    } else if (isSprintMoving) {
                        isCrouched = true;
                        isProne    = false;
                        qToggled   = false;
                        eToggled   = false;
                        slideTimer = SLIDE_DURATION;
                        slideSpeed = SLIDE_INITIAL_SPEED;
                        let mDir = new THREE.Vector3();
                        if (keys.w) mDir.z -= 1;
                        if (keys.s) mDir.z += 1;
                        if (keys.a) mDir.x -= 1;
                        if (keys.d) mDir.x += 1;
                        if (mDir.lengthSq() > 0) mDir.normalize();
                        mDir.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
                        slideDir.copy(mDir);
                    } else {
                        if (isProne)        { isProne = false; isCrouched = true; }
                        else if (isCrouched) { isCrouched = false; }
                        else                 { isCrouched = !isCrouched; }
                    }
                }
                keys.c = true;
            }

            if (code === 'KeyZ') {
                if (!keys.z) {
                    slideTimer = 0;
                    if (isProne) { isProne = false; isCrouched = true; }
                    else         { isProne = true; isCrouched = false; qToggled = false; eToggled = false; }
                }
                keys.z = true;
            }

            if (code === 'Digit1') switchWeapon(0);
            if (code === 'Digit2') switchWeapon(1);
            if (code === 'Digit3') switchWeapon(2);

            if (code === 'KeyF' && currentWeaponIndex === 2 && (keys.rmb || keys.space)) {
                sniperZoomLevel = Math.min(SNIPER_ZOOM_MAX, sniperZoomLevel + 1);
            }
            if (code === 'KeyG' && currentWeaponIndex === 2 && (keys.rmb || keys.space)) {
                sniperZoomLevel = Math.max(SNIPER_ZOOM_MIN, sniperZoomLevel - 1);
            }

            if (code === 'KeyR') {
                if (mountedTurret && !mountedTurret.isReloading && mountedTurret.ammo < mountedTurret.maxAmmo) {
                    mountedTurret.isReloading = true;
                    mountedTurret.reloadTimer = 0.6;
                }
            }

            if (code === 'KeyT' && !playerAI.dead) {
                if (mountedTurret) {
                    mountedTurret.user = null;
                    mountedTurret = null;
                    if (currentWeaponIndex === 2) modelSniper.visible = true;
                    weaponContainer.visible = true;
                } else {
                    let nearest = null;
                    let minDist = TURRET_MOUNT_RANGE;
                    turrets.forEach(t => {
                        const canClaim = !t.user || (t.user && !t.user.isEnemy && t.user !== playerAI);
                        if (canClaim && playerRoot.position.distanceTo(t.mesh.position) < minDist) {
                            nearest = t;
                            minDist = playerRoot.position.distanceTo(t.mesh.position);
                        }
                    });
                    if (nearest) {
                        mountedTurret = nearest;
                        nearest.user  = playerAI;
                        weaponContainer.visible = false;
                        isCrouched  = false;
                        isProne     = false;
                        slideTimer  = 0;
                        yaw   = nearest.swivel.rotation.y;
                        pitch = nearest.pitchGroup.rotation.x;
                    }
                }
            }
        });

        // --- Key up ---
        document.addEventListener('keyup', e => {
            const code = e.code;
            if (code === 'KeyW') keys.w = false;
            if (code === 'KeyA') keys.a = false;
            if (code === 'KeyS') keys.s = false;
            if (code === 'KeyD') keys.d = false;
            if (code === 'ShiftLeft' || code === 'ShiftRight') keys.shift = false;
            if (code === 'KeyQ')    keys.q     = false;
            if (code === 'KeyE')    keys.e     = false;
            if (code === 'Space')   keys.space = false;
            if (code === 'KeyZ')    keys.z     = false;
            if (code === 'KeyC')    keys.c     = false;
        });

        // --- Mouse buttons ---
        document.addEventListener('mousedown', e => {
            if (!document.pointerLockElement) return;
            if (e.button === 2) keys.rmb = true;
            if (e.button === 0) { keys.lmb = true; lmbJustPressed = true; }
        });
        document.addEventListener('mouseup', e => {
            if (e.button === 2) keys.rmb = false;
            if (e.button === 0) keys.lmb = false;
        });
        document.addEventListener('contextmenu', e => e.preventDefault());

        // ================================================================
        // SECTION 11: SHOOTING
        // ================================================================

        const raycaster    = new THREE.Raycaster();
        const lastShotTimes = [0, 0, 0];

        // Returns true if a world-space spot is visible from the player's camera
        function isSpotVisibleToPlayer(spot) {
            const camPos  = camera.getWorldPosition(new THREE.Vector3());
            const spotPos = new THREE.Vector3(spot.x, spot.y + 1.0, spot.z);
            const dir     = spotPos.clone().sub(camPos).normalize();
            const dist    = camPos.distanceTo(spotPos);
            const camForward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
            if (camForward.dot(dir) < 0.2) return false;
            const tempRaycaster = new THREE.Raycaster(camPos, dir);
            const intersects    = tempRaycaster.intersectObjects(worldMeshes, false);
            return !(intersects.length > 0 && intersects[0].distance < dist);
        }

        function shootPlayer() {
            if (playerAI.dead) return;
            if (currentWeaponIndex === 1 && mgOverheated) return;
            const now = performance.now();
            const wep = weaponsData[currentWeaponIndex];

            if (currentWeaponIndex === 2) {
                if (sniperNeedsRechamber) return;
            } else {
                if (now - lastShotTimes[currentWeaponIndex] < wep.fireRate) return;
            }

            lastShotTimes[currentWeaponIndex] = now;

            if (currentWeaponIndex === 1) {
                mgHeat += MG_HEAT_PER_SHOT;
                if (mgHeat >= MG_OVERHEAT_CAP) { mgHeat = MG_OVERHEAT_CAP; mgOverheated = true; }
            }

            if (currentWeaponIndex === 2) {
                sniperNeedsRechamber     = true;
                sniperRechamberStartTime = now;
            }

            playSoundFile('gunshot', wep.soundPitch, wep.id === 'sniper' ? 1.5 : 1.0);

            const barrelPos = new THREE.Vector3(0, 0, wep.barrelLen).applyMatrix4(weaponContainer.matrixWorld);
            const camDir    = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));

            if (wep.type === 'auto') {
                let stanceMult = 1.0;
                if (isProne)        stanceMult = 0.25;
                else if (isCrouched) stanceMult = 0.6;
                if (keys.w || keys.a || keys.s || keys.d) stanceMult *= 1.5;
                let currentSpread = (0.005 + (mgHeat / 100) * 0.05) * stanceMult;
                camDir.x += (Math.random() - 0.5) * currentSpread;
                camDir.y += (Math.random() - 0.5) * currentSpread;
                camDir.normalize();
            }

            fpFlashMaterial.opacity = 1.0;
            fpFlashLight.intensity  = 2.0;
            fpFlashGroup.rotation.z = Math.random() * Math.PI;
            let fsx = (Math.random() > 0.5 ? 1 : -1) * (0.8 + Math.random() * 0.4);
            let fsy = (Math.random() > 0.5 ? 1 : -1) * (0.8 + Math.random() * 0.4);
            fpFlashGroup.scale.set(fsx, fsy, 1);

            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            if (wep.type === 'auto') raycaster.set(camera.getWorldPosition(new THREE.Vector3()), camDir);

            const allAIMeshes = [...enemies.map(e => e.mesh), ...allies.map(a => a.mesh)];
            const intersects  = raycaster.intersectObjects([...worldMeshes, ...allAIMeshes], true);

            let hitDistance = 200;
            if (intersects.length > 0) {
                const hit    = intersects[0];
                hitDistance  = hit.distance;
                const hitObj = hit.object;

                if (hitObj.userData.ai) {
                    const isHead = hitObj.name === "head";
                    hitObj.userData.ai.takeDamage(isHead ? 99 : (1 * (currentWeaponIndex === 2 ? 5 : 1)), playerAI);
                    const marker = document.getElementById('hit-marker');
                    marker.style.opacity     = 1;
                    marker.style.borderColor = isHead ? 'red' : 'white';
                    setTimeout(() => marker.style.opacity = 0, 100);
                    playPositionalSound(hit.point, 'impact');
                } else {
                    let normal = new THREE.Vector3(0, 1, 0);
                    if (hit.face) normal.copy(hit.face.normal).applyMatrix3(new THREE.Matrix3().getNormalMatrix(hitObj.matrixWorld)).normalize();
                    createImpact(hit.point, normal);
                    playPositionalSound(hit.point, 'impact');
                    if (Math.random() < 0.3) {
                        let reflection = camDir.clone().sub(normal.clone().multiplyScalar(2 * camDir.dot(normal))).normalize();
                        reflection.x += (Math.random() - 0.5) * 0.3;
                        reflection.y += Math.random() * 0.4;
                        reflection.z += (Math.random() - 0.5) * 0.3;
                        reflection.normalize();
                        createTracer(hit.point, reflection, 60);
                        if (camera.getWorldPosition(new THREE.Vector3()).distanceToSquared(hit.point) < 64.0) {
                            playSoundFile('whiz', 1.5 + Math.random() * 0.5, 0.2);
                        }
                    }
                }
            }

            if (Math.random() < 0.25) createTracer(barrelPos, camDir, hitDistance);

            const bulletRay  = new THREE.Ray(barrelPos, camDir);
            let closestPt    = new THREE.Vector3();
            [...enemies, ...allies].forEach(e => {
                if (!e.dead) {
                    const ePos = e.mesh.position.clone().add(new THREE.Vector3(0, 1.0, 0));
                    bulletRay.closestPointToPoint(ePos, closestPt);
                    if (barrelPos.distanceTo(closestPt) < hitDistance + 1.0) {
                        if (closestPt.distanceToSquared(ePos) < 16.0) e.alert(playerAI);
                    }
                }
            });

            // Recoil
            let actualRecoil = wep.recoilPitch * (0.8 + Math.random() * 0.4);
            pitch += actualRecoil;
            pitch  = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
            pitchObject.rotation.x = pitch;

            if (wep.type === 'auto') {
                yaw += (Math.random() - 0.5) * actualRecoil * 1.5;
                playerRoot.rotation.y = yaw;
                weaponContainer.rotation.z += (Math.random() - 0.5) * 0.15;
                weaponContainer.rotation.x -= Math.random() * 0.05;
                weaponContainer.rotation.y += (Math.random() - 0.5) * 0.05;
            }

            weaponContainer.position.z += wep.recoilZ;
        }

        function shootTurret(turret, shooter) {
            if (turret.isReloading || turret.ammo <= 0) return;
            const now      = performance.now();
            const cooldown = (shooter && shooter.isPlayer) ? TURRET_PLAYER_FIRE_COOLDOWN : TURRET_AI_FIRE_COOLDOWN;
            if (now - turret.lastShot < cooldown) return;
            turret.lastShot = now;
            turret.ammo--;

            const barrelPos = new THREE.Vector3(0, 0, -1.1).applyMatrix4(turret.pitchGroup.matrixWorld);
            const dir       = new THREE.Vector3(0, 0, -1).applyQuaternion(turret.pitchGroup.getWorldQuaternion(new THREE.Quaternion()));

            let spread = 0.02;
            if (shooter && !shooter.isPlayer) spread = 0.15;
            dir.x += (Math.random() - 0.5) * spread;
            dir.y += (Math.random() - 0.5) * spread;
            dir.z += (Math.random() - 0.5) * spread;
            dir.normalize();

            showMuzzleFlash(barrelPos, dir);
            playPositionalSound(barrelPos, 'gunshot');
            turret.pitchGroup.position.z += 0.3;

            raycaster.set(barrelPos, dir);
            const allAIMeshes = [...enemies.map(e => e.mesh), ...allies.map(a => a.mesh), playerAI.mesh];
            const intersects  = raycaster.intersectObjects([...worldMeshes, ...allAIMeshes], true);

            let hitDistance = 200;
            if (intersects.length > 0) {
                const hit    = intersects[0];
                hitDistance  = hit.distance;
                let normal   = hit.face
                    ? hit.face.normal.clone().applyMatrix3(new THREE.Matrix3().getNormalMatrix(hit.object.matrixWorld)).normalize()
                    : new THREE.Vector3(0, 1, 0);

                createImpact(hit.point, normal);
                for (let i = 0; i < 8; i++) {
                    let debrisOffset = new THREE.Vector3(
                        (Math.random()-0.5)*5, Math.random()*4, (Math.random()-0.5)*5
                    );
                    createImpact(hit.point.clone().add(debrisOffset), normal);
                }

                createExplosion(hit.point);
                playPositionalSound(hit.point, 'artillery');

                const distToPlayer = camera.getWorldPosition(new THREE.Vector3()).distanceTo(hit.point);
                if (distToPlayer < 50) {
                    const shakeAmt = 1.0 - (distToPlayer / 50);
                    currentScreenShake = Math.max(currentScreenShake, shakeAmt * 0.6);
                }

                // AoE damage
                const hitPool = [...allies, ...enemies, playerAI];
                hitPool.forEach(t => {
                    if (!t.dead) {
                        const posOffset = t.isPlayer
                            ? ((isProne || slideTimer > 0) ? 0.15 : (isCrouched ? 0.4 : 1.0))
                            : (1.0 - (t.crouchT * 0.45));
                        const pos = t.isPlayer ? playerRoot.position.clone() : t.mesh.position.clone();
                        pos.y += posOffset;
                        if (pos.distanceTo(hit.point) < TURRET_EXPLOSION_RADIUS) {
                            t.takeDamage(TURRET_EXPLOSION_DAMAGE, shooter);
                        }
                    }
                });

                if (camera.getWorldPosition(new THREE.Vector3()).distanceTo(hit.point) < 8.0) {
                    triggerShellShock(1.5);
                }
            }

            createTracer(barrelPos, dir, hitDistance);

            // Whiz / suppression check
            const bulletRay = new THREE.Ray(barrelPos, dir);
            const hitPool   = [...allies, ...enemies, playerAI];
            let closestPt   = new THREE.Vector3();
            hitPool.forEach(t => {
                if (!t.dead) {
                    const posOffset = t.isPlayer
                        ? ((isProne || slideTimer > 0) ? 0.15 : (isCrouched ? 0.4 : 1.0))
                        : (1.0 - (t.crouchT * 0.45));
                    const pos = t.isPlayer ? playerRoot.position.clone() : t.mesh.position.clone();
                    pos.y += posOffset;
                    bulletRay.closestPointToPoint(pos, closestPt);
                    const distAlongRay = barrelPos.distanceTo(closestPt);
                    if (distAlongRay < hitDistance + 1.0) {
                        const distSq = closestPt.distanceToSquared(pos);
                        if (!t.isPlayer) {
                            if (distSq < 16.0) t.alert(shooter);
                        } else {
                            if (distSq < 2.0) playNearMissSound();
                        }
                    }
                }
            });
        }


        // ================================================================
        // SECTION 12: AI SYSTEM
        // ================================================================

        // --- AI materials ---
        const allyMat        = new THREE.MeshLambertMaterial({ color: 0x3b5030 });
        const enemyMat       = new THREE.MeshLambertMaterial({ color: 0x5a3030 });
        const skinMat        = new THREE.MeshLambertMaterial({ color: 0xdcb897 });
        const helmetMatEnemy = new THREE.MeshLambertMaterial({ color: 0x3a2a2a });
        const helmetMatAlly  = new THREE.MeshLambertMaterial({ color: 0x3a4a30 });

        class AI {
            constructor(isEnemy) {
                this.isEnemy = isEnemy;
                this.mesh    = new THREE.Group();

                const uniformMat = isEnemy ? enemyMat : allyMat;
                const helmetMat  = isEnemy ? helmetMatEnemy : helmetMatAlly;

                this.bodyRoot = new THREE.Group();
                this.mesh.add(this.bodyRoot);

                this.torso = new THREE.Group();
                this.torso.position.y = 0.3;
                this.bodyRoot.add(this.torso);

                const torsoMesh = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.6, 0.25), uniformMat);
                torsoMesh.userData.ai = this;
                this.torso.add(torsoMesh);

                this.headGroup = new THREE.Group();
                this.headGroup.position.y = 0.35;
                this.torso.add(this.headGroup);

                const head    = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.25, 0.2), skinMat);
                head.position.y = 0.125;
                head.name = "head";
                head.userData.ai = this;

                const helmet  = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.15, 0.25), helmetMat);
                helmet.position.y = 0.3;
                helmet.name = "head";
                helmet.userData.ai = this;

                const eyeMat  = new THREE.MeshLambertMaterial({ color: 0x111111 });
                const lEye    = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.04, 0.02), eyeMat);
                lEye.position.set(-0.04, 0.16, 0.101);
                lEye.name = "head";
                lEye.userData.ai = this;

                const rEye    = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.04, 0.02), eyeMat);
                rEye.position.set(0.04, 0.16, 0.101);
                rEye.name = "head";
                rEye.userData.ai = this;

                const mustache = new THREE.Mesh(
                    new THREE.BoxGeometry(0.12, 0.03, 0.04),
                    new THREE.MeshLambertMaterial({ color: 0x221100 })
                );
                mustache.position.set(0, 0.10, 0.115);
                mustache.name = "head";
                mustache.userData.ai = this;

                const mouth   = new THREE.Mesh(
                    new THREE.BoxGeometry(0.06, 0.02, 0.02),
                    new THREE.MeshLambertMaterial({ color: 0x3a0505 })
                );
                mouth.position.set(0, 0.06, 0.101);
                mouth.name = "head";
                mouth.userData.ai = this;

                this.headGroup.add(head, helmet, lEye, rEye, mustache, mouth);

                // Left arm
                this.leftArm = new THREE.Group();
                this.leftArm.position.set(-0.25, 0.2, 0);
                this.torso.add(this.leftArm);
                const lUArmMesh = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.28, 0.12), uniformMat);
                lUArmMesh.position.y = -0.14;
                lUArmMesh.userData.ai = this;
                this.leftArm.add(lUArmMesh);
                this.leftForearm = new THREE.Group();
                this.leftForearm.position.set(0, -0.28, 0);
                this.leftArm.add(this.leftForearm);
                const lLArmMesh = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.25, 0.1), uniformMat);
                lLArmMesh.position.y = -0.125;
                lLArmMesh.userData.ai = this;
                this.leftForearm.add(lLArmMesh);
                const lHand = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, 0.08), skinMat);
                lHand.position.set(0, -0.3, 0);
                this.leftForearm.add(lHand);

                // Right arm
                this.rightArm = new THREE.Group();
                this.rightArm.position.set(0.25, 0.2, 0);
                this.torso.add(this.rightArm);
                const rUArmMesh = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.28, 0.12), uniformMat);
                rUArmMesh.position.y = -0.14;
                rUArmMesh.userData.ai = this;
                this.rightArm.add(rUArmMesh);
                this.rightForearm = new THREE.Group();
                this.rightForearm.position.set(0, -0.28, 0);
                this.rightArm.add(this.rightForearm);
                const rLArmMesh = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.25, 0.1), uniformMat);
                rLArmMesh.position.y = -0.125;
                rLArmMesh.userData.ai = this;
                this.rightForearm.add(rLArmMesh);
                const rHand = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, 0.08), skinMat);
                rHand.position.set(0, -0.3, 0);
                this.rightForearm.add(rHand);

                // Weapon
                this.weaponGroup = new THREE.Group();
                const aiBarrel   = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.015, 0.9, 8), new THREE.MeshLambertMaterial({ color: 0x222222 }));
                aiBarrel.rotation.x = Math.PI / 2;
                aiBarrel.position.set(0, 0, 0.45);
                const aiReceiver = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.06, 0.25), new THREE.MeshLambertMaterial({ color: 0x1a1a1a }));
                aiReceiver.position.set(0, 0.01, 0.15);
                const aiStock    = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.12, 0.4), new THREE.MeshLambertMaterial({ color: 0x4a2e15 }));
                aiStock.position.set(0, -0.03, -0.1);
                const aiHandguard = new THREE.Mesh(new THREE.BoxGeometry(0.045, 0.04, 0.5), new THREE.MeshLambertMaterial({ color: 0x4a2e15 }));
                aiHandguard.position.set(0, -0.01, 0.4);
                const aiBolt     = new THREE.Mesh(new THREE.CylinderGeometry(0.005, 0.005, 0.04), new THREE.MeshLambertMaterial({ color: 0x333333 }));
                aiBolt.rotation.z = Math.PI / 2;
                aiBolt.position.set(0.025, 0.02, 0.1);
                this.weaponGroup.add(aiBarrel, aiReceiver, aiStock, aiHandguard, aiBolt);
                this.torso.add(this.weaponGroup);

                // Left leg
                this.leftLeg = new THREE.Group();
                this.leftLeg.position.set(-0.12, 0, 0);
                this.bodyRoot.add(this.leftLeg);
                const lThighMesh = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.4, 0.15), uniformMat);
                lThighMesh.position.y = -0.2;
                lThighMesh.userData.ai = this;
                this.leftLeg.add(lThighMesh);
                this.leftCalf = new THREE.Group();
                this.leftCalf.position.set(0, -0.4, 0);
                this.leftLeg.add(this.leftCalf);
                const lCalfMesh = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.45, 0.13), uniformMat);
                lCalfMesh.position.y = -0.2;
                lCalfMesh.userData.ai = this;
                this.leftCalf.add(lCalfMesh);

                // Right leg
                this.rightLeg = new THREE.Group();
                this.rightLeg.position.set(0.12, 0, 0);
                this.bodyRoot.add(this.rightLeg);
                const rThighMesh = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.4, 0.15), uniformMat);
                rThighMesh.position.y = -0.2;
                rThighMesh.userData.ai = this;
                this.rightLeg.add(rThighMesh);
                this.rightCalf = new THREE.Group();
                this.rightCalf.position.set(0, -0.4, 0);
                this.rightLeg.add(this.rightCalf);
                const rCalfMesh = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.45, 0.13), uniformMat);
                rCalfMesh.position.y = -0.2;
                rCalfMesh.userData.ai = this;
                this.rightCalf.add(rCalfMesh);

                scene.add(this.mesh);

                this.dead      = true;
                this.timer     = Math.random() * 2;
                this.crouchT   = 1.0;
                this.aimT      = 0.0;
                this.walkTime  = Math.random() * 10;

                this.respawn();
            }

            getDesiredCovers() {
                if (this.isEnemy) {
                    if (this.coverTier === 1) return enemyPathCovers;
                    if (this.coverTier === 2) return midCoversEnemy;
                    if (this.coverTier === 3) return allyCoversFront;
                    if (this.coverTier === 4) return allyCoversBack;
                    return this.trenchLevel === 'front' ? enemyCoversFront : enemyCoversBack;
                } else {
                    if (this.coverTier === 1) return allyPathCovers;
                    if (this.coverTier === 2) return midCoversAlly;
                    if (this.coverTier === 3) return enemyCoversFront;
                    if (this.coverTier === 4) return enemyCoversBack;
                    return this.trenchLevel === 'front' ? allyCoversFront : allyCoversBack;
                }
            }

            pickCover(isSpawning = false) {
                const peers = this.isEnemy ? enemies : allies;

                if (!this.isAdvancing) {
                    const backCovers = this.isEnemy ? enemyCoversBack : allyCoversBack;

                    let friendlyOnTurret = backCovers.some(c => {
                        if (!c.isTurret) return false;
                        if (c.turret.user && !c.turret.user.dead && (this.isEnemy ? c.turret.user.isEnemy : !c.turret.user.isEnemy)) return true;
                        if (peers.some(p => p !== this && !p.dead && p.targetCover === c)) return true;
                        return false;
                    });

                    if (!friendlyOnTurret) {
                        let emptyTurrets = backCovers.filter(c => {
                            if (!c.isTurret) return false;
                            if (c.turret.user && c.turret.user !== this && !c.turret.user.dead) return false;
                            if (peers.some(p => p !== this && !p.dead && p.targetCover === c)) return false;
                            return true;
                        });

                        if (emptyTurrets.length > 0) {
                            let safeTurrets = emptyTurrets;
                            if (isSpawning) {
                                let hiddenTurrets = emptyTurrets.filter(c => !isSpotVisibleToPlayer(c));
                                if (hiddenTurrets.length > 0) safeTurrets = hiddenTurrets;
                            }
                            this.targetCover = safeTurrets[Math.floor(Math.random() * safeTurrets.length)];
                            this.trenchLevel = 'back';
                            this.coverTier   = 0;
                            return;
                        }
                    }

                    const tryTrench = (level) => {
                        const covers = level === 'back'
                            ? (this.isEnemy ? enemyCoversBack  : allyCoversBack)
                            : (this.isEnemy ? enemyCoversFront : allyCoversFront);

                        let available = covers.filter(c => {
                            if (c.isTurret && c.turret.user && c.turret.user !== this) return false;
                            return !peers.some(p => p !== this && !p.dead && p.targetCover === c);
                        });

                        if (available.length > 0) {
                            this.trenchLevel = level;
                            this.coverTier   = 0;
                            if (isSpawning) {
                                let safe = available.filter(c => !isSpotVisibleToPlayer(c));
                                if (safe.length > 0) available = safe;
                            }
                            this.targetCover = available[Math.floor(Math.random() * available.length)];
                            return true;
                        }

                        if (level === 'back') return tryTrench('front');
                        this.isAdvancing = true;
                        this.coverTier   = 0;
                        return false;
                    };

                    if (tryTrench('back')) return;
                }

                // Advancing: tier-based cover selection
                let covers = this.getDesiredCovers();

                let available = covers.filter(c => {
                    if (c.isTurret && c.turret.user && c.turret.user !== this) return false;
                    return !peers.some(p => p !== this && !p.dead && p.targetCover === c);
                });

                if (available.length === 0) {
                    const occupancy = covers.map(c => ({
                        cover: c,
                        count: peers.filter(p => p !== this && !p.dead && p.targetCover === c).length
                    }));
                    const minCount = Math.min(...occupancy.map(o => o.count));
                    available = occupancy.filter(o => o.count === minCount).map(o => o.cover);
                }

                if (isSpawning) {
                    let safeAvailable = available.filter(c => !isSpotVisibleToPlayer(c));
                    if (safeAvailable.length > 0) available = safeAvailable;
                }

                this.targetCover = available[Math.floor(Math.random() * available.length)];
            }

            respawn() {
                this.hp           = Math.floor(Math.random() * 2) + 1;
                this.dead         = false;
                this.mesh.visible = true;
                this.state        = 'hidden';
                this.mesh.rotation.x = 0;
                this.deathAnimT   = 0;

                if (this.targetCover && this.targetCover.isTurret && this.targetCover.turret.user === this) {
                    this.targetCover.turret.user = null;
                }

                this.timer        = 0.5 + Math.random();
                this.target       = null;
                this.targetCover  = null;
                this.scanBaseYaw  = this.isEnemy ? Math.PI : 0;
                this.shootDelay   = 0;
                this.trenchLevel  = Math.random() > 0.5 ? 'front' : 'back';
                this.crouchT      = 1.0;
                this.aimT         = 0.0;

                const team = this.isEnemy ? enemies : allies;
                let livingCount = 0;
                let advancers   = 0;
                for (let i = 0; i < team.length; i++) {
                    if (!team[i].dead && team[i] !== this) {
                        livingCount++;
                        if (team[i].isAdvancing) advancers++;
                    }
                }
                livingCount++;
                this.isAdvancing    = (advancers / livingCount) < 0.5;
                this.coverTier      = 0;
                this.interruptedMove = false;

                this.pickCover(true);
                this.mesh.position.set(
                    this.targetCover.x,
                    getTerrainHeight(this.targetCover.x, this.targetCover.z),
                    this.targetCover.z
                );
            }

            alert(attacker) {
                if (this.dead || !attacker || attacker.dead) return;

                if (!this.target || Math.random() < 0.8) {
                    const isFriendlyFire      = !attacker.isPlayer && (attacker.isEnemy === this.isEnemy);
                    const isPlayerShootingAlly = attacker.isPlayer && !this.isEnemy;
                    if (!isFriendlyFire && !isPlayerShootingAlly) {
                        this.target = attacker;
                        let targetPos = attacker.isPlayer
                            ? camera.getWorldPosition(new THREE.Vector3())
                            : attacker.mesh.position.clone();
                        this.scanBaseYaw = Math.atan2(targetPos.x - this.mesh.position.x, targetPos.z - this.mesh.position.z);
                    }
                }

                if (this.state === 'moving') {
                    this.state           = 'aiming';
                    this.timer           = 0.4 + Math.random() * 0.4;
                    this.shootDelay      = 0;
                    this.interruptedMove = true;
                } else if (this.state === 'hidden' && Math.random() < 0.8) {
                    this.state = 'popping';
                    this.timer = 0.2;
                } else if (this.state === 'aiming' || this.state === 'shooting') {
                    this.state = 'aiming';
                    this.timer = 0.5 + Math.random();
                }
            }

            takeDamage(amount, attacker) {
                if (this.dead || this.hp <= 0) return;

                if (attacker && !attacker.isPlayer) {
                    amount = AI_DAMAGE_FROM_AI;
                }

                this.hp -= amount;

                if (this.hp <= 0) {
                    this.dead = true;
                    if (this.targetCover && this.targetCover.isTurret && this.targetCover.turret.user === this) {
                        this.targetCover.turret.user = null;
                    }
                    this.deathAnimT  = 0.0;
                    this.corpseDelay = 2.0;
                    this.timer       = 3 + Math.random() * 2;
                    if (attacker === playerAI && this.isEnemy) {
                        playerKills++;
                        document.getElementById('kill-count-indicator').innerText = `Kills: ${playerKills}`;
                    }
                } else if (attacker && !attacker.dead) {
                    const isFriendlyFire      = !attacker.isPlayer && (attacker.isEnemy === this.isEnemy);
                    const isPlayerShootingAlly = attacker.isPlayer && !this.isEnemy;
                    if (!isFriendlyFire && !isPlayerShootingAlly) {
                        this.alert(attacker);
                    }
                    if (this.state === 'aiming' || this.state === 'popping') this.timer += 0.2;
                }
            }

            update(dt) {
                // --- Death / Respawn sequence ---
                if (this.dead) {
                    if (this.deathAnimT < 1.0) {
                        // Fall backward animation
                        this.deathAnimT += dt * 3.0;
                        if (this.deathAnimT > 1.0) this.deathAnimT = 1.0;
                        this.mesh.rotation.x = this.deathAnimT * (-Math.PI / 2 + 0.1);
                        this.bodyRoot.position.y = 0.85 - (this.crouchT * 0.45) - (this.deathAnimT * 0.6);
                        this.rightArm.rotation.x += (0.1  - this.rightArm.rotation.x) * 10 * dt;
                        this.leftArm.rotation.x  += (0.1  - this.leftArm.rotation.x)  * 10 * dt;
                        this.rightArm.rotation.z += (0.2  - this.rightArm.rotation.z) * 10 * dt;
                        this.leftArm.rotation.z  += (-0.2 - this.leftArm.rotation.z)  * 10 * dt;
                        this.rightArm.rotation.y += (0    - this.rightArm.rotation.y) * 10 * dt;
                        this.leftArm.rotation.y  += (0    - this.leftArm.rotation.y)  * 10 * dt;
                        this.rightForearm.rotation.x += (0 - this.rightForearm.rotation.x) * 10 * dt;
                        this.leftForearm.rotation.x  += (0 - this.leftForearm.rotation.x)  * 10 * dt;
                        this.weaponGroup.position.lerp(new THREE.Vector3(0.2, -0.4, 0.1), 10 * dt);
                        this.weaponGroup.rotation.x += (Math.PI/2 - this.weaponGroup.rotation.x) * 10 * dt;
                        this.leftLeg.rotation.x   += (0 - this.leftLeg.rotation.x)   * 10 * dt;
                        this.rightLeg.rotation.x  += (0 - this.rightLeg.rotation.x)  * 10 * dt;
                        this.leftCalf.rotation.x  += (0 - this.leftCalf.rotation.x)  * 10 * dt;
                        this.rightCalf.rotation.x += (0 - this.rightCalf.rotation.x) * 10 * dt;
                        this.crouchT += (0 - this.crouchT) * 5 * dt;
                        this.torso.rotation.x    = this.crouchT * 0.4;
                        this.headGroup.rotation.x = -this.torso.rotation.x;
                        this.mesh.position.y = getTerrainHeight(this.mesh.position.x, this.mesh.position.z);
                    } else if (this.corpseDelay > 0) {
                        // Lie on ground
                        this.corpseDelay -= dt;
                    } else {
                        // Respawn queue
                        if (this.mesh.visible) this.mesh.visible = false;
                        this.timer -= dt;
                        if (this.timer <= 0) {
                            if (gameMode === 'endless') {
                                this.respawn();
                            } else if (gameMode === 'elimination') {
                                if (this.isEnemy && enemyReserves > 0) {
                                    enemyReserves--;
                                    this.respawn();
                                } else if (!this.isEnemy && allyReserves > 0) {
                                    allyReserves--;
                                    this.respawn();
                                }
                            }
                        }
                    }
                    return;
                }

                this.timer -= dt;

                // --- Threat detection ---
                let closestThreat  = null;
                let closestDistSq  = 25;
                const myForward    = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), this.mesh.rotation.y);
                const opposingForce = this.isEnemy ? [...allies, playerAI] : enemies;

                for (let i = 0; i < opposingForce.length; i++) {
                    const threat = opposingForce[i];
                    if (!threat.dead) {
                        const tPos = threat.isPlayer ? playerRoot.position : threat.mesh.position;
                        let perceivedDistSq = this.mesh.position.distanceToSquared(tPos);
                        const toThreat = tPos.clone().sub(this.mesh.position).normalize();
                        const dot      = myForward.dot(toThreat);
                        const isExposed = threat.isPlayer ? !isCrouched : (threat.state === 'moving' || threat.crouchT < 0.5);
                        if (dot > 0.5) perceivedDistSq *= 0.4;
                        if (isExposed)  perceivedDistSq *= 0.4;
                        if (perceivedDistSq < closestDistSq) {
                            closestDistSq = perceivedDistSq;
                            closestThreat = threat;
                        }
                    }
                }

                if (closestThreat && this.target !== closestThreat) {
                    if (this.calculateExposure(closestThreat) > 0) {
                        this.target = closestThreat;
                        const tPos = closestThreat.isPlayer
                            ? camera.getWorldPosition(new THREE.Vector3())
                            : closestThreat.mesh.position.clone();
                        this.scanBaseYaw = Math.atan2(tPos.x - this.mesh.position.x, tPos.z - this.mesh.position.z);
                        if (this.state === 'moving') this.interruptedMove = true;
                        if (this.state !== 'using_turret') {
                            this.state      = 'aiming';
                            this.shootDelay = 0.2 + Math.random() * 0.2;
                        }
                    }
                }

                let targetCrouch = 0.0;
                let targetAim    = 0.0;

                // --- State machine ---
                switch (this.state) {

                    case 'moving': {
                        targetCrouch = 0.5;
                        const moveSpeed = AI_MOVE_SPEED;
                        let destX = this.targetCover.x;
                        let destZ = this.targetCover.z;
                        let curX  = this.mesh.position.x;
                        let curZ  = this.mesh.position.z;
                        let tempX = destX;
                        let tempZ = destZ;

                        const isHome  = (z) => Math.abs(z) >= 17;
                        const isMid   = (z) => Math.abs(z) <= 5;
                        const isPath  = (z) => Math.abs(z) > 5 && Math.abs(z) < 17;
                        const getPathX = (x) => (Math.abs(x - (-40)) < Math.abs(x - 40)) ? -40 : 40;

                        if (isHome(curZ) && !isHome(destZ)) {
                            let px = getPathX(curX);
                            if (Math.abs(curX - px) > 1.0) { tempX = px; tempZ = curZ; }
                            else                            { tempX = px; tempZ = destZ; }
                        } else if (isMid(curZ) && !isMid(destZ)) {
                            let px = getPathX(curX);
                            if (Math.abs(curX - px) > 1.0) { tempX = px; tempZ = curZ; }
                            else                            { tempX = px; tempZ = destZ; }
                        } else if (isPath(curZ)) {
                            if (isHome(destZ)) {
                                let safeZ = destZ > 0 ? 19.5 : -19.5;
                                if (Math.abs(destZ) > 26) safeZ = destZ > 0 ? 28 : -28;
                                if (Math.abs(curZ - safeZ) > 1.0) { tempX = curX; tempZ = safeZ; }
                                else                               { tempX = destX; tempZ = destZ; }
                            } else if (isMid(destZ)) {
                                if (Math.abs(curZ) > 1.0) { tempX = curX; tempZ = 0; }
                                else                      { tempX = destX; tempZ = destZ; }
                            }
                        }

                        let dx   = tempX - curX;
                        let dz   = tempZ - curZ;
                        let dist = Math.sqrt(dx*dx + dz*dz);
                        let finalDx   = destX - curX;
                        let finalDz   = destZ - curZ;
                        let finalDist = Math.sqrt(finalDx*finalDx + finalDz*finalDz);

                        if (finalDist < 0.2) {
                            if (this.targetCover && this.targetCover.isTurret) {
                                this.state = 'hidden';
                                this.timer = 0.1;
                            } else {
                                this.state = 'hidden';
                                this.timer = 0.2 + Math.random() * 0.3;
                            }
                        } else {
                            if (dist < 0.1) { dx = finalDx; dz = finalDz; dist = finalDist; }
                            this.mesh.position.x += (dx/dist) * moveSpeed * dt;
                            this.mesh.position.z += (dz/dist) * moveSpeed * dt;
                            const targetYaw = Math.atan2(dx, dz);
                            let diff = targetYaw - this.mesh.rotation.y;
                            while (diff < -Math.PI) diff += Math.PI * 2;
                            while (diff >  Math.PI) diff -= Math.PI * 2;
                            this.mesh.rotation.y += diff * 10 * dt;
                        }
                        break;
                    }

                    case 'hidden':
                        targetCrouch = 1.0;
                        if (this.timer <= 0) {
                            if (this.targetCover && this.targetCover.isTurret) {
                                if (!this.targetCover.turret.user || this.targetCover.turret.user === this) {
                                    this.state = 'using_turret';
                                } else {
                                    this.pickCover();
                                    this.state = 'moving';
                                }
                            } else if (this.isAdvancing && this.coverTier < 4 && !this.findTarget()) {
                                this.coverTier++;
                                this.pickCover();
                                this.state = 'moving';
                            } else {
                                this.state = 'popping';
                                this.timer = 0.3;
                            }
                        }
                        break;

                    case 'using_turret': {
                        targetCrouch = 0.0;
                        targetAim    = 0.0;
                        const t = this.targetCover.turret;
                        if (!t || (t.user && t.user !== this)) {
                            this.state = 'hidden';
                            break;
                        }
                        t.user = this;

                        // Lock AI position to turret mount
                        this.mesh.position.x = t.mesh.position.x;
                        this.mesh.position.z = t.mesh.position.z + (this.isEnemy ? 1.0 : -1.0);
                        this.mesh.position.y = getTerrainHeight(this.mesh.position.x, this.mesh.position.z);

                        if (t.isReloading || t.ammo <= 0) {
                            this.shootDelay = 0.5 + Math.random() * 0.5;
                            t.swivel.rotation.y    += (this.scanBaseYaw - t.swivel.rotation.y) * 2 * dt;
                            t.pitchGroup.rotation.x += (0 - t.pitchGroup.rotation.x) * 2 * dt;
                            this.mesh.rotation.y = t.swivel.rotation.y + Math.PI;
                        } else if (this.target && !this.target.dead && this.checkLOS(this.target)) {
                            let targetPos = new THREE.Vector3();
                            if (this.target.isPlayer) camera.getWorldPosition(targetPos);
                            else targetPos.copy(this.target.mesh.position);

                            const tx = targetPos.x - t.mesh.position.x;
                            const tz = targetPos.z - t.mesh.position.z;
                            let targetTurretYaw = Math.atan2(tx, tz) + Math.PI;

                            let aiYawDiff = targetTurretYaw - t.baseYaw;
                            while (aiYawDiff < -Math.PI) aiYawDiff += Math.PI * 2;
                            while (aiYawDiff >  Math.PI) aiYawDiff -= Math.PI * 2;
                            if (aiYawDiff >  Math.PI / 2) targetTurretYaw = t.baseYaw + Math.PI / 2;
                            if (aiYawDiff < -Math.PI / 2) targetTurretYaw = t.baseYaw - Math.PI / 2;

                            let tDiff = targetTurretYaw - t.swivel.rotation.y;
                            while (tDiff < -Math.PI) tDiff += Math.PI * 2;
                            while (tDiff >  Math.PI) tDiff -= Math.PI * 2;
                            t.swivel.rotation.y += tDiff * 5 * dt;

                            const tDist2d = Math.sqrt(tx*tx + tz*tz);
                            const ty      = targetPos.y - (t.mesh.position.y + 0.3);
                            const targetTurretPitch = Math.atan2(ty, tDist2d);
                            t.pitchGroup.rotation.x += (targetTurretPitch - t.pitchGroup.rotation.x) * 5 * dt;

                            this.mesh.rotation.y = t.swivel.rotation.y + Math.PI;

                            if (this.shootDelay <= 0) {
                                if (Math.abs(tDiff) < 0.2) {
                                    shootTurret(t, this);
                                    this.shootDelay = 1.8 + Math.random() * 0.4;
                                }
                            } else {
                                this.shootDelay -= dt;
                            }
                        } else {
                            this.target     = this.findTarget();
                            this.shootDelay = 0.5 + Math.random() * 0.5;
                            t.swivel.rotation.y    += (this.scanBaseYaw - t.swivel.rotation.y) * 2 * dt;
                            t.pitchGroup.rotation.x += (0 - t.pitchGroup.rotation.x) * 2 * dt;
                            this.mesh.rotation.y = t.swivel.rotation.y + Math.PI;
                        }
                        break;
                    }

                    case 'popping':
                        targetCrouch = 0.0;
                        targetAim    = 1.0;
                        if (this.target) this.aimAtTarget(dt);
                        if (this.timer <= 0) {
                            this.state = 'aiming';
                            this.timer = 0.5 + Math.random() * 1.0;
                            if (!this.target || this.target.dead || !this.checkLOS(this.target)) {
                                this.target = this.findTarget();
                            } else {
                                this.shootDelay = 0.1 + Math.random() * 0.2;
                            }
                        }
                        break;

                    case 'aiming':
                        targetCrouch = 0.0;
                        targetAim    = 1.0;
                        if (this.target && !this.target.dead && this.checkLOS(this.target)) {
                            this.aimAtTarget(dt);
                            if (this.shootDelay <= 0) {
                                this.state       = 'shooting';
                                this.shotsFired  = 0;
                                this.shotsToFire = 3 + Math.floor(Math.random() * 4);
                                this.timer       = 0.1;
                            } else {
                                this.shootDelay -= dt;
                            }
                        } else {
                            this.target     = this.findTarget();
                            this.shootDelay = 0.1 + Math.random() * 0.2;
                            this.mesh.rotation.y = this.scanBaseYaw + Math.sin(performance.now() * 0.002 + this.mesh.id) * 0.5;
                            if (this.timer <= 0) {
                                if (this.isAdvancing && this.coverTier < 4) {
                                    this.coverTier++;
                                    this.pickCover();
                                    this.state = 'moving';
                                } else {
                                    this.state = 'hidden';
                                    this.timer = 0.5 + Math.random();
                                }
                            }
                        }
                        break;

                    case 'shooting':
                        targetCrouch = 0.0;
                        targetAim    = 1.0;
                        if (!this.target || this.target.dead || !this.checkLOS(this.target)) {
                            this.state = 'hidden';
                            this.timer = 0.5 + Math.random();
                            break;
                        }
                        this.aimAtTarget(dt);
                        if (this.timer <= 0) {
                            this.shoot();
                            this.shotsFired++;
                            this.timer = 0.15 + Math.random() * 0.15;
                            if (this.shotsFired >= this.shotsToFire) {
                                if (this.interruptedMove) {
                                    this.interruptedMove = false;
                                    this.state = 'moving';
                                } else if (this.isAdvancing && this.coverTier < 4 && Math.random() < 0.95) {
                                    this.coverTier++;
                                    this.pickCover();
                                    this.state = 'moving';
                                } else if (this.isAdvancing && Math.random() < 0.2) {
                                    this.pickCover();
                                    this.state = 'moving';
                                } else {
                                    if (!this.isAdvancing) {
                                        const team = this.isEnemy ? enemies : allies;
                                        let living = 0, adv = 0;
                                        team.forEach(s => { if (!s.dead) { living++; if (s.isAdvancing) adv++; } });
                                        if (adv / living < 0.5) this.isAdvancing = true;
                                    }
                                    this.state = 'hidden';
                                    this.timer = 0.5 + Math.random() * 1.0;
                                }
                            }
                        }
                        break;
                }

                // --- Crouch/aim blend ---
                this.crouchT += (targetCrouch - this.crouchT) * 10 * dt;
                this.aimT    += (targetAim    - this.aimT)    * 12 * dt;

                this.bodyRoot.position.y  = 0.85 - (this.crouchT * 0.45);
                this.torso.rotation.x     = this.crouchT * 0.4;
                this.headGroup.rotation.x = -this.torso.rotation.x;

                // --- Walk animation ---
                let legSwing = 0;
                let armSwing = 0;
                if (this.state === 'moving') {
                    this.walkTime += dt * 10;
                    legSwing = Math.sin(this.walkTime) * 0.6;
                    armSwing = Math.sin(this.walkTime) * 0.3;
                } else {
                    this.walkTime = 0;
                }

                const squatThighRot = -1.2 * this.crouchT;
                const squatCalfRot  =  2.0 * this.crouchT;
                this.leftLeg.rotation.z  =  0.15 * this.crouchT;
                this.rightLeg.rotation.z = -0.15 * this.crouchT;
                this.leftLeg.rotation.x  = squatThighRot + legSwing;
                this.leftCalf.rotation.x = squatCalfRot;
                if (legSwing < 0) this.leftCalf.rotation.x += legSwing * -0.5;
                this.rightLeg.rotation.x  = squatThighRot - legSwing;
                this.rightCalf.rotation.x = squatCalfRot;
                if (legSwing > 0) this.rightCalf.rotation.x += -legSwing * -0.5;

                // --- Weapon & arm kinematics ---
                const idleGunPos = new THREE.Vector3(0.05, -0.15, 0.35);
                const idleGunRot = new THREE.Euler(0.4, 0.5, -0.1);
                const aimGunPos  = new THREE.Vector3(0.12, 0.15, -0.05);
                const aimGunRot  = new THREE.Euler(0, 0, 0);

                this.weaponGroup.position.lerpVectors(idleGunPos, aimGunPos, this.aimT);
                this.weaponGroup.rotation.set(
                    idleGunRot.x + (aimGunRot.x - idleGunRot.x) * this.aimT,
                    idleGunRot.y + (aimGunRot.y - idleGunRot.y) * this.aimT,
                    idleGunRot.z + (aimGunRot.z - idleGunRot.z) * this.aimT
                );
                if (this.state === 'moving') {
                    this.weaponGroup.position.y += Math.sin(this.walkTime * 2) * 0.02;
                    this.weaponGroup.rotation.x += Math.sin(this.walkTime) * 0.05;
                }

                const idleRArm    = new THREE.Euler(-0.4, -0.2,  0.1);
                const aimRArm     = new THREE.Euler(-1.2, -0.2,  0.3);
                const idleRForearm = new THREE.Euler(-0.6,  0,    0);
                const aimRForearm  = new THREE.Euler(-2.4,  0,    0);
                const idleLArm    = new THREE.Euler(-0.3,  0.4, -0.2);
                const aimLArm     = new THREE.Euler(-1.4,  0.8,  0);
                const idleLForearm = new THREE.Euler(-1.2,  0,    0);
                const aimLForearm  = new THREE.Euler(-0.2,  0,    0);

                this.rightArm.rotation.set(
                    idleRArm.x + (aimRArm.x - idleRArm.x) * this.aimT + (armSwing * (1 - this.aimT)),
                    idleRArm.y + (aimRArm.y - idleRArm.y) * this.aimT,
                    idleRArm.z + (aimRArm.z - idleRArm.z) * this.aimT
                );
                this.rightForearm.rotation.x = idleRForearm.x + (aimRForearm.x - idleRForearm.x) * this.aimT;

                this.leftArm.rotation.set(
                    idleLArm.x + (aimLArm.x - idleLArm.x) * this.aimT - (armSwing * (1 - this.aimT)),
                    idleLArm.y + (aimLArm.y - idleLArm.y) * this.aimT,
                    idleLArm.z + (aimLArm.z - idleLArm.z) * this.aimT
                );
                this.leftForearm.rotation.x = idleLForearm.x + (aimLForearm.x - idleLForearm.x) * this.aimT;

                // --- Peer separation ---
                const peers = this.isEnemy ? enemies : allies;
                peers.forEach(peer => {
                    if (peer !== this && !peer.dead) {
                        const cdx = this.mesh.position.x - peer.mesh.position.x;
                        const cdz = this.mesh.position.z - peer.mesh.position.z;
                        const distSq = cdx*cdx + cdz*cdz;
                        if (distSq < 0.64 && distSq > 0.0001) {
                            const cDist   = Math.sqrt(distSq);
                            const overlap = AI_PEER_SEPARATION - cDist;
                            let nx = cdx / cDist;
                            let nz = cdz / cDist;
                            let tx = -nz;
                            let tz = nx;
                            this.mesh.position.x += (nx * 0.6 + tx * 0.8) * overlap * 5 * dt;
                            this.mesh.position.z += (nz * 0.6 + tz * 0.8) * overlap * 5 * dt;
                        }
                    }
                });

                // --- Obstacle collision ---
                let aiPos2D = { x: this.mesh.position.x, z: this.mesh.position.z };
                resolveObstacles(aiPos2D, 0.4);
                this.mesh.position.x = aiPos2D.x;
                this.mesh.position.z = aiPos2D.z;

                // --- Z-axis bounds by tier ---
                let minZ, maxZ;
                if (this.isEnemy) {
                    if (this.coverTier === 4)          { minZ = -36.2; maxZ = 36.2; }
                    else if (this.coverTier === 3)     { minZ = -22.0; maxZ = 36.2; }
                    else if (this.coverTier > 0)       { minZ =  -5.0; maxZ = 36.2; }
                    else if (this.trenchLevel === 'front') { minZ = 18.2; maxZ = 21.8; }
                    else                               { minZ = 26.8;  maxZ = 36.2; }
                } else {
                    if (this.coverTier === 4)          { minZ = -36.2; maxZ = 36.2; }
                    else if (this.coverTier === 3)     { minZ = -36.2; maxZ = 22.0; }
                    else if (this.coverTier > 0)       { minZ = -36.2; maxZ =  5.0; }
                    else if (this.trenchLevel === 'front') { minZ = -21.8; maxZ = -18.2; }
                    else                               { minZ = -36.2; maxZ = -26.8; }
                }
                this.mesh.position.z = Math.max(minZ, Math.min(maxZ, this.mesh.position.z));

                // --- Snap to cover position when stationary ---
                if (this.state !== 'moving' && this.state !== 'using_turret' && this.targetCover && !this.targetCover.isTurret) {
                    this.mesh.position.x += (this.targetCover.x - this.mesh.position.x) * 2 * dt;
                    this.mesh.position.z += (this.targetCover.z - this.mesh.position.z) * 2 * dt;
                }

                this.mesh.position.y = getTerrainHeight(this.mesh.position.x, this.mesh.position.z);
            }

            calculateExposure(target) {
                const heightOffset  = 1.55 - (this.crouchT * 0.45);
                const eyeStart      = this.mesh.position.clone().add(new THREE.Vector3(0, heightOffset, 0));
                const pointsToCheck = [];

                if (target.isPlayer) {
                    const base   = playerRoot.position.clone();
                    const pProne = isProne || slideTimer > 0;
                    pointsToCheck.push(base.clone().add(new THREE.Vector3(0, pProne ? 0.3  : (isCrouched ? 0.8 : 1.5), 0)));
                    pointsToCheck.push(base.clone().add(new THREE.Vector3(0, pProne ? 0.15 : (isCrouched ? 0.4 : 1.0), 0)));
                    pointsToCheck.push(base.clone().add(new THREE.Vector3(0, 0.2, 0)));
                } else {
                    const base    = target.mesh.position.clone();
                    const cOffset = target.crouchT * 0.45;
                    pointsToCheck.push(base.clone().add(new THREE.Vector3(0, 1.55 - cOffset, 0)));
                    pointsToCheck.push(base.clone().add(new THREE.Vector3(0, 1.0  - (cOffset * 0.5), 0)));
                    pointsToCheck.push(base.clone().add(new THREE.Vector3(0, 0.3, 0)));
                }

                let hits = 0;
                for (let pt of pointsToCheck) {
                    const dir  = pt.clone().sub(eyeStart).normalize();
                    const dist = eyeStart.distanceTo(pt);
                    raycaster.set(eyeStart, dir);
                    const intersects = raycaster.intersectObjects(worldMeshes, false);
                    if (!(intersects.length > 0 && intersects[0].distance < dist)) hits++;
                }
                return hits / pointsToCheck.length;
            }

            checkLOS(target) {
                return this.calculateExposure(target) > 0;
            }

            findTarget() {
                let targets = this.isEnemy ? [...allies, playerAI] : enemies;
                targets = targets.filter(t => !t.dead && t.hp > 0);
                if (targets.length === 0) return null;

                const myPos     = this.mesh.position;
                const myForward = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), this.mesh.rotation.y);
                let bestTarget  = null;
                let bestScore   = Infinity;

                for (let i = 0; i < targets.length; i++) {
                    const target = targets[i];
                    const tPos   = target.isPlayer ? playerRoot.position : target.mesh.position;
                    let score    = tPos.distanceToSquared(myPos);
                    if (score > 10000) continue;
                    const exposure = this.calculateExposure(target);
                    if (exposure === 0) continue;
                    const toTarget = tPos.clone().sub(myPos).normalize();
                    const dot      = myForward.dot(toTarget);
                    if (dot > 0.5)  score *= 0.3;
                    else if (dot < 0) score *= 2.5;
                    score /= exposure;
                    score *= (0.8 + Math.random() * 0.4);
                    if (score < bestScore) { bestScore = score; bestTarget = target; }
                }
                return bestTarget;
            }

            aimAtTarget(dt) {
                if (!this.target) return;
                let targetPos = new THREE.Vector3();
                if (this.target.isPlayer) camera.getWorldPosition(targetPos);
                else targetPos.copy(this.target.mesh.position);
                const targetYaw = Math.atan2(targetPos.x - this.mesh.position.x, targetPos.z - this.mesh.position.z);
                let diff = targetYaw - this.mesh.rotation.y;
                while (diff < -Math.PI) diff += Math.PI * 2;
                while (diff >  Math.PI) diff -= Math.PI * 2;
                this.mesh.rotation.y += diff * 8 * dt;
            }

            shoot() {
                if (!this.target || this.target.dead) return;
                const heightOffset = 1.55 - (this.crouchT * 0.45);
                const eyeStart     = this.mesh.position.clone().add(new THREE.Vector3(0, heightOffset, 0));

                this.weaponGroup.updateMatrixWorld(true);
                const visualStart = new THREE.Vector3(0, 0, 0.9).applyMatrix4(this.weaponGroup.matrixWorld);

                let targetPos = new THREE.Vector3();
                if (this.target.isPlayer) {
                    camera.getWorldPosition(targetPos);
                    targetPos.y -= 0.2;
                } else {
                    const targetHeightOffset = 1.55 - (this.target.crouchT * 0.45);
                    targetPos.copy(this.target.mesh.position).add(new THREE.Vector3(0, targetHeightOffset, 0));
                }

                const dir  = targetPos.clone().sub(eyeStart).normalize();
                const dist = eyeStart.distanceTo(targetPos);

                let spread = 0.05 + (dist * 0.002);
                if (!this.target.isPlayer) spread *= 8.0;
                dir.x += (Math.random() - 0.5) * spread;
                dir.y += (Math.random() - 0.5) * spread;
                dir.z += (Math.random() - 0.5) * spread;
                dir.normalize();

                showMuzzleFlash(visualStart, dir);
                raycaster.set(eyeStart, dir);

                if (this.shotsFired % 4 === 0) {
                    playPositionalSound(visualStart, 'gunshot');
                }

                const hitTargets = [playerAI.mesh, ...allies.map(a => a.mesh), ...enemies.map(e => e.mesh)];
                const intersects = raycaster.intersectObjects([...worldMeshes, ...hitTargets], true);

                let hitDistance = 200;
                if (intersects.length > 0) {
                    const hit   = intersects[0];
                    hitDistance = hit.distance;
                    playPositionalSound(hit.point, 'impact');
                    if (hit.object.userData.ai) {
                        const hitAI = hit.object.userData.ai;
                        if (hitAI.isPlayer) hitAI.takeDamage(1, this);
                        else hitAI.takeDamage(hit.object.name === "head" ? 99 : 1, this);
                    } else {
                        let normal = new THREE.Vector3(0, 1, 0);
                        if (hit.face) normal.copy(hit.face.normal).applyMatrix3(new THREE.Matrix3().getNormalMatrix(hit.object.matrixWorld)).normalize();
                        createImpact(hit.point, normal);
                        if (Math.random() < 0.3) {
                            let reflection = dir.clone().sub(normal.clone().multiplyScalar(2 * dir.dot(normal))).normalize();
                            reflection.x += (Math.random() - 0.5) * 0.3;
                            reflection.y += Math.random() * 0.4;
                            reflection.z += (Math.random() - 0.5) * 0.3;
                            reflection.normalize();
                            createTracer(hit.point, reflection, 60);
                            if (camera.getWorldPosition(new THREE.Vector3()).distanceToSquared(hit.point) < 64.0) {
                                playSoundFile('whiz', 1.5 + Math.random() * 0.5, 0.2);
                            }
                        }
                    }
                }

                if (Math.random() < 0.25) createTracer(visualStart, dir, hitDistance);

                const bulletRay = new THREE.Ray(eyeStart, dir);
                const hitPool   = [...allies, ...enemies, playerAI];
                let closestPt   = new THREE.Vector3();
                hitPool.forEach(t => {
                    if (!t.dead) {
                        const posOffset = t.isPlayer
                            ? ((isProne || slideTimer > 0) ? 0.15 : (isCrouched ? 0.4 : 1.0))
                            : (1.0 - (t.crouchT * 0.45));
                        const pos = t.isPlayer ? playerRoot.position.clone() : t.mesh.position.clone();
                        pos.y += posOffset;
                        bulletRay.closestPointToPoint(pos, closestPt);
                        const distAlongRay = eyeStart.distanceTo(closestPt);
                        if (distAlongRay < hitDistance + 1.0) {
                            const distSq = closestPt.distanceToSquared(pos);
                            if (!t.isPlayer) {
                                if (distSq < 16.0) t.alert(this);
                            } else {
                                if (distSq < 2.0) playNearMissSound();
                            }
                        }
                    }
                });
            }
        }

        const allies  = [];
        const enemies = [];

        function spawnSoldiers(count) {
            allies.forEach(a => scene.remove(a.mesh));
            enemies.forEach(e => scene.remove(e.mesh));
            allies.length  = 0;
            enemies.length = 0;
            for (let i = 0; i < count; i++) {
                allies.push(new AI(false));
                enemies.push(new AI(true));
            }
        }

        // ================================================================
        // SECTION 13: GAME MANAGEMENT
        // ================================================================

        function startGame(mode) {
            gameMode = mode;
            if (!initialized) {
                initAudio();
                startAmbientBattle();
                initialized = true;
            }

            // Reset player state
            playerHp      = PLAYER_HP_MAX;
            playerAI.dead = false;
            document.getElementById('healthbar').style.width   = '100%';
            document.getElementById('hurt-overlay').style.opacity    = 0;
            document.getElementById('hurt-overlay').style.background = 'red';
            document.getElementById('victory-screen').style.display  = 'none';

            // Randomize spawn position (center 2/3 of map, trench or parapet)
            const spawnX = (Math.random() - 0.5) * 132;
            let spawnZ   = Math.random() > 0.5 ? (-21 + Math.random() * 3) : (-34 + Math.random() * 6);
            let spawnPos2D = { x: spawnX, z: spawnZ };
            resolveObstacles(spawnPos2D, 0.4);
            playerRoot.position.set(spawnPos2D.x, getTerrainHeight(spawnPos2D.x, spawnPos2D.z), spawnPos2D.z);

            // Reset player controls
            yaw          = Math.PI;
            pitch        = 0;
            isCrouched   = false;
            isProne      = false;
            slideTimer   = 0;
            mgHeat       = 0;
            mgOverheated = false;
            qToggled     = false;
            eToggled     = false;
            rollAngle    = 0;
            activeRollDir = 0;
            rollCooldown  = 0;

            playerKills = 0;
            document.getElementById('kill-count-indicator').innerText = 'Kills: 0';
            sniperNeedsRechamber = false;
            sniperZoomLevel      = SNIPER_ZOOM_DEFAULT;

            if (mountedTurret) {
                mountedTurret.user = null;
                mountedTurret      = null;
                weaponContainer.visible = true;
            }
            turrets.forEach(t => t.user = null);

            const totalCount  = parseInt(document.getElementById('soldier-count').value, 10) || 500;
            const activeCount = parseInt(document.getElementById('active-count').value, 10) || 25;

            if (mode === 'elimination') {
                const initialSpawn = Math.min(totalCount, activeCount);
                allyReserves  = totalCount - initialSpawn;
                enemyReserves = totalCount - initialSpawn;
                spawnSoldiers(initialSpawn);
                document.getElementById('reserves-indicator').style.display = 'block';
            } else {
                spawnSoldiers(activeCount);
                document.getElementById('reserves-indicator').style.display = 'none';
            }

            if (!document.pointerLockElement) {
                document.body.requestPointerLock().catch(err => console.warn(err));
            }
        }

        // --- Button listeners ---
        document.getElementById('btn-endless').addEventListener('click', () => startGame('endless'));
        document.getElementById('btn-elimination').addEventListener('click', () => startGame('elimination'));
        document.getElementById('btn-victory-menu').addEventListener('click', () => {
            document.getElementById('victory-screen').style.display  = 'none';
            document.getElementById('instructions').style.display    = 'flex';
        });
        document.addEventListener('pointerlockchange', () => {
            if (document.getElementById('victory-screen').style.display === 'flex') return;
            document.getElementById('instructions').style.display = document.pointerLockElement ? 'none' : 'flex';
        });

        // Initial preview spawn (shows soldiers before mode is selected)
        spawnSoldiers(25);


        // ================================================================
        // SECTION 14: GAME LOOP
        // ================================================================

        let lastTime          = performance.now();
        let bobTime           = 0;
        let breathTime        = 0;
        let currentScreenShake = 0;

        function animate() {
            requestAnimationFrame(animate);

            // --- TIMING ---
            const now = performance.now();
            let dt = (now - lastTime) / 1000;
            lastTime = now;
            if (dt > 0.1) dt = 0.1;
            breathTime += dt * 1.5;

            // ---- PLAYER FRAME (only runs while alive and pointer locked) ----
            if (!playerAI.dead && document.pointerLockElement) {

                // --- ELIMINATION VICTORY CHECK ---
                if (gameMode === 'elimination') {
                    const aliveEnemies = enemies.filter(e => !e.dead).length;
                    document.getElementById('reserves-indicator').innerText = `Enemies Remaining: ${enemyReserves + aliveEnemies}`;
                    if (aliveEnemies === 0 && enemyReserves <= 0) {
                        document.exitPointerLock();
                        document.getElementById('victory-screen').style.display = 'flex';
                        playerAI.dead = true;
                        return;
                    }
                }

                // --- MG HEAT & HEAT BAR UI ---
                if (mgHeat > 0) {
                    mgHeat -= (mgOverheated ? MG_COOL_OVERHEAT : MG_COOL_NORMAL) * dt;
                    if (mgHeat <= 0) { mgHeat = 0; mgOverheated = false; }
                }
                const heatContainer = document.getElementById('heatbar-container');
                if (currentWeaponIndex === 1 && !mountedTurret) {
                    heatContainer.style.display = 'block';
                    document.getElementById('heatbar').style.width      = mgHeat + '%';
                    document.getElementById('heatbar').style.background = mgOverheated ? '#ff0000' : '#ff8800';
                } else {
                    heatContainer.style.display = 'none';
                }

                // --- SHOOTING ---
                const wep = weaponsData[currentWeaponIndex];
                if (keys.lmb) {
                    if (mountedTurret) shootTurret(mountedTurret, playerAI);
                    else if (wep.type === 'auto' || lmbJustPressed) shootPlayer();
                }
                lmbJustPressed = false;

                // --- SNIPER BOLT RECHAMBER STATE ---
                let isRechambering    = false;
                let isActivelyBolting = false;
                let boltProgress      = 0;

                if (currentWeaponIndex === 2 && sniperNeedsRechamber && !mountedTurret) {
                    isRechambering = true;
                    const timeSinceBoltStart = now - sniperRechamberStartTime;
                    if (timeSinceBoltStart >= wep.fireRate) {
                        sniperNeedsRechamber = false;
                        isRechambering       = false;
                    } else if (timeSinceBoltStart >= SNIPER_PRE_BOLT_DELAY) {
                        isActivelyBolting = true;
                        boltProgress      = (timeSinceBoltStart - SNIPER_PRE_BOLT_DELAY) / (wep.fireRate - SNIPER_PRE_BOLT_DELAY);
                    }
                }

                // --- AIM STATE & SCOPE ---
                const isAiming = (keys.rmb || keys.space) && !isActivelyBolting;
                document.getElementById('scope-overlay').style.display =
                    (isAiming && currentWeaponIndex === 2 && !mountedTurret) ? 'flex' : 'none';

                // --- CROSSHAIR ---
                let hideCrosshair = false;
                if (mountedTurret) {
                    hideCrosshair = isAiming;
                } else {
                    hideCrosshair = isAiming || currentWeaponIndex === 2;
                }
                document.getElementById('crosshair').style.display = hideCrosshair ? 'none' : 'block';

                // --- ACTION PROMPT ---
                const promptEl = document.getElementById('action-prompt');
                let canMount   = false;
                if (!mountedTurret) {
                    turrets.forEach(t => {
                        const canClaim = !t.user || (t.user && !t.user.isEnemy && t.user !== playerAI);
                        if (canClaim && playerRoot.position.distanceTo(t.mesh.position) < TURRET_MOUNT_RANGE) canMount = true;
                    });
                }
                if (mountedTurret) {
                    promptEl.style.display = 'block';
                    promptEl.innerText     = "Press T to leave turret";
                } else if (canMount) {
                    promptEl.style.display = 'block';
                    promptEl.innerText     = "Press T to use turret";
                } else {
                    promptEl.style.display = 'none';
                }

                // --- WEAPON BOB & SWAY ---
                let bobOffsetX       = 0;
                let bobOffsetY       = 0;
                let targetWeaponRotY = 0;
                let targetWeaponRotZ = 0;
                let targetWeaponRotX = 0;
                let targetBoltRotZ   = 0;
                let targetBoltPosZ   = -0.05;

                const isMovingInput = (keys.w || keys.s || keys.a || keys.d) && document.pointerLockElement && !mountedTurret;

                if (slideTimer > 0 && !isAiming) {
                    targetWeaponRotX -= 0.15;
                    targetWeaponRotZ += 0.15;
                    bobOffsetX = Math.cos(bobTime) * 0.01;
                    bobOffsetY = Math.sin(bobTime) * 0.01;
                } else if (isMovingInput && !isAiming) {
                    let moveMult = 1.0;
                    if (isProne)                   moveMult = 0.3;
                    else if (isCrouched && keys.shift) moveMult = 1.5;
                    else if (isCrouched)           moveMult = 0.5;
                    else if (keys.shift)           moveMult = 2.5;
                    bobOffsetX      = Math.cos(bobTime * 0.5) * 0.015 * moveMult;
                    bobOffsetY      = Math.sin(bobTime)       * 0.015 * moveMult;
                    targetWeaponRotZ += Math.cos(bobTime * 0.5) * -0.05 * moveMult;
                    targetWeaponRotX += Math.sin(bobTime)       *  0.02 * moveMult;
                    targetWeaponRotY += Math.cos(bobTime * 0.5) *  0.04 * moveMult;
                } else if (!isAiming && !mountedTurret) {
                    bobOffsetY      = Math.sin(breathTime) * 0.004;
                    targetWeaponRotX += Math.sin(breathTime) * 0.005;
                }

                // --- AIM / SCOPE FOV ---
                let targetFov = 75;
                if (isAiming && !mountedTurret) {
                    if (currentWeaponIndex === 2) {
                        targetFov = 75 / sniperZoomLevel;
                        modelSniper.visible = false;
                    } else {
                        targetFov = 40;
                        weaponContainer.position.lerp(new THREE.Vector3(0, wep.alignY, -0.25), 15 * dt);
                    }
                } else if (!mountedTurret) {
                    if (currentWeaponIndex === 2) modelSniper.visible = true;
                    weaponContainer.position.lerp(new THREE.Vector3(0.2 + bobOffsetX, -0.2 + bobOffsetY, -0.4), 15 * dt);
                } else if (mountedTurret) {
                    targetFov = isAiming ? 40 : 75;
                }

                // --- SNIPER BOLT ANIMATION ---
                if (isActivelyBolting && !mountedTurret) {
                    targetWeaponRotZ += Math.sin(boltProgress * Math.PI) * 0.25;
                    targetWeaponRotX += Math.sin(boltProgress * Math.PI) * -0.05;
                    if (boltProgress < 0.15) {
                        // 1. Unlock (rotate handle up)
                        targetBoltRotZ = (boltProgress / 0.15) * (-Math.PI / 3);
                    } else if (boltProgress < 0.4) {
                        // 2. Pull back
                        targetBoltRotZ = -Math.PI / 3;
                        targetBoltPosZ = -0.05 + ((boltProgress - 0.15) / 0.25) * 0.15;
                    } else if (boltProgress < 0.65) {
                        // 3. Push forward
                        targetBoltRotZ = -Math.PI / 3;
                        targetBoltPosZ = 0.10 - ((boltProgress - 0.4) / 0.25) * 0.15;
                    } else if (boltProgress < 0.8) {
                        // 4. Lock (rotate handle down)
                        targetBoltRotZ = -Math.PI / 3 + ((boltProgress - 0.65) / 0.15) * (Math.PI / 3);
                    }
                }

                // Apply weapon rotation sway
                weaponContainer.rotation.z += (targetWeaponRotZ - weaponContainer.rotation.z) * 10 * dt;
                weaponContainer.rotation.x += (targetWeaponRotX - weaponContainer.rotation.x) * 10 * dt;
                weaponContainer.rotation.y += (targetWeaponRotY - (weaponContainer.rotation.y || 0)) * 10 * dt;

                // Animate bolt handle
                snBoltGroup.rotation.z += (targetBoltRotZ - snBoltGroup.rotation.z) * 25 * dt;
                snBoltGroup.position.z += (targetBoltPosZ - snBoltGroup.position.z) * 25 * dt;

                // Recoil Z recovery
                weaponContainer.position.z += (-0.4 - weaponContainer.position.z) * 10 * dt;

                // FOV lerp
                camera.fov += (targetFov - camera.fov) * 15 * dt;
                camera.updateProjectionMatrix();

                // --- LEAN & ROLL ---
                const isLeaningLeft  = (keys.q || qToggled) && !mountedTurret && !isProne;
                const isLeaningRight = (keys.e || eToggled) && !mountedTurret && !isLeaningLeft && !isProne;

                if (rollCooldown > 0) rollCooldown -= dt;

                if (isProne && !mountedTurret) {
                    if (activeRollDir === 0 && rollCooldown <= 0) {
                        if (keys.q)      activeRollDir =  1;
                        else if (keys.e) activeRollDir = -1;
                    }
                } else {
                    activeRollDir = 0;
                }

                const isRollingLeft  = activeRollDir ===  1;
                const isRollingRight = activeRollDir === -1;

                if (!isProne) {
                    const targetLeanZ = isLeaningLeft  ?  0.25 : (isLeaningRight ? -0.25 : 0);
                    const targetLeanX = isLeaningLeft  ? -0.5  : (isLeaningRight ?  0.5  : 0);
                    leanObject.rotation.z += (targetLeanZ - leanObject.rotation.z) * 10 * dt;
                    if (typeof leanObject.userData.baseLocalX === 'undefined') leanObject.userData.baseLocalX = 0;
                    leanObject.userData.baseLocalX += (targetLeanX - leanObject.userData.baseLocalX) * 10 * dt;
                    rollAngle = leanObject.rotation.z;
                } else {
                    if (isRollingLeft) {
                        rollAngle += Math.PI * 3 * dt;
                        if (rollAngle >= Math.PI * 2) { rollAngle = 0; activeRollDir = 0; rollCooldown = 0.4; }
                    } else if (isRollingRight) {
                        rollAngle -= Math.PI * 3 * dt;
                        if (rollAngle <= -Math.PI * 2) { rollAngle = 0; activeRollDir = 0; rollCooldown = 0.4; }
                    } else {
                        rollAngle = rollAngle % (Math.PI * 2);
                        if (rollAngle >  Math.PI) rollAngle -= Math.PI * 2;
                        if (rollAngle < -Math.PI) rollAngle += Math.PI * 2;
                        rollAngle += (0 - rollAngle) * 12 * dt;
                    }
                    leanObject.rotation.z = rollAngle;
                    if (typeof leanObject.userData.baseLocalX === 'undefined') leanObject.userData.baseLocalX = 0;
                    leanObject.userData.baseLocalX += (0 - leanObject.userData.baseLocalX) * 10 * dt;
                }

                // --- CAMERA LEAN POSITION (world-space obstacle resolution) ---
                if (!mountedTurret) {
                    let leanLocalVec = new THREE.Vector3(leanObject.userData.baseLocalX, 0, 0);
                    leanLocalVec.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
                    let leanPos2D = { x: playerRoot.position.x + leanLocalVec.x, z: playerRoot.position.z + leanLocalVec.z };
                    resolveObstacles(leanPos2D, 0.3);
                    let resolvedLocalVec = new THREE.Vector3(leanPos2D.x - playerRoot.position.x, 0, leanPos2D.z - playerRoot.position.z);
                    resolvedLocalVec.applyAxisAngle(new THREE.Vector3(0, 1, 0), -yaw);
                    leanObject.position.x = resolvedLocalVec.x;
                    leanObject.position.z = resolvedLocalVec.z;

                    // --- PLAYER EYE HEIGHT ---
                    const effProne   = isProne || slideTimer > 0;
                    let targetEyeY   = effProne ? EYE_HEIGHT_PRONE : (isCrouched ? EYE_HEIGHT_CROUCH : EYE_HEIGHT_STAND);
                    if (isProne && (isRollingLeft || isRollingRight)) targetEyeY = 0.2;
                    leanObject.position.y += (targetEyeY - leanObject.position.y) * 10 * dt;

                    pitchObject.position.z += (0 - pitchObject.position.z) * 15 * dt;

                    playerAI.mesh.scale.y    = effProne ? 0.2 : (isCrouched ? 0.5 : 1.0);
                    playerAI.mesh.position.y = effProne ? 0.18 : (isCrouched ? 0.45 : 0.9);
                    playerAI.mesh.position.x = leanObject.position.x;
                    playerAI.mesh.position.z = leanObject.position.z;

                    // --- PLAYER MOVEMENT ---
                    const moveDir = new THREE.Vector3();
                    if (isRollingLeft) {
                        moveDir.x -= 1;
                    } else if (isRollingRight) {
                        moveDir.x += 1;
                    } else {
                        if (keys.w) moveDir.z -= 1;
                        if (keys.s) moveDir.z += 1;
                        if (keys.a) moveDir.x -= 1;
                        if (keys.d) moveDir.x += 1;
                    }
                    if (moveDir.lengthSq() > 0) moveDir.normalize();
                    moveDir.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);

                    let speed   = SPEED_STAND_WALK;
                    let bobSpeed = 8;
                    let bobAmp   = 0.05;
                    let slideVelocity = new THREE.Vector3(0, 0, 0);

                    if (slideTimer > 0) {
                        slideTimer -= dt;
                        slideSpeed = Math.max(0, slideSpeed - SLIDE_FRICTION * dt);
                        slideVelocity.copy(slideDir).multiplyScalar(slideSpeed * dt);
                        speed    = 1.5;
                        bobSpeed = 0;
                        bobAmp   = 0;
                    } else if (isProne) {
                        if (isRollingLeft || isRollingRight) {
                            speed = SPEED_PRONE_ROLL; bobSpeed = 0; bobAmp = 0;
                        } else if (keys.shift && !isAiming) {
                            speed = SPEED_PRONE_SPRINT; bobSpeed = 6; bobAmp = 0.025;
                        } else {
                            speed = SPEED_PRONE; bobSpeed = 4; bobAmp = 0.015;
                        }
                    } else if (isCrouched) {
                        if (keys.shift && !isAiming) { speed = SPEED_CROUCH_SPRINT; bobSpeed = 10; bobAmp = 0.035; }
                        else                          { speed = SPEED_CROUCH_WALK;  bobSpeed =  6; bobAmp = 0.02; }
                    } else {
                        if (keys.shift && !isAiming) { speed = SPEED_STAND_SPRINT; bobSpeed = 12; bobAmp = 0.05; }
                        else                          { speed = SPEED_STAND_WALK;  bobSpeed =  8; bobAmp = 0.05; }
                    }

                    const velocity = moveDir.multiplyScalar(speed * dt).add(slideVelocity);

                    if (moveDir.lengthSq() > 0 && document.pointerLockElement) {
                        bobTime += dt * bobSpeed;
                        pitchObject.position.y = Math.sin(bobTime) * bobAmp;
                    } else if (document.pointerLockElement) {
                        pitchObject.position.y += (Math.sin(breathTime) * 0.015 - pitchObject.position.y) * 5 * dt;
                    } else {
                        pitchObject.position.y += (0 - pitchObject.position.y) * 10 * dt;
                    }

                    // Move player root and clamp to world bounds
                    let nextPos = playerRoot.position.clone().add(velocity);
                    const pr    = PLAYER_RADIUS;
                    if (nextPos.z < -36.3 + pr) nextPos.z = -36.3 + pr;
                    if (nextPos.z >  36.3 - pr) nextPos.z =  36.3 - pr;
                    if (nextPos.x < -95 + pr)   nextPos.x = -95 + pr;
                    if (nextPos.x >  95 - pr)   nextPos.x =  95 - pr;

                    let pPos2D = { x: nextPos.x, z: nextPos.z };
                    resolveObstacles(pPos2D, pr);
                    nextPos.x = pPos2D.x;
                    nextPos.z = pPos2D.z;

                    // Player-AI crowd separation
                    const allLivingAI = [...allies, ...enemies].filter(a => !a.dead);
                    allLivingAI.forEach(ai => {
                        let dx = nextPos.x - ai.mesh.position.x;
                        let dz = nextPos.z - ai.mesh.position.z;
                        let distSq  = dx * dx + dz * dz;
                        let minDist = AI_PEER_SEPARATION;
                        if (distSq < minDist * minDist && distSq > 0.0001) {
                            let dist = Math.sqrt(distSq);
                            let overlap = minDist - dist;
                            nextPos.x += (dx / dist) * overlap;
                            nextPos.z += (dz / dist) * overlap;
                        }
                    });

                    playerRoot.position.copy(nextPos);
                    playerRoot.position.y = getTerrainHeight(playerRoot.position.x, playerRoot.position.z);

                } else {
                    // --- TURRET MOUNT: lock camera to turret pivot ---
                    leanObject.position.x += (0   - leanObject.position.x) * 15 * dt;
                    leanObject.position.z += (0   - leanObject.position.z) * 15 * dt;
                    leanObject.position.y += (0.1 - leanObject.position.y) * 15 * dt;
                    pitchObject.position.z += (0 - pitchObject.position.z) * 15 * dt;
                    pitchObject.position.y += (0 - pitchObject.position.y) * 15 * dt;

                    const targetCamZ = isAiming ? 0.25 : 0.8;
                    const targetCamY = isAiming ? 0.14 : 0.35;
                    camera.position.y += (targetCamY - camera.position.y) * 15 * dt;
                    camera.position.z += (targetCamZ - camera.position.z) * 15 * dt;

                    playerRoot.position.copy(mountedTurret.mesh.position);
                    mountedTurret.swivel.rotation.y    = yaw;
                    mountedTurret.pitchGroup.rotation.x = pitch;
                }

                // --- WEAPON INDICATOR UI ---
                const weaponInd = document.getElementById('weapon-indicator');
                if (mountedTurret) {
                    if (mountedTurret.isReloading) {
                        weaponInd.innerText   = `Turret [RELOADING...] (${mountedTurret.ammo}/${mountedTurret.maxAmmo})`;
                        weaponInd.style.color = '#ffffaa';
                    } else {
                        weaponInd.innerText   = `Turret (${mountedTurret.ammo}/${mountedTurret.maxAmmo})`;
                        weaponInd.style.color = mountedTurret.ammo === 0 ? '#ff5555' : 'white';
                    }
                } else {
                    weaponInd.innerText   = weaponsData[currentWeaponIndex].name;
                    weaponInd.style.color = 'white';
                }

                // --- TURRET RELOAD ANIMATION ---
                turrets.forEach(t => {
                    t.pitchGroup.position.z += (0 - t.pitchGroup.position.z) * 10 * dt;

                    if (t.isReloading) {
                        if (t.user) {
                            t.reloadTimer -= dt;
                            t.dummyShell.visible = true;
                            let loadProgress = 1.0 - (t.reloadTimer / 0.6);
                            if (loadProgress > 1) loadProgress = 1;
                            if (loadProgress < 0) loadProgress = 0;
                            t.dummyShell.position.set(0, 0.4 - (loadProgress * 0.3), 0.1);

                            if (t.reloadTimer <= 0) {
                                t.ammo++;
                                playSoundFile('gunshot', 3.0, 0.05);
                                t.pitchGroup.rotation.z = (Math.random() - 0.5) * 0.15;
                                if (t.ammo >= t.maxAmmo) {
                                    t.isReloading = false;
                                    t.dummyShell.visible = false;
                                } else {
                                    t.reloadTimer = 0.6;
                                }
                            }
                        } else {
                            t.dummyShell.visible = false;
                        }
                        t.pitchGroup.rotation.z += (0 - t.pitchGroup.rotation.z) * 10 * dt;
                    } else {
                        t.dummyShell.visible = false;
                        t.pitchGroup.rotation.z += (0 - t.pitchGroup.rotation.z) * 10 * dt;
                        if (t.ammo <= 0 && t.user) {
                            t.isReloading = true;
                            t.reloadTimer = 0.6;
                        }
                    }
                });

            } // end player frame

            // --- HURT OVERLAY FADE ---
            const hurtEl = document.getElementById('hurt-overlay');
            if (!playerAI.dead && parseFloat(hurtEl.style.opacity) > 0) {
                hurtEl.style.opacity = Math.max(0, parseFloat(hurtEl.style.opacity) - dt);
            }

            // --- FP MUZZLE FLASH FADE ---
            if (fpFlashMaterial.opacity > 0) {
                fpFlashMaterial.opacity = Math.max(0, fpFlashMaterial.opacity - dt * 20);
                fpFlashLight.intensity  = Math.max(0, fpFlashLight.intensity - dt * 40);
            }

            // --- EXPLOSION POOL UPDATE ---
            explosions.forEach(exp => {
                if (exp.life > 0) {
                    exp.life -= dt;
                    let t = 1.0 - (exp.life / exp.maxLife);
                    if (t > 1) t = 1;
                    const scale = 0.5 + (Math.pow(t, 0.4) * 9.0);
                    exp.mesh.scale.set(scale, scale, scale);
                    if (t < 0.15)      exp.mesh.material.color.setHex(0xffffff);
                    else if (t < 0.4)  exp.mesh.material.color.setHex(0xff8800);
                    else               exp.mesh.material.color.setHex(0x330800);
                    exp.mesh.material.opacity = (1.0 - t) * 0.9;
                    exp.light.intensity = Math.max(0, 20.0 * (1.0 - (t * 1.5)));
                    if (exp.life <= 0) {
                        exp.mesh.visible    = false;
                        exp.light.intensity = 0;
                    }
                }
            });

            // --- IMPACT POOL UPDATE ---
            impacts.forEach(imp => {
                if (imp.life > 0) {
                    imp.life -= dt;
                    imp.mesh.scale.addScalar(dt * 10);
                    imp.mesh.material.opacity = (imp.life / 0.2);
                    if (imp.life <= 0) imp.mesh.visible = false;
                }
            });

            // --- AI ENTITY UPDATE ---
            allies.forEach(a => a.update(dt));
            enemies.forEach(e => e.update(dt));

            // --- WORLD FLASH POOL UPDATE ---
            flashes.forEach(f => {
                if (f.life > 0) {
                    f.life -= dt;
                    if (f.life <= 0) f.mesh.material.opacity = 0;
                }
            });

            // --- TRACER POOL UPDATE ---
            tracers.forEach(t => {
                if (t.life > 0) {
                    t.life -= dt;
                    const moveDist = 150 * dt;
                    t.traveled += moveDist;
                    if (t.traveled >= t.maxDist) {
                        t.life = 0;
                        t.mesh.visible = false;
                    } else {
                        t.mesh.position.add(t.dir.clone().multiplyScalar(moveDist));
                    }
                }
            });

            // --- ASH PARTICLES UPDATE ---
            const positions = ashParticles.geometry.attributes.position.array;
            for (let i = 0; i < ashCount * 3; i += 3) {
                positions[i]   -= dt * 1.5; // Drift left
                positions[i+1] -= dt * 0.8; // Fall down
                if (positions[i]   < -100) positions[i]   = 100;
                if (positions[i+1] <   -2) positions[i+1] = 10 + Math.random() * 5;
            }
            ashParticles.geometry.attributes.position.needsUpdate = true;

            // --- HORIZON LIGHTS DECAY ---
            horizonLights.forEach(hl => {
                if (hl.timer > 0) {
                    hl.timer -= dt;
                    if (hl.timer <= 0) hl.light.intensity = 0;
                } else {
                    hl.light.intensity = Math.max(0, hl.light.intensity - dt * 20);
                }
            });

            // --- SHELL SHOCK AUDIO EFFECTS ---
            if (audioCtx && masterFilter) {
                if (shellShockTimer > 0) {
                    shellShockTimer -= dt;
                    masterFilter.frequency.setTargetAtTime(300,   audioCtx.currentTime, 0.1);
                    masterGain.gain.setTargetAtTime(0.4,          audioCtx.currentTime, 0.1);
                } else {
                    masterFilter.frequency.setTargetAtTime(22000, audioCtx.currentTime, 2.0);
                    masterGain.gain.setTargetAtTime(1.0,          audioCtx.currentTime, 2.0);
                }
            }

            // --- SCREEN SHAKE & RENDER ---
            let sx = 0, sy = 0, sz = 0;
            if (currentScreenShake > 0) {
                currentScreenShake -= dt;
                sx = (Math.random() - 0.5) * currentScreenShake;
                sy = (Math.random() - 0.5) * currentScreenShake;
                sz = (Math.random() - 0.5) * currentScreenShake;
                camera.position.x += sx;
                camera.position.y += sy;
                camera.position.z += sz;
            }

            renderer.render(scene, camera);

            // Revert screen shake so logical aiming is unaffected
            if (sx !== 0 || sy !== 0 || sz !== 0) {
                camera.position.x -= sx;
                camera.position.y -= sy;
                camera.position.z -= sz;
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
