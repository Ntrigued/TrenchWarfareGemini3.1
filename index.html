<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Trench Warfare FPS</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: sans-serif;
            user-select: none;
        }
        #game-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 24px;
            font-weight: bold;
        }
        #action-prompt {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 20px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border: 2px solid #333;
            display: none;
        }
        #healthbar-container {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 300px;
            height: 25px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #333;
        }
        #healthbar {
            width: 100%;
            height: 100%;
            background: #00aa00;
            transition: width 0.2s;
        }
        #heatbar-container {
            position: absolute;
            bottom: 60px;
            left: 30px;
            width: 300px;
            height: 10px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #333;
            display: none;
        }
        #heatbar {
            width: 0%;
            height: 100%;
            background: #ff8800;
            transition: width 0.1s;
        }
        #weapon-indicator {
            position: absolute;
            bottom: 30px;
            right: 30px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border: 2px solid #333;
        }
        #kill-count-indicator {
            position: absolute;
            bottom: 90px;
            right: 30px;
            color: white;
            font-size: 20px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 16px;
            border: 2px solid #333;
        }
        #reserves-indicator {
            position: absolute;
            top: 30px;
            right: 30px;
            color: white;
            font-size: 20px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 16px;
            border: 2px solid #333;
            display: none;
        }
        #scope-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(circle, transparent 35%, rgba(0,0,0,0.9) 55%, black 100%);
            align-items: center;
            justify-content: center;
        }
        .scope-line-h { width: 100%; height: 2px; background: rgba(0,0,0,0.8); position: absolute; }
        .scope-line-v { width: 2px; height: 100%; background: rgba(0,0,0,0.8); position: absolute; }
        .scope-dot { width: 4px; height: 4px; background: red; border-radius: 50%; position: absolute; }
        #instructions {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 10;
        }
        .menu-btn {
            background: #333; color: #fff; border: 2px solid #555;
            padding: 12px 24px; font-size: 18px; font-weight: bold;
            cursor: pointer; transition: 0.2s; border-radius: 4px;
            font-family: sans-serif;
        }
        .menu-btn:hover { background: #555; border-color: #888; }
        
        #victory-screen {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 50, 0, 0.85); color: white; z-index: 20;
            flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto;
        }
        .inst-text {
            max-width: 600px;
            text-align: center;
            line-height: 1.6;
            font-size: 18px;
        }
        #hurt-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: red;
            opacity: 0;
            transition: opacity 0.1s;
        }
        #hit-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border-top: 2px solid white;
            border-right: 2px solid white;
            opacity: 0;
            transform-origin: center;
            transform: translate(-50%, -50%) rotate(45deg);
            transition: opacity 0.1s;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="ui">
        <div id="hurt-overlay"></div>
        <div id="scope-overlay">
            <div class="scope-line-h"></div>
            <div class="scope-line-v"></div>
            <div class="scope-dot"></div>
        </div>
        <div id="crosshair">+</div>
        <div id="action-prompt">Press T to use turret</div>
        <div id="hit-marker"></div>
        <div id="healthbar-container">
            <div id="healthbar"></div>
        </div>
        <div id="heatbar-container">
            <div id="heatbar"></div>
        </div>
        <div id="reserves-indicator">Enemies Remaining: 0</div>
        <div id="kill-count-indicator">Kills: 0</div>
        <div id="weapon-indicator">1: Rifle</div>
        <div id="instructions">
            <div class="inst-text">
                <h2>TRENCH WARFARE</h2>
                <p>Select a mode to deploy and lock pointer.</p>
                <p>
                    <b>WASD</b>: Move &nbsp;|&nbsp; <b>Shift</b>: Sprint &nbsp;|&nbsp; <b>C</b>: Toggle Crouch / Slide<br>
                    <b>Q / E</b>: Lean Left / Right &nbsp;|&nbsp; <b>T</b>: Mount Turret &nbsp;|&nbsp; <b>R</b>: Reload Turret &nbsp;|&nbsp; <b>Z</b>: Go Prone<br>
                    <b>RMB / Space</b>: Aim Down Sights &nbsp;|&nbsp; <b>LMB</b>: Fire<br>
                    <b>1, 2, 3</b>: Switch Weapons &nbsp;|&nbsp; <b>F / G</b>: Sniper Zoom
                </p>
                <p style="color:#aaa; font-size:14px;">Survive an endless onslaught or eliminate the enemy reinforcements.</p>
            </div>
            
            <div style="margin: 20px 0; display: flex; flex-direction: column; align-items: center; background: rgba(0,0,0,0.5); padding: 15px; border-radius: 8px; border: 1px solid #444; width: 340px;">
                <label for="soldier-count" style="font-size: 16px; font-weight: bold; margin-bottom: 5px;">
                    Total Forces (Elimination): <span id="soldier-count-display">500</span>
                </label>
                <input type="range" id="soldier-count" min="10" max="1000" value="500" style="width: 250px; cursor: pointer; margin-bottom: 15px;">

                <label for="active-count" style="font-size: 16px; font-weight: bold; margin-bottom: 5px;">
                    Max Active on Field: <span id="active-count-display">25</span>
                </label>
                <input type="range" id="active-count" min="10" max="100" value="25" style="width: 250px; cursor: pointer;">
            </div>

            <div style="display: flex; gap: 20px;">
                <button id="btn-endless" class="menu-btn">Play Endless Mode</button>
                <button id="btn-elimination" class="menu-btn">Play Elimination Mode</button>
            </div>
        </div>
        
        <div id="victory-screen">
            <h1 style="font-size: 72px; margin-bottom: 10px; text-shadow: 0 0 10px #0f0;">VICTORY</h1>
            <p style="font-size: 24px; margin-bottom: 30px;">The enemy line has been broken.</p>
            <button id="btn-victory-menu" class="menu-btn">Return to Menu</button>
        </div>
    </div>

    <script>
        // --- GLOBALS & SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x555555, 0.015);
        scene.background = new THREE.Color(0x555555);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- AUDIO SYSTEM ---
        let audioCtx;
        let masterFilter;
        let masterGain;
        let shellShockTimer = 0;
        const audioBuffers = {};

        function triggerShellShock(duration) {
            shellShockTimer = Math.max(shellShockTimer, duration);
        }

        function createRealisticGunshot(ctx) {
            const buffer = ctx.createBuffer(1, ctx.sampleRate * 1.0, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            let lastOut = 0;
            for (let i = 0; i < data.length; i++) {
                const t = i / ctx.sampleRate;
                const crack = (Math.random() * 2 - 1) * Math.exp(-t * 50) * 1.5;
                const boomFreq = 40 + 140 * Math.exp(-t * 35);
                const boom = Math.sin(2 * Math.PI * boomFreq * t) * Math.exp(-t * 12) * 4.0;
                const sub = Math.sin(2 * Math.PI * 35 * t) * Math.exp(-t * 6) * 1.5;
                const noise = (Math.random() * 2 - 1) * Math.exp(-t * 18) * 0.8;
                let sample = crack + boom + sub + noise;
                lastOut = lastOut + 0.45 * (sample - lastOut);
                let saturated = Math.tanh(lastOut * 1.3);
                const tail = (Math.random() * 2 - 1) * Math.exp(-t * 2.5) * 0.12;
                data[i] = saturated + tail;
            }
            return buffer;
        }

        function createRealisticExplosion(ctx) {
            const buffer = ctx.createBuffer(1, ctx.sampleRate * 2.5, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            let lastOut = 0;
            for (let i = 0; i < data.length; i++) {
                const t = i / ctx.sampleRate;
                const noise = Math.random() * 2 - 1;
                const attack = Math.min(1.0, t * 20);
                const decay = Math.exp(-t * 1.5);
                const rumble = Math.sin(2 * Math.PI * (20 + 30 * Math.random()) * t);
                let sample = (noise * 0.6 + rumble * 0.4) * attack * decay;
                lastOut = lastOut + 0.05 * (sample - lastOut); 
                data[i] = lastOut * 3.0;
            }
            return buffer;
        }

        function createBulletWhiz(ctx) {
            const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.3, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            let lastOut = 0;
            for (let i = 0; i < data.length; i++) {
                const t = i / ctx.sampleRate;
                const freq = 1200 - 800 * (t / 0.3); 
                const tone = Math.sin(2 * Math.PI * freq * t);
                const noise = Math.random() * 2 - 1;
                const env = t < 0.1 ? (t / 0.1) : 1.0 - ((t - 0.1) / 0.2);
                let sample = (tone * 0.6 + noise * 0.4) * env;
                lastOut = lastOut + 0.4 * (sample - lastOut);
                data[i] = lastOut * 0.8;
            }
            return buffer;
        }

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                
                // Master audio routing for Shell Shock
                masterFilter = audioCtx.createBiquadFilter();
                masterFilter.type = 'lowpass';
                masterFilter.frequency.value = 22000;
                
                masterGain = audioCtx.createGain();
                masterGain.gain.value = 1.0;
                
                masterFilter.connect(masterGain);
                masterGain.connect(audioCtx.destination);

                audioBuffers['gunshot'] = createRealisticGunshot(audioCtx);
                audioBuffers['artillery'] = createRealisticExplosion(audioCtx);
                audioBuffers['whiz'] = createBulletWhiz(audioCtx);
            }
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function playSoundFile(name, pitchShift = 1.0, volume = 1.0, isDistant = false) {
            if (!audioCtx || !audioBuffers[name]) return; 
            const source = audioCtx.createBufferSource();
            source.buffer = audioBuffers[name];
            source.playbackRate.value = pitchShift * (0.95 + Math.random() * 0.1);
            const gain = audioCtx.createGain();
            gain.gain.value = volume;
            if (isDistant) {
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 300 + Math.random() * 500;
                source.connect(filter);
                filter.connect(gain);
            } else {
                source.connect(gain);
            }
            gain.connect(masterFilter); // Route into Shell Shock effects
            source.start(0);
        }

        function playPositionalSound(pos, type = 'gunshot') {
            if (!audioCtx) return;
            const camPos = camera.getWorldPosition(new THREE.Vector3());
            const dist = camPos.distanceTo(pos);
            
            // STRICT PROXIMITY CHECK: Only play localized real sounds within 25 meters
            if (dist > 25) return; 
            
            // Exponential drop-off for realistic sound attenuation
            let vol = Math.exp(-dist * 0.12);
            
            if (type === 'impact') {
                // High pitch snap/thud for nearby bullet impacts
                playSoundFile('gunshot', 1.5 + Math.random() * 0.5, vol * 0.3); 
            } else if (type === 'artillery') {
                // Explosive impact sound with same quadratic drop-off
                playSoundFile('artillery', 1.2 + Math.random() * 0.3, vol * 1.5);
            } else {
                // Standard local muzzle gunshot
                playSoundFile('gunshot', 0.9 + Math.random() * 0.2, vol * 0.7);
            }
        }

        let lastNearMissTime = 0;
        function playNearMissSound() {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;
            if (now - lastNearMissTime < 0.3) return; // Slightly throttle how often it can play
            lastNearMissTime = now;
            playSoundFile('whiz', 0.9 + Math.random() * 0.2, 0.8);
        }

        function startAmbientBattle() {
            setInterval(() => {
                if (Math.random() > 0.5) {
                    const isCloseHit = Math.random() < 0.15;
                    playSoundFile('artillery', 0.6 + Math.random() * 0.4, isCloseHit ? 1.5 : 0.7, !isCloseHit);
                    
                    // Flash horizon lights
                    let hl = horizonLights[Math.floor(Math.random() * horizonLights.length)];
                    hl.light.intensity = 5.0 + Math.random() * 15.0;
                    hl.timer = 0.2 + Math.random() * 0.4;

                    if (isCloseHit) triggerShellShock(2.5);
                }
            }, 2500);

            // Frequent but heavily muted ambient gunshots
            setInterval(() => {
                // Increased volume to 0.15 and significantly lowered pitch for a deeper, bassier rumble
                if (Math.random() > 0.3) playSoundFile('gunshot', 0.25 + Math.random() * 0.2, 0.15, true);
            }, 150);
        }

        // --- WORLD GEOMETRY & TERRAIN ---
        const worldMeshes = [];
        const collisionObstacles = [];
        const turrets = [];
        let mountedTurret = null;
        
        function getTerrainHeight(x, z) {
            const absZ = Math.abs(z);
            if (absZ < 22.0) return -1.2; 
            if (absZ >= 22.0 && absZ < 26.0) {
                const inGap = (Math.abs(x + 60) < 4.2) || (Math.abs(x + 20) < 4.2) || 
                              (Math.abs(x - 20) < 4.2) || (Math.abs(x - 60) < 4.2);
                if (inGap) {
                    return -1.2 + (2.2 * ((absZ - 22.0) / 4.0)); // Incline/Ramp
                } else {
                    return 1.0; 
                }
            }
            return 1.0; 
        }

        const groundMat = new THREE.MeshLambertMaterial({ color: 0x3a4530 });
        const wallMat = new THREE.MeshLambertMaterial({ color: 0x4a3c2b });
        const woodMat = new THREE.MeshLambertMaterial({ color: 0x3d2817 });

        const baseFloor = new THREE.Mesh(new THREE.PlaneGeometry(200, 100), groundMat);
        baseFloor.rotation.x = -Math.PI / 2;
        baseFloor.position.set(0, -1.2, 0);
        scene.add(baseFloor);
        worldMeshes.push(baseFloor);

        const nmlRegions = [
            { x: -71.5, w: 57, z: -9.75, d: 15.5 }, 
            { x: 0, w: 74, z: -9.75, d: 15.5 },     
            { x: 71.5, w: 57, z: -9.75, d: 15.5 },  
            { x: -71.5, w: 57, z: 9.75, d: 15.5 },  
            { x: 0, w: 74, z: 9.75, d: 15.5 },      
            { x: 71.5, w: 57, z: 9.75, d: 15.5 }    
        ];
        nmlRegions.forEach(reg => {
            const b = new THREE.Mesh(new THREE.BoxGeometry(reg.w, 1.2, reg.d), groundMat);
            b.position.set(reg.x, -0.6, reg.z);
            scene.add(b); worldMeshes.push(b);
            collisionObstacles.push({ minX: reg.x - reg.w/2, maxX: reg.x + reg.w/2, minZ: reg.z - reg.d/2, maxZ: reg.z + reg.d/2 });
        });

        const bfA = new THREE.Mesh(new THREE.PlaneGeometry(200, 10.75), wallMat);
        bfA.rotation.x = -Math.PI / 2; bfA.position.set(0, 1.0, -31.375);
        const bfE = new THREE.Mesh(new THREE.PlaneGeometry(200, 10.75), wallMat);
        bfE.rotation.x = -Math.PI / 2; bfE.position.set(0, 1.0, 31.375);
        scene.add(bfA, bfE); worldMeshes.push(bfA, bfE);

        const rampGeo = new THREE.PlaneGeometry(8, 4.565);
        const gapCenters = [-60, -20, 20, 60];
        const blockCenters = [-82, -40, 0, 40, 82];
        const blockWidths = [36, 32, 32, 32, 36];

        for (let i = 0; i < blockCenters.length; i++) {
            let cx = blockCenters[i];
            let w = blockWidths[i];
            
            let bA = new THREE.Mesh(new THREE.BoxGeometry(w, 2.2, 4.0), groundMat);
            bA.position.set(cx, -0.1, -24.0);
            scene.add(bA); worldMeshes.push(bA);
            collisionObstacles.push({ minX: cx - w/2, maxX: cx + w/2, minZ: -26.0, maxZ: -22.0 });
            
            let bE = new THREE.Mesh(new THREE.BoxGeometry(w, 2.2, 4.0), groundMat);
            bE.position.set(cx, -0.1, 24.0);
            scene.add(bE); worldMeshes.push(bE);
            collisionObstacles.push({ minX: cx - w/2, maxX: cx + w/2, minZ: 22.0, maxZ: 26.0 });
        }

        for (let i = 0; i < gapCenters.length; i++) {
            let rA = new THREE.Mesh(rampGeo, groundMat);
            rA.rotation.x = -Math.PI / 2 + 0.5028; 
            rA.position.set(gapCenters[i], -0.1, -24.0);
            scene.add(rA); worldMeshes.push(rA);

            let rE = new THREE.Mesh(rampGeo, groundMat);
            rE.rotation.x = -Math.PI / 2 - 0.5028; 
            rE.position.set(gapCenters[i], -0.1, 24.0);
            scene.add(rE); worldMeshes.push(rE);
        }

        function createWall(x, z, w, h, yCenter) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, 0.5), wallMat);
            mesh.position.set(x, yCenter, z);
            scene.add(mesh);
            worldMeshes.push(mesh);
            collisionObstacles.push({ minX: x - w/2, maxX: x + w/2, minZ: z - 0.25, maxZ: z + 0.25 });
        }

        createWall(-71.5, -17.75, 57, 1.4, -0.5);
        createWall(0, -17.75, 74, 1.4, -0.5);
        createWall(71.5, -17.75, 57, 1.4, -0.5);

        createWall(-71.5, 17.75, 57, 1.4, -0.5);
        createWall(0, 17.75, 74, 1.4, -0.5);
        createWall(71.5, 17.75, 57, 1.4, -0.5);

        createWall(0, -36.75, 200, 2.0, 2.0);  
        createWall(0, 36.75, 200, 2.0, 2.0);   

        // Add random jagged buttresses and dirt mounds to break up the flat, straight trench walls
        for(let i=0; i<50; i++) {
            let bx = (Math.random() - 0.5) * 190;
            let bz = Math.random() > 0.5 ? (-17.5 + (Math.random() * 1.5)) : (17.5 - (Math.random() * 1.5));
            if (Math.abs(bx + 60) < 5 || Math.abs(bx + 20) < 5 || Math.abs(bx - 20) < 5 || Math.abs(bx - 60) < 5) continue; // Keep ramps clear
            
            let bw = 1.0 + Math.random() * 4.0;
            let bh = 1.0 + Math.random() * 1.5;
            let bm = new THREE.Mesh(new THREE.BoxGeometry(bw, bh, 0.8 + Math.random()), Math.random() > 0.5 ? wallMat : groundMat);
            bm.position.set(bx, -1.2 + bh/2, bz);
            bm.rotation.y = (Math.random() - 0.5) * 0.4;
            scene.add(bm);
            worldMeshes.push(bm);
            collisionObstacles.push({ minX: bx - bw/2, maxX: bx + bw/2, minZ: bz - 0.6, maxZ: bz + 0.6 });
        }

        const sideWallGeo = new THREE.BoxGeometry(2, 10, 80);
        const sw1 = new THREE.Mesh(sideWallGeo, wallMat); sw1.position.set(-100, 0, 0);
        const sw2 = new THREE.Mesh(sideWallGeo, wallMat); sw2.position.set(100, 0, 0);
        scene.add(sw1, sw2); worldMeshes.push(sw1, sw2);
        collisionObstacles.push({ minX: -101, maxX: -99, minZ: -40, maxZ: 40 });
        collisionObstacles.push({ minX: 99, maxX: 101, minZ: -40, maxZ: 40 });

        const allyCoversFront = [], allyCoversBack = [];
        const enemyCoversFront = [], enemyCoversBack = [];
        
        const allyPathCovers = [];
        const enemyPathCovers = [];
        const midCoversAlly = [];
        const midCoversEnemy = [];

        function addCover(x, z, arr, dirZ) {
            let bw = 1.2 + Math.random() * 0.8;
            let bd = 0.8 + Math.random() * 0.4;
            let mesh = new THREE.Mesh(new THREE.BoxGeometry(bw, 1.2 + Math.random() * 0.5, bd), woodMat);
            mesh.position.set(x, -0.6, z);
            mesh.rotation.y = (Math.random() - 0.5) * 1.5; // Random messy rotation
            scene.add(mesh); worldMeshes.push(mesh);
            
            // Use the calculated dimensions to create a reliable bounding box that accounts for the messy rotation
            let maxR = Math.max(bw, bd) / 1.5; 
            collisionObstacles.push({ minX: x - maxR, maxX: x + maxR, minZ: z - maxR, maxZ: z + maxR });
            arr.push({ x: x, z: z + dirZ, y: -1.2 });
        }

        // Jittered Path Covers
        addCover(-41.5 + Math.random()*2, -12 + (Math.random()-0.5)*3, allyPathCovers, -1.2);
        addCover(-38.5 - Math.random()*2, -6 + (Math.random()-0.5)*3, allyPathCovers, -1.2);
        addCover(41.5 + Math.random()*2, -12 + (Math.random()-0.5)*3, allyPathCovers, -1.2);
        addCover(38.5 - Math.random()*2, -6 + (Math.random()-0.5)*3, allyPathCovers, -1.2);
        
        addCover(-41.5 + Math.random()*2, 12 + (Math.random()-0.5)*3, enemyPathCovers, 1.2);
        addCover(-38.5 - Math.random()*2, 6 + (Math.random()-0.5)*3, enemyPathCovers, 1.2);
        addCover(41.5 + Math.random()*2, 12 + (Math.random()-0.5)*3, enemyPathCovers, 1.2);
        addCover(38.5 - Math.random()*2, 6 + (Math.random()-0.5)*3, enemyPathCovers, 1.2);

        // Randomized Mid-field Skirmish Covers
        for (let x = -90; x <= 90; x += 5 + Math.random() * 6) {
            if (Math.abs(x + 40) < 5 || Math.abs(x - 40) < 5) continue; 
            let zOff = (Math.random() - 0.5) * 12; // Massive vertical scatter in No Man's Land
            if (Math.random() > 0.5) addCover(x, -2.5 + zOff, midCoversAlly, -1.2);
            else addCover(x, 2.5 + zOff, midCoversEnemy, 1.2);
        }

        // --- EXPLOSIVE TURRETS SETUP ---
        class Turret {
            constructor(x, y, z, isEnemy) {
                this.isEnemy = isEnemy;
                this.mesh = new THREE.Group();
                this.mesh.position.set(x, y, z); 
                
                // --- AMMO MECHANICS ---
                this.ammo = 5;
                this.maxAmmo = 5;
                this.isReloading = false;
                this.reloadTimer = 0;
                
                const base = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 0.6, 8), wallMat);
                base.position.y = -0.3;
                this.mesh.add(base);
                
                this.swivel = new THREE.Group();
                this.swivel.position.y = 0.1;
                
                // Set default forward-facing direction (Enemy = 0 (-Z), Ally = PI (+Z))
                this.baseYaw = isEnemy ? 0 : Math.PI;
                this.swivel.rotation.y = this.baseYaw;
                
                this.mesh.add(this.swivel);
                
                this.pitchGroup = new THREE.Group();
                this.swivel.add(this.pitchGroup);
                
                // Shrink receiver box so it doesn't block the screen
                const receiver = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.15, 0.4), new THREE.MeshLambertMaterial({color: 0x1a1a1a}));
                this.pitchGroup.add(receiver);
                
                const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.05, 1.0, 8), new THREE.MeshLambertMaterial({color: 0x111111}));
                barrel.rotation.x = Math.PI / 2;
                barrel.position.z = -0.5;
                this.pitchGroup.add(barrel);

                // Lower shield so we can actually see over it when aiming
                const shield = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.5, 0.05), new THREE.MeshLambertMaterial({color: 0x3a4530}));
                shield.position.set(0, -0.15, -0.2);
                this.pitchGroup.add(shield);
                
                // Adjust iron sights closer to the new receiver top
                const tRSightBase = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.02, 0.04), new THREE.MeshLambertMaterial({ color: 0x111111 }));
                tRSightBase.position.set(0, 0.08, 0.15);
                const tRSightL = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.04, 0.04), new THREE.MeshLambertMaterial({ color: 0x111111 }));
                tRSightL.position.set(-0.04, 0.11, 0.15);
                const tRSightR = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.04, 0.04), new THREE.MeshLambertMaterial({ color: 0x111111 }));
                tRSightR.position.set(0.04, 0.11, 0.15);
                const tFSight = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.06, 0.02), new THREE.MeshLambertMaterial({ color: 0x111111 }));
                tFSight.position.set(0, 0.09, -0.95);
                this.pitchGroup.add(tRSightBase, tRSightL, tRSightR, tFSight);
                
                // Dummy Shell for Reload Animation
                this.dummyShell = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.1, 8), new THREE.MeshLambertMaterial({color: 0xccaa44}));
                this.dummyShell.rotation.x = Math.PI / 2;
                this.dummyShell.visible = false;
                this.pitchGroup.add(this.dummyShell);
                
                scene.add(this.mesh);
                
                // Add all main turret parts to worldMeshes so they intercept bullets and block AI Line of Sight
                worldMeshes.push(base, shield, receiver, barrel); 
                
                // Add physical movement block so players and AI can't walk through the turret base
                collisionObstacles.push({ minX: x - 0.5, maxX: x + 0.5, minZ: z - 0.5, maxZ: z + 0.5 });
                
                turrets.push(this);
                
                this.user = null;
                this.lastShot = 0;

                // Create cover position specifically for this turret so AIs know where to stand
                const zOffset = this.isEnemy ? 1.0 : -1.0;
                this.coverPos = { x: this.mesh.position.x, z: this.mesh.position.z + zOffset, isTurret: true, turret: this };
                if (this.isEnemy) enemyCoversBack.push(this.coverPos);
                else allyCoversBack.push(this.coverPos);
            }
        }

        function buildElevatedWallAndCovers(zPos, isEnemy) {
            // Pick 1 left block (0 or 1) and 1 right block (3 or 4) to ensure they are on opposite sides
            const leftBlock = Math.random() > 0.5 ? 0 : 1;
            const rightBlock = Math.random() > 0.5 ? 3 : 4;
            const turretBlocks = [leftBlock, rightBlock];
            
            // Pick a random window (odd count index) for those chosen blocks
            const turretCounts = {};
            turretBlocks.forEach(b => {
                const possibleCounts = [1, 3, 5, 7];
                turretCounts[b] = possibleCounts[Math.floor(Math.random() * possibleCounts.length)];
            });

            for (let i = 0; i < blockCenters.length; i++) {
                const cx = blockCenters[i]; const w = blockWidths[i];
                createWall(cx, zPos, w, 0.8, 1.4);
                let startX = cx - w/2 + 2; let endX = cx + w/2 - 2; let count = 0;
                for (let x = startX; x <= endX; x += 4) {
                    if (count % 2 === 0) {
                        createWall(x, zPos, 3.5, 1.8, 1.9);
                    } else {
                        const targetZ = isEnemy ? zPos + 1.2 : zPos - 1.2;
                        // Place turrets in the randomly chosen windows
                        if (turretCounts[i] === count) {
                            new Turret(x, 2.0, zPos, isEnemy);
                        } else {
                            if (isEnemy) enemyCoversBack.push({ x: x, z: targetZ, y: 1.0 });
                            else allyCoversBack.push({ x: x, z: targetZ, y: 1.0 });
                        }
                    }
                    count++;
                }
            }
        }
        buildElevatedWallAndCovers(-26.25, false);
        buildElevatedWallAndCovers(26.25, true);

        // Scattered messy front-line cover
        for (let x = -96; x <= 96; x += 4 + Math.random() * 3) {
            if (Math.abs(x + 60) < 5 || Math.abs(x + 20) < 5 || Math.abs(x - 20) < 5 || Math.abs(x - 60) < 5) continue; 
            if (Math.abs(x + 40) < 4 || Math.abs(x - 40) < 4) continue; 

            let oxA = x + (Math.random() - 0.5) * 2;
            addCover(oxA, -18.5 + (Math.random() - 0.5), allyCoversFront, -1.2);

            let oxE = x + (Math.random() - 0.5) * 2;
            addCover(oxE, 18.5 + (Math.random() - 0.5), enemyCoversFront, 1.2);
        }

        // Random chaotic debris boxes
        for (let i = 0; i < 60; i++) {
            const x = (Math.random() - 0.5) * 180;
            const z = (Math.random() - 0.5) * 35; // Spread out across the whole mid-field
            if (Math.abs(x + 40) < 4 || Math.abs(x - 40) < 4) continue;

            let bw = 0.8 + Math.random();
            let bh = 0.5 + Math.random();
            let bd = 0.8 + Math.random();
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(bw, bh, bd), Math.random() > 0.5 ? woodMat : wallMat);
            mesh.position.set(x, getTerrainHeight(x, z) + 0.2, z); 
            mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            scene.add(mesh);
            worldMeshes.push(mesh); // Bullets can hit them
            
            // Add physical collision so players and AI can't walk through them
            let maxR = Math.max(bw, bh, bd) / 1.8;
            collisionObstacles.push({ minX: x - maxR, maxX: x + maxR, minZ: z - maxR, maxZ: z + maxR });
        }

        // Ground Craters / Scorch Marks
        const craterGeo = new THREE.PlaneGeometry(3, 3);
        const craterMat = new THREE.MeshBasicMaterial({ color: 0x1a1c14, depthWrite: false, transparent: true, opacity: 0.8 });
        for(let i=0; i<120; i++) {
            let cr = new THREE.Mesh(craterGeo, craterMat);
            let cx = (Math.random() - 0.5) * 190;
            let cz = (Math.random() - 0.5) * 36; 
            let s = 0.5 + Math.random() * 2;
            cr.scale.set(s, s, s);
            cr.rotation.x = -Math.PI / 2;
            cr.rotation.z = Math.random() * Math.PI;
            cr.position.set(cx, getTerrainHeight(cx, cz) + 0.02, cz);
            scene.add(cr);
        }

        // --- ATMOSPHERIC VISUALS ---
        const ashGeo = new THREE.BufferGeometry();
        const ashCount = 1000;
        const ashPos = new Float32Array(ashCount * 3);
        for(let i = 0; i < ashCount * 3; i += 3) {
            ashPos[i] = (Math.random() - 0.5) * 200;
            ashPos[i+1] = Math.random() * 10;
            ashPos[i+2] = (Math.random() - 0.5) * 100;
        }
        ashGeo.setAttribute('position', new THREE.BufferAttribute(ashPos, 3));
        const ashMat = new THREE.PointsMaterial({ color: 0x666666, size: 0.15, transparent: true, opacity: 0.5 });
        const ashParticles = new THREE.Points(ashGeo, ashMat);
        scene.add(ashParticles);

        const horizonLights = [];
        for(let i = 0; i < 6; i++) {
            let l = new THREE.PointLight(0xffaa55, 0, 150);
            l.position.set((Math.random() - 0.5) * 180, 5, (i % 2 === 0 ? 1 : -1) * (40 + Math.random() * 20));
            scene.add(l);
            horizonLights.push({light: l, timer: 0});
        }

        function resolveObstacles(pos, radius) {
            for (let obs of collisionObstacles) {
                let closestX = Math.max(obs.minX, Math.min(pos.x, obs.maxX));
                let closestZ = Math.max(obs.minZ, Math.min(pos.z, obs.maxZ));
                
                if (pos.x >= obs.minX && pos.x <= obs.maxX && pos.z >= obs.minZ && pos.z <= obs.maxZ) {
                    let dLeft = pos.x - obs.minX;
                    let dRight = obs.maxX - pos.x;
                    let dTop = pos.z - obs.minZ;
                    let dBottom = obs.maxZ - pos.z;

                    let minD = Math.min(dLeft, dRight, dTop, dBottom);
                    if (minD === dLeft) pos.x = obs.minX - radius;
                    else if (minD === dRight) pos.x = obs.maxX + radius;
                    else if (minD === dTop) pos.z = obs.minZ - radius;
                    else if (minD === dBottom) pos.z = obs.maxZ + radius;
                } else {
                    let dx = pos.x - closestX;
                    let dz = pos.z - closestZ;
                    let distSq = dx * dx + dz * dz;
                    if (distSq < radius * radius && distSq > 0.0001) {
                        let dist = Math.sqrt(distSq);
                        let overlap = radius - dist;
                        pos.x += (dx / dist) * overlap;
                        pos.z += (dz / dist) * overlap;
                    }
                }
            }
        }

        const ambient = new THREE.AmbientLight(0x404040, 1.5);
        scene.add(ambient);
        const dirLight = new THREE.DirectionalLight(0xffddbb, 0.8);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // --- PLAYER & CAMERA ---
        const playerRoot = new THREE.Group();
        playerRoot.position.set(0, getTerrainHeight(0, -20), -20);
        scene.add(playerRoot);
        const leanObject = new THREE.Group(); leanObject.position.y = 1.5; playerRoot.add(leanObject);
        const pitchObject = new THREE.Group(); leanObject.add(pitchObject); pitchObject.add(camera);

        const playerAI = {
            isPlayer: true, hp: 10, dead: false,
            takeDamage: function(amt, attacker) {
                if (this.dead) return;
                playNearMissSound(); 
                triggerShellShock(1.0); // Muffle hearing when hit
                playerHp -= amt;
                document.getElementById('healthbar').style.width = (playerHp * 10) + '%';
                document.getElementById('hurt-overlay').style.opacity = 0.5;
                if (playerHp <= 0) {
                    this.dead = true;
                    if (mountedTurret) {
                        mountedTurret.user = null;
                        mountedTurret = null;
                        weaponContainer.visible = true;
                    }
                    document.getElementById('hurt-overlay').style.background = 'black';
                    document.getElementById('hurt-overlay').style.opacity = 1.0;
                    setTimeout(() => {
                        if (document.pointerLockElement) document.exitPointerLock();
                    }, 2000);
                }
            }
        };
        playerAI.mesh = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.8, 0.8), new THREE.MeshBasicMaterial({ visible: false }));
        playerAI.mesh.userData.ai = playerAI; playerAI.mesh.position.y = 0.9; playerRoot.add(playerAI.mesh);

        // --- WEAPON SYSTEM ---
        const weaponContainer = new THREE.Group(); camera.add(weaponContainer); weaponContainer.position.set(0.2, -0.2, -0.4);
        const weaponsData = [
            { id: 'rifle', name: '1: Rifle', type: 'semi', fireRate: 250, recoilPitch: 0.0066, recoilZ: 0.033, barrelLen: -0.8, soundPitch: 1.0, alignY: -0.06 },
            { id: 'mg', name: '2: Machine Gun', type: 'auto', fireRate: 100, recoilPitch: 0.012, recoilZ: 0.05, barrelLen: -0.9, soundPitch: 1.1, alignY: -0.08 },
            { id: 'sniper', name: '3: Sniper Rifle', type: 'semi', fireRate: 1500, recoilPitch: 0.0198, recoilZ: 0.1, barrelLen: -1.2, soundPitch: 0.7, alignY: 0 } // Sniper fireRate increased to 1.5s for bolt action
        ];
        let currentWeaponIndex = 0; let sniperZoomLevel = 4;
        let snBoltGroup; // Expose globally for bolt animation
        let sniperNeedsRechamber = false; // Track uncompleted bolting
        let sniperRechamberStartTime = 0;

        const modelRifle = new THREE.Group();
        const rBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.015, 0.8, 8), new THREE.MeshLambertMaterial({ color: 0x222222 })); rBarrel.rotation.x = Math.PI / 2; rBarrel.position.set(0, 0, -0.4);
        const rReceiver = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.06, 0.25), new THREE.MeshLambertMaterial({ color: 0x1a1a1a })); rReceiver.position.set(0, 0.01, -0.15);
        const rStock = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.12, 0.4), new THREE.MeshLambertMaterial({ color: 0x4a2e15 })); rStock.position.set(0, -0.03, 0.1);
        const rFSight = new THREE.Mesh(new THREE.BoxGeometry(0.005, 0.04, 0.01), new THREE.MeshLambertMaterial({ color: 0x111111 })); rFSight.position.set(0, 0.04, -0.75); 
        const rRSightBase = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.02, 0.02), new THREE.MeshLambertMaterial({ color: 0x111111 })); rRSightBase.position.set(0, 0.03, -0.2); 
        const rRSightL = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.02, 0.02), new THREE.MeshLambertMaterial({ color: 0x111111 })); rRSightL.position.set(-0.015, 0.05, -0.2); 
        const rRSightR = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.02, 0.02), new THREE.MeshLambertMaterial({ color: 0x111111 })); rRSightR.position.set(0.015, 0.05, -0.2); 
        modelRifle.add(rBarrel, rReceiver, rStock, rFSight, rRSightBase, rRSightL, rRSightR);

        const modelMG = new THREE.Group();
        const mgBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.018, 0.02, 0.9, 8), new THREE.MeshLambertMaterial({ color: 0x1a1a1a })); mgBarrel.rotation.x = Math.PI / 2; mgBarrel.position.set(0, 0, -0.45);
        const mgReceiver = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.08, 0.35), new THREE.MeshLambertMaterial({ color: 0x111111 })); mgReceiver.position.set(0, 0.01, -0.1);
        const mgMag = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.12, 0.1), new THREE.MeshLambertMaterial({ color: 0x2a3a2a })); mgMag.position.set(-0.04, -0.05, -0.1);
        const mgStock = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.1, 0.3), new THREE.MeshLambertMaterial({ color: 0x3a2e15 })); mgStock.position.set(0, -0.02, 0.15);
        const mgBipod = new THREE.Mesh(new THREE.CylinderGeometry(0.005, 0.005, 0.15), new THREE.MeshLambertMaterial({color: 0x111111})); mgBipod.position.set(0, -0.05, -0.8); mgBipod.rotation.x = Math.PI/4;
        
        // Cleaned up front sight connecting to the barrel, no bulky rear sights
        const mgFSight = new THREE.Mesh(new THREE.BoxGeometry(0.005, 0.062, 0.01), new THREE.MeshLambertMaterial({ color: 0x111111 })); mgFSight.position.set(0, 0.049, -0.85); 
        
        modelMG.add(mgBarrel, mgReceiver, mgMag, mgStock, mgBipod, mgFSight);

        const modelSniper = new THREE.Group();
        const snBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.015, 1.2, 8), new THREE.MeshLambertMaterial({ color: 0x222222 })); snBarrel.rotation.x = Math.PI / 2; snBarrel.position.set(0, 0, -0.6);
        const snReceiver = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.05, 0.3), new THREE.MeshLambertMaterial({ color: 0x1a1a1a })); snReceiver.position.set(0, 0, -0.15);
        const snStock = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.1, 0.5), new THREE.MeshLambertMaterial({ color: 0x4a2e15 })); snStock.position.set(0, -0.03, 0.15);
        const snScope = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.3, 12), new THREE.MeshLambertMaterial({ color: 0x111111 })); snScope.rotation.x = Math.PI / 2; snScope.position.set(0, 0.06, -0.15);
        
        // Assemble the Bolt Action parts
        snBoltGroup = new THREE.Group();
        snBoltGroup.position.set(0, 0.015, -0.05); 
        const snBoltBody = new THREE.Mesh(new THREE.CylinderGeometry(0.008, 0.008, 0.18, 8), new THREE.MeshLambertMaterial({ color: 0x555555 })); snBoltBody.rotation.x = Math.PI / 2; 
        const snBoltHandle = new THREE.Mesh(new THREE.CylinderGeometry(0.003, 0.003, 0.06), new THREE.MeshLambertMaterial({ color: 0x333333 })); snBoltHandle.rotation.z = Math.PI / 2; snBoltHandle.position.set(0.03, 0, 0.07); 
        const snBoltKnob = new THREE.Mesh(new THREE.SphereGeometry(0.008, 8, 8), new THREE.MeshLambertMaterial({ color: 0x111111 })); snBoltKnob.position.set(0.06, 0, 0.07); 
        snBoltGroup.add(snBoltBody, snBoltHandle, snBoltKnob);
        
        modelSniper.add(snBarrel, snReceiver, snStock, snScope, snBoltGroup);

        weaponContainer.add(modelRifle, modelMG, modelSniper); modelMG.visible = false; modelSniper.visible = false;

        function switchWeapon(index) {
            if (index === currentWeaponIndex) return;
            currentWeaponIndex = index;
            modelRifle.visible = (index === 0); modelMG.visible = (index === 1); modelSniper.visible = (index === 2);
            document.getElementById('weapon-indicator').innerText = weaponsData[index].name;
            fpFlashGroup.position.z = weaponsData[index].barrelLen - 0.05; fpFlashLight.position.z = weaponsData[index].barrelLen - 0.05;
            
            // Restart the rechambering process if switching to the sniper and it still needs it!
            if (index === 2 && sniperNeedsRechamber) {
                sniperRechamberStartTime = performance.now();
            }
        }

        // --- PROCEDURAL MUZZLE FLASH TEXTURE ---
        const flashTexCanvas = document.createElement('canvas'); 
        flashTexCanvas.width = 16; flashTexCanvas.height = 16;
        const fctx = flashTexCanvas.getContext('2d');
        
        // Blocky, pixel-art style flash to match the primitive 3D aesthetic
        fctx.fillStyle = "rgba(200, 50, 0, 0.5)"; 
        fctx.fillRect(6, 2, 4, 12); fctx.fillRect(2, 6, 12, 4);
        
        fctx.fillStyle = "rgba(255, 120, 0, 0.8)"; 
        fctx.fillRect(7, 3, 2, 10); fctx.fillRect(3, 7, 10, 2); fctx.fillRect(5, 5, 6, 6);
        
        fctx.fillStyle = "rgba(255, 220, 100, 1)"; 
        fctx.fillRect(6, 6, 4, 4);
        
        fctx.fillStyle = "rgba(255, 255, 255, 1)"; 
        fctx.fillRect(7, 7, 2, 2);

        const flashTexture = new THREE.CanvasTexture(flashTexCanvas);
        flashTexture.magFilter = THREE.NearestFilter; // Preserve hard pixel edges
        flashTexture.minFilter = THREE.NearestFilter;

        const fpFlashMaterial = new THREE.MeshBasicMaterial({ map: flashTexture, transparent: true, opacity: 0, depthWrite: false, blending: THREE.AdditiveBlending });
        const fpFlashGroup = new THREE.Group(); 
        fpFlashGroup.add(new THREE.Mesh(new THREE.PlaneGeometry(0.3, 0.3), fpFlashMaterial), new THREE.Mesh(new THREE.PlaneGeometry(0.3, 0.3), fpFlashMaterial));
        fpFlashGroup.children[0].rotation.z = Math.PI / 4; fpFlashGroup.children[1].rotation.z = -Math.PI / 4; fpFlashGroup.position.set(0, 0, -0.85);
        const fpFlashLight = new THREE.PointLight(0xffddaa, 0, 5); fpFlashLight.position.set(0, 0, -0.85);
        weaponContainer.add(fpFlashGroup, fpFlashLight);

        // --- EFFECTS ---
        const flashes = [];
        for (let i = 0; i < 20; i++) {
            const f = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 0.5), new THREE.MeshBasicMaterial({ map: flashTexture, transparent: true, opacity: 0, depthWrite: false, blending: THREE.AdditiveBlending, side: THREE.DoubleSide }));
            scene.add(f); flashes.push({ mesh: f, life: 0 });
        }
        function showMuzzleFlash(pos, dir) {
            const f = flashes.find(fl => fl.life <= 0);
            if (f) { 
                f.life = 0.05; 
                f.mesh.position.copy(pos).add(dir.clone().multiplyScalar(0.4)); 
                
                // Fix: Orient the flash orthogonally to the barrel direction, not the camera
                f.mesh.lookAt(f.mesh.position.clone().add(dir)); 
                
                f.mesh.rotateZ(Math.random() * Math.PI * 2); // Spin randomly on spawn
                
                // Randomly flip and scale slightly to make the single texture look highly varied
                const sx = (Math.random() > 0.5 ? 1 : -1) * (0.7 + Math.random() * 0.6);
                const sy = (Math.random() > 0.5 ? 1 : -1) * (0.7 + Math.random() * 0.6);
                f.mesh.scale.set(sx, sy, 1);
                
                f.mesh.material.opacity = 1; 
            }
        }

        const explosions = [];
        const expGeo = new THREE.SphereGeometry(1, 16, 16); // Higher poly for smoother shockwave
        const expMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 1, depthWrite: false, blending: THREE.AdditiveBlending });
        for(let i = 0; i < 15; i++) {
            const m = new THREE.Mesh(expGeo, expMat.clone());
            m.visible = false;
            const l = new THREE.PointLight(0xff6600, 0, 40); // Dramatic dynamic lighting flash
            scene.add(m);
            scene.add(l);
            explosions.push({ mesh: m, light: l, life: 0, maxLife: 0.5 });
        }
        function createExplosion(pos) {
            const exp = explosions.find(e => e.life <= 0);
            if (exp) {
                exp.life = exp.maxLife;
                exp.mesh.position.copy(pos);
                exp.light.position.copy(pos);
                exp.visible = true;
                exp.mesh.visible = true;
                exp.mesh.material.opacity = 1;
                exp.light.intensity = 20.0;
            }
        }

        const impacts = [];
        const impactGeo = new THREE.PlaneGeometry(0.3, 0.3); const impactMat = new THREE.MeshBasicMaterial({ color: 0x887755, transparent: true, opacity: 1, depthWrite: false });
        for (let i = 0; i < 40; i++) { const m = new THREE.Mesh(impactGeo, impactMat.clone()); m.visible = false; scene.add(m); impacts.push({ mesh: m, life: 0 }); }
        function createImpact(pos, normal) {
            const imp = impacts.find(i => i.life <= 0);
            if (imp) { imp.life = 0.2; imp.mesh.position.copy(pos).add(normal.clone().multiplyScalar(0.02)); imp.mesh.lookAt(pos.clone().add(normal)); imp.mesh.scale.set(0.1, 0.1, 0.1); imp.mesh.material.opacity = 1; imp.mesh.visible = true; }
        }

        const tracers = []; const tracerGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -8)]);
        for (let i = 0; i < 100; i++) { const t = new THREE.Line(tracerGeo, new THREE.LineBasicMaterial({ color: 0xffcc88 })); t.visible = false; scene.add(t); tracers.push({ mesh: t, life: 0, dir: new THREE.Vector3(), traveled: 0, maxDist: 200 }); }
        function createTracer(start, dir, maxDist = 200) {
            const t = tracers.find(tr => tr.life <= 0);
            if (t) { t.life = 0.8; t.mesh.position.copy(start); t.dir.copy(dir); t.mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, -1), dir); t.mesh.visible = true; t.traveled = 0; t.maxDist = maxDist; }
        }

        // --- INPUT & CONTROLS ---
        const keys = { w: false, a: false, s: false, d: false, shift: false, z: false, c: false, q: false, e: false, space: false, lmb: false };
        let lastQPress = 0, lastEPress = 0; let qToggled = false, eToggled = false;
        let lmbJustPressed = false; let isCrouched = false; let isProne = false; let slideTimer = 0; let slideSpeed = 0; let slideDir = new THREE.Vector3(); let yaw = 0; let pitch = 0; let playerHp = 10; let initialized = false; let mgHeat = 0; let mgOverheated = false; let gameMode = 'endless';
        let playerKills = 0;
        
        let allyReserves = 0;
        let enemyReserves = 0;

        document.getElementById('soldier-count').addEventListener('input', (e) => { document.getElementById('soldier-count-display').innerText = e.target.value; });
        document.getElementById('active-count').addEventListener('input', (e) => { document.getElementById('active-count-display').innerText = e.target.value; });

        function startGame(mode) {
            gameMode = mode;
            if (!initialized) { initAudio(); startAmbientBattle(); initialized = true; }
            playerHp = 10; playerAI.dead = false; document.getElementById('healthbar').style.width = '100%'; document.getElementById('hurt-overlay').style.opacity = 0;
            document.getElementById('hurt-overlay').style.background = 'red'; document.getElementById('victory-screen').style.display = 'none';
            playerRoot.position.set(0, getTerrainHeight(0, -20), -20); yaw = 0; pitch = 0; isCrouched = false; isProne = false; slideTimer = 0; mgHeat = 0; mgOverheated = false;
            qToggled = false; eToggled = false;
            
            playerKills = 0;
            document.getElementById('kill-count-indicator').innerText = 'Kills: 0';
            sniperNeedsRechamber = false; // Reset bolt state on new game
            sniperZoomLevel = 4; // Reset zoom to default 4x
            
            if (mountedTurret) {
                mountedTurret.user = null;
                mountedTurret = null;
                weaponContainer.visible = true;
            }
            turrets.forEach(t => t.user = null); // Reset all turrets

            const totalCount = parseInt(document.getElementById('soldier-count').value, 10) || 500;
            const activeCount = parseInt(document.getElementById('active-count').value, 10) || 25;

            if (mode === 'elimination') {
                const initialSpawn = Math.min(totalCount, activeCount);
                allyReserves = totalCount - initialSpawn;
                enemyReserves = totalCount - initialSpawn;
                spawnSoldiers(initialSpawn);
                document.getElementById('reserves-indicator').style.display = 'block';
            } else {
                spawnSoldiers(activeCount);
                document.getElementById('reserves-indicator').style.display = 'none';
            }

            if (!document.pointerLockElement) document.body.requestPointerLock().catch(err => console.warn(err));
        }

        document.getElementById('btn-endless').addEventListener('click', () => startGame('endless'));
        document.getElementById('btn-elimination').addEventListener('click', () => startGame('elimination'));
        document.getElementById('btn-victory-menu').addEventListener('click', () => { document.getElementById('victory-screen').style.display = 'none'; document.getElementById('instructions').style.display = 'flex'; });
        document.addEventListener('pointerlockchange', () => { if (document.getElementById('victory-screen').style.display === 'flex') return; document.getElementById('instructions').style.display = document.pointerLockElement ? 'none' : 'flex'; });
        document.addEventListener('mousemove', (e) => { 
            if (document.pointerLockElement && !playerAI.dead) { 
                yaw -= e.movementX * 0.002; 
                pitch -= e.movementY * 0.002; 
                pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch)); 
                
                // Limit turret traversal to 90 degrees left and right
                if (mountedTurret) {
                    let diff = yaw - mountedTurret.baseYaw;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    
                    if (diff > Math.PI / 2) diff = Math.PI / 2;
                    if (diff < -Math.PI / 2) diff = -Math.PI / 2;
                    
                    yaw = mountedTurret.baseYaw + diff;
                }

                playerRoot.rotation.y = yaw; 
                pitchObject.rotation.x = pitch; 
            } 
        });

        document.addEventListener('keydown', e => {
            const code = e.code;
            if (code === 'KeyW') keys.w = true; if (code === 'KeyA') keys.a = true; if (code === 'KeyS') keys.s = true; if (code === 'KeyD') keys.d = true;
            if (code === 'ShiftLeft' || code === 'ShiftRight') keys.shift = true; 
            
            if (code === 'KeyQ') {
                if (!keys.q) {
                    const now = performance.now();
                    if (qToggled) qToggled = false;
                    else if (now - lastQPress < 300) { qToggled = true; lastQPress = 0; }
                    else lastQPress = now;
                }
                keys.q = true; eToggled = false;
            }
            if (code === 'KeyE') {
                if (!keys.e) {
                    const now = performance.now();
                    if (eToggled) eToggled = false;
                    else if (now - lastEPress < 300) { eToggled = true; lastEPress = 0; }
                    else lastEPress = now;
                }
                keys.e = true; qToggled = false;
            }
            if (code === 'Space') keys.space = true;

            if (code === 'KeyC') { 
                if (!keys.c) { 
                    // Prevent sliding if already crouched
                    let isSprintMoving = (keys.w || keys.a || keys.s || keys.d) && keys.shift && !isProne && !isCrouched && !mountedTurret;
                    if (slideTimer > 0) {
                        slideTimer = 0; // cancel active slide
                        isCrouched = false;
                    } else if (isSprintMoving) {
                        isCrouched = true; isProne = false; // End in crouch
                        slideTimer = 0.75; slideSpeed = 16.0;
                        let mDir = new THREE.Vector3();
                        if (keys.w) mDir.z -= 1; if (keys.s) mDir.z += 1; if (keys.a) mDir.x -= 1; if (keys.d) mDir.x += 1;
                        if (mDir.lengthSq() > 0) mDir.normalize(); mDir.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
                        slideDir.copy(mDir);
                    } else {
                        if (isProne) { isProne = false; isCrouched = true; } // From prone to crouch
                        else if (isCrouched) { isCrouched = false; } // Stand up if already crouched
                        else { isCrouched = !isCrouched; }
                    }
                } 
                keys.c = true; 
            }
            if (code === 'KeyZ') { 
                if (!keys.z) {
                    slideTimer = 0;
                    if (isProne) { isProne = false; isCrouched = true; }
                    else { isProne = true; isCrouched = false; }
                } 
                keys.z = true; 
            }
            if (code === 'Digit1') switchWeapon(0); if (code === 'Digit2') switchWeapon(1); if (code === 'Digit3') switchWeapon(2);
            if (code === 'KeyF' && currentWeaponIndex === 2 && (keys.rmb || keys.space)) sniperZoomLevel = Math.min(10, sniperZoomLevel + 1);
            if (code === 'KeyG' && currentWeaponIndex === 2 && (keys.rmb || keys.space)) sniperZoomLevel = Math.max(2, sniperZoomLevel - 1);
            
            // Manual Turret Reloading
            if (code === 'KeyR') {
                if (mountedTurret && !mountedTurret.isReloading && mountedTurret.ammo < mountedTurret.maxAmmo) {
                    mountedTurret.isReloading = true;
                    mountedTurret.reloadTimer = 0.6; // Start reload
                }
            }

            if (code === 'KeyT' && !playerAI.dead) {
                if (mountedTurret) {
                    mountedTurret.user = null;
                    mountedTurret = null;
                    // Restore weapon visibility
                    if (currentWeaponIndex === 2) {
                        modelSniper.visible = true; 
                    } 
                    weaponContainer.visible = true;
                } else {
                    let nearest = null;
                    let minDist = 3.0;
                    turrets.forEach(t => {
                        // Allow mounting if unoccupied OR if occupied by a friendly AI
                        const canClaim = !t.user || (t.user && !t.user.isEnemy && t.user !== playerAI);
                        if (canClaim && playerRoot.position.distanceTo(t.mesh.position) < minDist) {
                            nearest = t;
                            minDist = playerRoot.position.distanceTo(t.mesh.position);
                        }
                    });
                    if (nearest) {
                        mountedTurret = nearest;
                        nearest.user = playerAI;
                        weaponContainer.visible = false; // Hide hand weapons when mounted
                        isCrouched = false; isProne = false; slideTimer = 0; // Force stand up to see over turret
                        // Smoothly align player orientation to turret's current orientation
                        yaw = nearest.swivel.rotation.y;
                        pitch = nearest.pitchGroup.rotation.x;
                    }
                }
            }
        });

        document.addEventListener('keyup', e => {
            const code = e.code;
            if (code === 'KeyW') keys.w = false; if (code === 'KeyA') keys.a = false; if (code === 'KeyS') keys.s = false; if (code === 'KeyD') keys.d = false;
            if (code === 'ShiftLeft' || code === 'ShiftRight') keys.shift = false; if (code === 'KeyQ') keys.q = false; if (code === 'KeyE') keys.e = false; if (code === 'Space') keys.space = false;
            if (code === 'KeyZ') keys.z = false; if (code === 'KeyC') keys.c = false;
        });

        document.addEventListener('mousedown', e => { if (!document.pointerLockElement) return; if (e.button === 2) keys.rmb = true; if (e.button === 0) { keys.lmb = true; lmbJustPressed = true; } });
        document.addEventListener('mouseup', e => { if (e.button === 2) keys.rmb = false; if (e.button === 0) keys.lmb = false; });
        document.addEventListener('contextmenu', e => e.preventDefault());

        const raycaster = new THREE.Raycaster(); 
        const lastShotTimes = [0, 0, 0]; // Track delays independently per weapon

        function shootPlayer() {
            if (playerAI.dead || (currentWeaponIndex === 1 && mgOverheated)) return;
            const now = performance.now(); const wep = weaponsData[currentWeaponIndex];
            
            if (currentWeaponIndex === 2) {
                if (sniperNeedsRechamber) return; // Cannot shoot if the bolt needs to be pulled
            } else {
                if (now - lastShotTimes[currentWeaponIndex] < wep.fireRate) return;
            }
            
            lastShotTimes[currentWeaponIndex] = now;
            if (currentWeaponIndex === 1) { mgHeat += 8; if (mgHeat >= 100) { mgHeat = 100; mgOverheated = true; } }
            
            if (currentWeaponIndex === 2) {
                sniperNeedsRechamber = true;
                sniperRechamberStartTime = now;
            }

            playSoundFile('gunshot', wep.soundPitch, wep.id === 'sniper' ? 1.5 : 1.0);
            
            const barrelPos = new THREE.Vector3(0, 0, wep.barrelLen).applyMatrix4(weaponContainer.matrixWorld);
            const camDir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
            if (wep.type === 'auto') { camDir.x += (Math.random() - 0.5) * 0.015; camDir.y += (Math.random() - 0.5) * 0.015; camDir.normalize(); }

            fpFlashMaterial.opacity = 1.0; fpFlashLight.intensity = 2.0; 
            fpFlashGroup.rotation.z = Math.random() * Math.PI;
            
            // Randomize first person flash scale and flip
            let fsx = (Math.random() > 0.5 ? 1 : -1) * (0.8 + Math.random() * 0.4);
            let fsy = (Math.random() > 0.5 ? 1 : -1) * (0.8 + Math.random() * 0.4);
            fpFlashGroup.scale.set(fsx, fsy, 1);

            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            if (wep.type === 'auto') raycaster.set(camera.getWorldPosition(new THREE.Vector3()), camDir);
            
            // Allow intersecting with ANY AI on the field
            const allAIMeshes = [...enemies.map(e => e.mesh), ...allies.map(a => a.mesh)];
            const intersects = raycaster.intersectObjects([...worldMeshes, ...allAIMeshes], true);
            
            let hitDistance = 200;
            if (intersects.length > 0) {
                const hit = intersects[0]; hitDistance = hit.distance; const hitObj = hit.object;
                
                // If it hits an AI (friend or foe)
                if (hitObj.userData.ai) {
                    const isHead = hitObj.name === "head";
                    hitObj.userData.ai.takeDamage(isHead ? 99 : (1 * (currentWeaponIndex === 2 ? 5 : 1)), playerAI);
                    const marker = document.getElementById('hit-marker'); marker.style.opacity = 1; marker.style.borderColor = isHead ? 'red' : 'white';
                    setTimeout(() => marker.style.opacity = 0, 100);
                    playPositionalSound(hit.point, 'impact');
                } else {
                    let normal = new THREE.Vector3(0, 1, 0);
                    if (hit.face) normal.copy(hit.face.normal).applyMatrix3(new THREE.Matrix3().getNormalMatrix(hitObj.matrixWorld)).normalize();
                    createImpact(hit.point, normal);
                    playPositionalSound(hit.point, 'impact');
                    
                    // Tracer Ricochet
                    if (Math.random() < 0.3) {
                        let reflection = camDir.clone().sub(normal.clone().multiplyScalar(2 * camDir.dot(normal))).normalize();
                        reflection.x += (Math.random() - 0.5) * 0.3; reflection.y += Math.random() * 0.4; reflection.z += (Math.random() - 0.5) * 0.3; reflection.normalize();
                        createTracer(hit.point, reflection, 60);
                        
                        // ONLY hear ricochets near the camera
                        if (camera.getWorldPosition(new THREE.Vector3()).distanceToSquared(hit.point) < 64.0) {
                            playSoundFile('whiz', 1.5 + Math.random() * 0.5, 0.2); 
                        }
                    }
                }
            }

            if (Math.random() < 0.25) createTracer(barrelPos, camDir, hitDistance);
            const bulletRay = new THREE.Ray(barrelPos, camDir);
            let closestPt = new THREE.Vector3();
            
            // Whiz / Suppression check against EVERYONE
            [...enemies, ...allies].forEach(e => { 
                if (!e.dead) {
                    const ePos = e.mesh.position.clone().add(new THREE.Vector3(0, 1.0, 0));
                    bulletRay.closestPointToPoint(ePos, closestPt);
                    // Ensure the bullet hasn't hit a wall BEFORE passing the entity
                    if (barrelPos.distanceTo(closestPt) < hitDistance + 1.0) {
                        if (closestPt.distanceToSquared(ePos) < 16.0) e.alert(playerAI);
                    }
                }
            });

            // Recoil & Jostle
            let actualRecoil = wep.recoilPitch * (0.8 + Math.random() * 0.4); // Slight randomization to vertical climb
            pitch += actualRecoil; 
            pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch)); 
            pitchObject.rotation.x = pitch;
            
            if (wep.type === 'auto') {
                // Horizontal camera kick
                yaw += (Math.random() - 0.5) * actualRecoil * 1.5;
                playerRoot.rotation.y = yaw;
                
                // Violent visual weapon twist
                weaponContainer.rotation.z += (Math.random() - 0.5) * 0.15;
                weaponContainer.rotation.x -= Math.random() * 0.05;
                weaponContainer.rotation.y += (Math.random() - 0.5) * 0.05;
            }

            weaponContainer.position.z += wep.recoilZ;
        }

        function shootTurret(turret, shooter) {
            // Check Reload Logic
            if (turret.isReloading || turret.ammo <= 0) return; 

            const now = performance.now();
            const cooldown = (shooter && shooter.isPlayer) ? 600 : 1800; // Player shoots much faster
            if (now - turret.lastShot < cooldown) return; 
            turret.lastShot = now;
            turret.ammo--; // Reduce ammo

            // Tip of the turret barrel
            const barrelPos = new THREE.Vector3(0, 0, -1.1).applyMatrix4(turret.pitchGroup.matrixWorld);
            const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(turret.pitchGroup.getWorldQuaternion(new THREE.Quaternion()));

            // Heavy weapon spread
            let spread = 0.02;
            if (shooter && !shooter.isPlayer) {
                spread = 0.15; // Give AIs terrible aim with the turret so they don't laser beam other AIs
            }
            
            dir.x += (Math.random() - 0.5) * spread;
            dir.y += (Math.random() - 0.5) * spread;
            dir.z += (Math.random() - 0.5) * spread;
            dir.normalize();

            showMuzzleFlash(barrelPos, dir);
            playPositionalSound(barrelPos, 'gunshot'); 
            
            turret.pitchGroup.position.z += 0.3; // Heavy visual recoil

            raycaster.set(barrelPos, dir);
            const allAIMeshes = [...enemies.map(e => e.mesh), ...allies.map(a => a.mesh), playerAI.mesh];
            const intersects = raycaster.intersectObjects([...worldMeshes, ...allAIMeshes], true);

            let hitDistance = 200;
            if (intersects.length > 0) {
                const hit = intersects[0];
                hitDistance = hit.distance;
                
                let normal = hit.face ? hit.face.normal.clone().applyMatrix3(new THREE.Matrix3().getNormalMatrix(hit.object.matrixWorld)).normalize() : new THREE.Vector3(0, 1, 0);
                
                // Extra visual impact debris for explosive hit
                createImpact(hit.point, normal);
                for(let i=0; i<8; i++){
                    let debrisOffset = new THREE.Vector3((Math.random()-0.5)*5, Math.random()*4, (Math.random()-0.5)*5);
                    createImpact(hit.point.clone().add(debrisOffset), normal);
                }
                
                // Trigger the new animated explosion sphere & dynamic light!
                createExplosion(hit.point);

                playPositionalSound(hit.point, 'artillery');
                
                // Trigger intense screen shake based on proximity
                const distToPlayer = camera.getWorldPosition(new THREE.Vector3()).distanceTo(hit.point);
                if (distToPlayer < 50) {
                    const shakeAmt = 1.0 - (distToPlayer / 50);
                    currentScreenShake = Math.max(currentScreenShake, shakeAmt * 0.6);
                }

                // High Explosive AoE Damage
                const explosionRadius = 4.0;
                const hitPool = [...allies, ...enemies, playerAI];
                hitPool.forEach(t => {
                    if (!t.dead) {
                        const posOffset = t.isPlayer ? ((isProne || slideTimer > 0) ? 0.15 : (isCrouched ? 0.4 : 1.0)) : (1.0 - (t.crouchT * 0.45));
                        const pos = t.isPlayer ? playerRoot.position.clone() : t.mesh.position.clone(); 
                        pos.y += posOffset;
                        
                        if (pos.distanceTo(hit.point) < explosionRadius) {
                            t.takeDamage(10, shooter); 
                        }
                    }
                });
                
                // Trigger player shell shock if explosion is close
                if (camera.getWorldPosition(new THREE.Vector3()).distanceTo(hit.point) < 8.0) {
                    triggerShellShock(1.5);
                }
            }

            createTracer(barrelPos, dir, hitDistance);
            
            // Whiz / Suppression check
            const bulletRay = new THREE.Ray(barrelPos, dir);
            const hitPool = [...allies, ...enemies, playerAI];
            let closestPt = new THREE.Vector3();
            hitPool.forEach(t => {
                if (!t.dead) {
                    const posOffset = t.isPlayer ? ((isProne || slideTimer > 0) ? 0.15 : (isCrouched ? 0.4 : 1.0)) : (1.0 - (t.crouchT * 0.45));
                    const pos = t.isPlayer ? playerRoot.position.clone() : t.mesh.position.clone(); pos.y += posOffset;
                    
                    bulletRay.closestPointToPoint(pos, closestPt);
                    const distAlongRay = barrelPos.distanceTo(closestPt);
                    
                    if (distAlongRay < hitDistance + 1.0) {
                        const distSq = closestPt.distanceToSquared(pos);
                        if (!t.isPlayer) {
                            if (distSq < 16.0) t.alert(shooter); 
                        } else {
                            if (distSq < 2.0) playNearMissSound(); 
                        }
                    }
                }
            });
        }

        // Helper function to prevent AI from spawning in the player's field of view
        function isSpotVisibleToPlayer(spot) {
            const camPos = camera.getWorldPosition(new THREE.Vector3());
            const spotPos = new THREE.Vector3(spot.x, spot.y + 1.0, spot.z); // Target chest/head height
            const dir = spotPos.clone().sub(camPos).normalize();
            const dist = camPos.distanceTo(spotPos);

            const camForward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
            if (camForward.dot(dir) < 0.2) return false; // Out of FOV / Behind player

            const tempRaycaster = new THREE.Raycaster(camPos, dir);
            const intersects = tempRaycaster.intersectObjects(worldMeshes, false);
            return !(intersects.length > 0 && intersects[0].distance < dist);
        }

        // --- AI SYSTEM ---
        const allyMat = new THREE.MeshLambertMaterial({ color: 0x3b5030 }); const enemyMat = new THREE.MeshLambertMaterial({ color: 0x5a3030 });
        const skinMat = new THREE.MeshLambertMaterial({ color: 0xdcb897 }); const helmetMatEnemy = new THREE.MeshLambertMaterial({ color: 0x3a2a2a }); const helmetMatAlly = new THREE.MeshLambertMaterial({ color: 0x3a4a30 });

        class AI {
            constructor(isEnemy) {
                this.isEnemy = isEnemy; this.mesh = new THREE.Group(); 
                
                const uniformMat = isEnemy ? enemyMat : allyMat; const helmetMat = isEnemy ? helmetMatEnemy : helmetMatAlly;
                this.bodyRoot = new THREE.Group(); this.mesh.add(this.bodyRoot);
                this.torso = new THREE.Group(); this.torso.position.y = 0.3; this.bodyRoot.add(this.torso);

                const torsoMesh = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.6, 0.25), uniformMat); torsoMesh.userData.ai = this; this.torso.add(torsoMesh);
                const backpack = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.4, 0.15), new THREE.MeshLambertMaterial({ color: 0x4a3a2a })); backpack.position.set(0, 0, 0.2); backpack.userData.ai = this; this.torso.add(backpack);

                this.headGroup = new THREE.Group(); this.headGroup.position.y = 0.35; this.torso.add(this.headGroup);
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.25, 0.2), skinMat); head.position.y = 0.125; head.name = "head"; head.userData.ai = this;
                const helmet = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.15, 0.25), helmetMat); helmet.position.y = 0.3; helmet.name = "head"; helmet.userData.ai = this;
                
                // Add Face Features
                const eyeMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
                const lEye = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.04, 0.02), eyeMat); lEye.position.set(-0.04, 0.16, 0.101); lEye.name = "head"; lEye.userData.ai = this;
                const rEye = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.04, 0.02), eyeMat); rEye.position.set(0.04, 0.16, 0.101); rEye.name = "head"; rEye.userData.ai = this;
                // Increased depth and pushed Z position forward so the mustache sticks out prominently
                const mustache = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.03, 0.04), new THREE.MeshLambertMaterial({color: 0x221100})); mustache.position.set(0, 0.10, 0.115); mustache.name = "head"; mustache.userData.ai = this;
                const mouth = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.02, 0.02), new THREE.MeshLambertMaterial({color: 0x3a0505})); mouth.position.set(0, 0.06, 0.101); mouth.name = "head"; mouth.userData.ai = this;
                
                this.headGroup.add(head, helmet, lEye, rEye, mustache, mouth);

                this.leftArm = new THREE.Group(); this.leftArm.position.set(-0.25, 0.2, 0); this.torso.add(this.leftArm);
                const lArmMesh = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.5, 0.12), uniformMat); lArmMesh.position.y = -0.2; lArmMesh.userData.ai = this; this.leftArm.add(lArmMesh);
                this.rightArm = new THREE.Group(); this.rightArm.position.set(0.25, 0.2, 0); this.torso.add(this.rightArm);
                const rArmMesh = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.5, 0.12), uniformMat); rArmMesh.position.y = -0.2; rArmMesh.userData.ai = this; this.rightArm.add(rArmMesh);

                const aiGun = new THREE.Group();
                const gunBody = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.08, 0.6), new THREE.MeshLambertMaterial({color: 0x222222}));
                const gunWood = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.06, 0.4), new THREE.MeshLambertMaterial({color: 0x4a2e15})); gunWood.position.z = 0.1;
                aiGun.add(gunBody, gunWood); aiGun.position.set(-0.05, -0.35, -0.2); this.rightArm.add(aiGun);

                this.leftLeg = new THREE.Group(); this.leftLeg.position.set(-0.12, 0, 0); this.bodyRoot.add(this.leftLeg);
                const lThighMesh = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.4, 0.15), uniformMat); lThighMesh.position.y = -0.2; lThighMesh.userData.ai = this; this.leftLeg.add(lThighMesh);
                this.leftCalf = new THREE.Group(); this.leftCalf.position.set(0, -0.4, 0); this.leftLeg.add(this.leftCalf);
                const lCalfMesh = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.45, 0.13), uniformMat); lCalfMesh.position.y = -0.2; lCalfMesh.userData.ai = this; this.leftCalf.add(lCalfMesh);

                this.rightLeg = new THREE.Group(); this.rightLeg.position.set(0.12, 0, 0); this.bodyRoot.add(this.rightLeg);
                const rThighMesh = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.4, 0.15), uniformMat); rThighMesh.position.y = -0.2; rThighMesh.userData.ai = this; this.rightLeg.add(rThighMesh);
                this.rightCalf = new THREE.Group(); this.rightCalf.position.set(0, -0.4, 0); this.rightLeg.add(this.rightCalf);
                const rCalfMesh = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.45, 0.13), uniformMat); rCalfMesh.position.y = -0.2; rCalfMesh.userData.ai = this; this.rightCalf.add(rCalfMesh);

                scene.add(this.mesh);
                this.dead = true; this.timer = Math.random() * 2; this.crouchT = 1.0; this.aimT = 0.0; this.walkTime = Math.random() * 10;
                
                this.respawn();
            }

            getDesiredCovers() {
                if (this.isEnemy) {
                    if (this.coverTier === 1) return enemyPathCovers;
                    if (this.coverTier === 2) return midCoversEnemy;
                    return this.trenchLevel === 'front' ? enemyCoversFront : enemyCoversBack;
                } else {
                    if (this.coverTier === 1) return allyPathCovers;
                    if (this.coverTier === 2) return midCoversAlly;
                    return this.trenchLevel === 'front' ? allyCoversFront : allyCoversBack;
                }
            }

            pickCover(isSpawning = false) {
                const peers = this.isEnemy ? enemies : allies;
                
                // Priority: Non-advancing soldiers should always try to man an empty turret first
                if (!this.isAdvancing) {
                    const backCovers = this.isEnemy ? enemyCoversBack : allyCoversBack;
                    
                    // Check if a friendly is already manning (or heading to) ANY turret on this side
                    let friendlyOnTurret = backCovers.some(c => {
                        if (!c.isTurret) return false;
                        if (c.turret.user && !c.turret.user.dead && (this.isEnemy ? c.turret.user.isEnemy : !c.turret.user.isEnemy)) return true;
                        if (peers.some(p => p !== this && !p.dead && p.targetCover === c)) return true;
                        return false;
                    });

                    if (!friendlyOnTurret) {
                        let emptyTurrets = backCovers.filter(c => {
                            if (!c.isTurret) return false;
                            if (c.turret.user && c.turret.user !== this && !c.turret.user.dead) return false; // In use by player or other AI
                            if (peers.some(p => p !== this && !p.dead && p.targetCover === c)) return false; // Claimed by another AI heading towards it
                            return true;
                        });
                        
                        if (emptyTurrets.length > 0) {
                            let safeTurrets = emptyTurrets;
                            if (isSpawning) {
                                let hiddenTurrets = emptyTurrets.filter(c => !isSpotVisibleToPlayer(c));
                                if (hiddenTurrets.length > 0) safeTurrets = hiddenTurrets;
                            }
                            this.targetCover = safeTurrets[Math.floor(Math.random() * safeTurrets.length)];
                            this.trenchLevel = 'back';
                            this.coverTier = 0;
                            return;
                        }
                    }
                }

                let covers = this.getDesiredCovers();
                
                // Exclude covers taken by alive peers, AND turrets currently occupied by ANYONE
                let available = covers.filter(c => {
                    if (c.isTurret && c.turret.user && c.turret.user !== this) return false;
                    return !peers.some(p => p !== this && !p.dead && p.targetCover === c);
                });
                
                if (available.length === 0) available = covers; // fallback if crowded
                
                if (isSpawning) {
                    // Filter out spots the player is actively looking at to prevent pop-in ONLY when spawning
                    let safeAvailable = available.filter(c => !isSpotVisibleToPlayer(c));
                    
                    // Only use the safe list if there are actually hidden spots available. 
                    if (safeAvailable.length > 0) {
                        available = safeAvailable;
                    }
                }
                
                this.targetCover = available[Math.floor(Math.random() * available.length)];
            }

            respawn() {
                this.hp = Math.floor(Math.random() * 2) + 1; 
                this.dead = false; this.mesh.visible = true; this.state = 'hidden';
                this.mesh.rotation.x = 0; // Ensure they are standing upright again after a death animation
                this.deathAnimT = 0;
                
                if (this.targetCover && this.targetCover.isTurret && this.targetCover.turret.user === this) {
                    this.targetCover.turret.user = null;
                }
                
                this.timer = 0.5 + Math.random(); this.target = null; this.targetCover = null; this.scanBaseYaw = this.isEnemy ? Math.PI : 0;
                this.shootDelay = 0; this.trenchLevel = Math.random() > 0.5 ? 'front' : 'back'; this.crouchT = 1.0; this.aimT = 0.0;
                
                const team = this.isEnemy ? enemies : allies;
                let livingCount = 0;
                let advancers = 0;
                for (let i = 0; i < team.length; i++) {
                    if (!team[i].dead && team[i] !== this) {
                        livingCount++;
                        if (team[i].isAdvancing) advancers++;
                    }
                }
                livingCount++; 
                
                // Keep higher push rate so the middle sees a steady stream of action
                this.isAdvancing = (advancers / livingCount) < 0.4;
                this.coverTier = 0;
                this.interruptedMove = false;

                this.pickCover(true);
                this.mesh.position.set(this.targetCover.x, getTerrainHeight(this.targetCover.x, this.targetCover.z), this.targetCover.z);
            }

            alert(attacker) {
                if (this.dead || !attacker || attacker.dead) return;
                
                if (!this.target || Math.random() < 0.8) {
                    // Don't target teammates from accidental crossfire
                    const isFriendlyFire = !attacker.isPlayer && (attacker.isEnemy === this.isEnemy);
                    
                    if (!isFriendlyFire) {
                        this.target = attacker;
                        let targetPos = attacker.isPlayer ? camera.getWorldPosition(new THREE.Vector3()) : attacker.mesh.position.clone();
                        this.scanBaseYaw = Math.atan2(targetPos.x - this.mesh.position.x, targetPos.z - this.mesh.position.z);
                    }
                }
                
                if (this.state === 'moving') {
                    this.state = 'aiming';
                    this.timer = 0.4 + Math.random() * 0.4;
                    this.shootDelay = 0;
                    this.interruptedMove = true; 
                } else if (this.state === 'hidden' && Math.random() < 0.8) {
                    this.state = 'popping';
                    this.timer = 0.2;
                } else if (this.state === 'aiming' || this.state === 'shooting') {
                    this.state = 'aiming';
                    this.timer = 0.5 + Math.random();
                }
            }

            takeDamage(amount, attacker) {
                if (this.dead || this.hp <= 0) return;
                
                // Massively reduce damage taken from other AI to prolong skirmishes
                if (attacker && !attacker.isPlayer) {
                    amount = 0.05; // Flat tiny amount. Takes 20-40 hits to kill another AI, stopping AoE multi-kills.
                }
                
                this.hp -= amount;
                
                if (this.hp <= 0) {
                    this.dead = true;
                    if (this.targetCover && this.targetCover.isTurret && this.targetCover.turret.user === this) {
                        this.targetCover.turret.user = null;
                    }
                    this.deathAnimT = 0.0;
                    this.corpseDelay = 2.0; // Wait 2s on ground before fading
                    this.timer = 3 + Math.random() * 2; // Respawn delay AFTER corpse vanishes
                    
                    if (attacker === playerAI && this.isEnemy) {
                        playerKills++;
                        document.getElementById('kill-count-indicator').innerText = `Kills: ${playerKills}`;
                    }
                } else if (attacker && !attacker.dead) {
                    // Prevent AI from mutiny-ing against each other due to accidental crossfire, but punish rogue players
                    if (attacker.isPlayer || attacker.isEnemy !== this.isEnemy) {
                        this.alert(attacker);
                    }
                    if (this.state === 'aiming' || this.state === 'popping') this.timer += 0.2;
                }
            }

            update(dt) {
                if (this.dead) {
                    // 1. Process death animation
                    if (this.deathAnimT < 1.0) {
                        this.deathAnimT += dt * 3.0; // Fall backward over ~0.33 seconds
                        if (this.deathAnimT > 1.0) this.deathAnimT = 1.0;
                        
                        // Pivot backward from the feet
                        this.mesh.rotation.x = this.deathAnimT * (-Math.PI / 2 + 0.1); 
                        // Sink body downward slightly to simulate lying flat and not pivoting stiffly
                        this.bodyRoot.position.y = 0.85 - (this.crouchT * 0.45) - (this.deathAnimT * 0.6); 
                        
                        // Animate limbs going limp and dropping weapon
                        this.rightArm.rotation.x += (0.1 - this.rightArm.rotation.x) * 10 * dt;
                        this.leftArm.rotation.x += (0.1 - this.leftArm.rotation.x) * 10 * dt;
                        this.rightArm.rotation.z += (0.2 - this.rightArm.rotation.z) * 10 * dt;
                        this.leftArm.rotation.z += (-0.2 - this.leftArm.rotation.z) * 10 * dt;
                        this.leftArm.rotation.y += (0 - this.leftArm.rotation.y) * 10 * dt;
                        
                        // Straighten legs out
                        this.leftLeg.rotation.x += (0 - this.leftLeg.rotation.x) * 10 * dt;
                        this.rightLeg.rotation.x += (0 - this.rightLeg.rotation.x) * 10 * dt;
                        this.leftCalf.rotation.x += (0 - this.leftCalf.rotation.x) * 10 * dt;
                        this.rightCalf.rotation.x += (0 - this.rightCalf.rotation.x) * 10 * dt;
                        
                        // Straighten torso out
                        this.crouchT += (0 - this.crouchT) * 5 * dt;
                        this.torso.rotation.x = this.crouchT * 0.4;
                        this.headGroup.rotation.x = -this.torso.rotation.x;
                        
                        this.mesh.position.y = getTerrainHeight(this.mesh.position.x, this.mesh.position.z);
                    } 
                    // 2. Wait for the corpse to remain on the battlefield
                    else if (this.corpseDelay > 0) {
                        this.corpseDelay -= dt;
                    } 
                    // 3. Remove corpse and enter respawn queue
                    else {
                        if (this.mesh.visible) {
                            this.mesh.visible = false;
                        }
                        
                        this.timer -= dt;
                        if (this.timer <= 0) {
                            if (gameMode === 'endless') {
                                this.respawn();
                            } else if (gameMode === 'elimination') {
                                if (this.isEnemy && enemyReserves > 0) {
                                    enemyReserves--;
                                    this.respawn();
                                } else if (!this.isEnemy && allyReserves > 0) {
                                    allyReserves--;
                                    this.respawn();
                                }
                            }
                        }
                    }
                    return;
                }

                this.timer -= dt;
                
                let closestThreat = null;
                let closestDistSq = 25; 
                
                const myForward = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), this.mesh.rotation.y);
                const opposingForce = this.isEnemy ? [...allies, playerAI] : enemies;
                
                for (let i = 0; i < opposingForce.length; i++) {
                    const threat = opposingForce[i];
                    if (!threat.dead) {
                        const tPos = threat.isPlayer ? playerRoot.position : threat.mesh.position;
                        let perceivedDistSq = this.mesh.position.distanceToSquared(tPos);
                        
                        const toThreat = tPos.clone().sub(this.mesh.position).normalize();
                        const dot = myForward.dot(toThreat);
                        
                        const isExposed = threat.isPlayer ? !isCrouched : (threat.state === 'moving' || threat.crouchT < 0.5);
                        
                        if (dot > 0.5) perceivedDistSq *= 0.4; 
                        if (isExposed) perceivedDistSq *= 0.4; 
                        
                        if (perceivedDistSq < closestDistSq) {
                            closestDistSq = perceivedDistSq;
                            closestThreat = threat;
                        }
                    }
                }

                if (closestThreat && this.target !== closestThreat) {
                    if (this.calculateExposure(closestThreat) > 0) {
                        this.target = closestThreat;
                        const tPos = closestThreat.isPlayer ? camera.getWorldPosition(new THREE.Vector3()) : closestThreat.mesh.position.clone();
                        this.scanBaseYaw = Math.atan2(tPos.x - this.mesh.position.x, tPos.z - this.mesh.position.z);
                        
                        if (this.state === 'moving') this.interruptedMove = true;
                        
                        // Prevent interrupting turret usage for every small threat if already engaged
                        if (this.state !== 'using_turret') {
                            this.state = 'aiming';
                            this.shootDelay = 0.2 + Math.random() * 0.2; 
                        }
                    }
                }

                let targetCrouch = 0.0; let targetAim = 0.0;

                switch (this.state) {
                    case 'moving':
                        targetCrouch = 0.5; 
                        const moveSpeed = 4.5;
                        
                        let destX = this.targetCover.x;
                        let destZ = this.targetCover.z;
                        let curX = this.mesh.position.x;
                        let curZ = this.mesh.position.z;
                        
                        let tempX = destX;
                        let tempZ = destZ;

                        const isHome = (z) => Math.abs(z) >= 17;
                        const isMid = (z) => Math.abs(z) <= 5;
                        const isPath = (z) => Math.abs(z) > 5 && Math.abs(z) < 17;
                        const getPathX = (x) => (Math.abs(x - (-40)) < Math.abs(x - 40)) ? -40 : 40;
                        
                        if (isHome(curZ) && !isHome(destZ)) {
                            let px = getPathX(curX);
                            if (Math.abs(curX - px) > 1.0) { tempX = px; tempZ = curZ; } 
                            else { tempX = px; tempZ = destZ; }
                        } else if (isMid(curZ) && !isMid(destZ)) {
                            let px = getPathX(curX);
                            if (Math.abs(curX - px) > 1.0) { tempX = px; tempZ = curZ; } 
                            else { tempX = px; tempZ = destZ; }
                        } else if (isPath(curZ)) {
                            if (isHome(destZ)) {
                                let safeZ = destZ > 0 ? 19.5 : -19.5;
                                if (Math.abs(destZ) > 26) safeZ = destZ > 0 ? 28 : -28; 
                                if (Math.abs(curZ - safeZ) > 1.0) { tempX = curX; tempZ = safeZ; } 
                                else { tempX = destX; tempZ = destZ; }
                            } else if (isMid(destZ)) {
                                if (Math.abs(curZ) > 1.0) { tempX = curX; tempZ = 0; } 
                                else { tempX = destX; tempZ = destZ; }
                            }
                        }
                        
                        let dx = tempX - curX;
                        let dz = tempZ - curZ;
                        let dist = Math.sqrt(dx*dx + dz*dz);
                        
                        let finalDx = destX - curX;
                        let finalDz = destZ - curZ;
                        let finalDist = Math.sqrt(finalDx*finalDx + finalDz*finalDz);
                        
                        if (finalDist < 0.2) {
                            if (this.targetCover && this.targetCover.isTurret) {
                                this.state = 'hidden'; 
                                this.timer = 0.1; // short delay before grabbing it
                            } else {
                                this.state = 'hidden';
                                this.timer = 0.2 + Math.random() * 0.3;
                            }
                        } else {
                            if (dist < 0.1) { dx = finalDx; dz = finalDz; dist = finalDist; } 
                            this.mesh.position.x += (dx/dist) * moveSpeed * dt;
                            this.mesh.position.z += (dz/dist) * moveSpeed * dt;
                            
                            const targetYaw = Math.atan2(dx, dz);
                            let diff = targetYaw - this.mesh.rotation.y;
                            while (diff < -Math.PI) diff += Math.PI * 2; while (diff > Math.PI) diff -= Math.PI * 2;
                            this.mesh.rotation.y += diff * 10 * dt;
                        }
                        break;
                    case 'hidden':
                        targetCrouch = 1.0; 
                        if (this.timer <= 0) { 
                            if (this.targetCover && this.targetCover.isTurret) {
                                if (!this.targetCover.turret.user || this.targetCover.turret.user === this) {
                                    this.state = 'using_turret';
                                } else {
                                    this.pickCover();
                                    this.state = 'moving';
                                }
                            } else {
                                this.state = 'popping'; 
                                this.timer = 0.3; 
                            }
                        }
                        break;
                    case 'using_turret':
                        targetCrouch = 0.0; targetAim = 0.0; // Stand behind
                        const t = this.targetCover.turret;
                        if (!t || (t.user && t.user !== this)) {
                            this.state = 'hidden'; break; // Turret was hijacked or lost
                        }
                        t.user = this; // Claim it
                        
                        // Lock AI position tightly to turret mount
                        this.mesh.position.x = t.mesh.position.x;
                        this.mesh.position.z = t.mesh.position.z + (this.isEnemy ? 1.0 : -1.0);
                        this.mesh.position.y = getTerrainHeight(this.mesh.position.x, this.mesh.position.z);
                        
                        // AI firing Logic for Turret
                        if (t.isReloading || t.ammo <= 0) {
                            // Wait for reload, don't try to shoot
                            this.shootDelay = 0.5 + Math.random() * 0.5;
                            t.swivel.rotation.y += (this.scanBaseYaw - t.swivel.rotation.y) * 2 * dt;
                            t.pitchGroup.rotation.x += (0 - t.pitchGroup.rotation.x) * 2 * dt;
                            this.mesh.rotation.y = t.swivel.rotation.y + Math.PI; 
                        } else if (this.target && !this.target.dead && this.checkLOS(this.target)) {
                            let targetPos = new THREE.Vector3();
                            if (this.target.isPlayer) camera.getWorldPosition(targetPos);
                            else targetPos.copy(this.target.mesh.position);
                            
                            // Align turret yaw (+PI because turret default barrel points to -Z)
                            const tx = targetPos.x - t.mesh.position.x;
                            const tz = targetPos.z - t.mesh.position.z;
                            let targetTurretYaw = Math.atan2(tx, tz) + Math.PI; 
                            
                            // Restrict AI rotation to 90 degrees left/right of the turret's default forward
                            let aiYawDiff = targetTurretYaw - t.baseYaw;
                            while (aiYawDiff < -Math.PI) aiYawDiff += Math.PI * 2; 
                            while (aiYawDiff > Math.PI) aiYawDiff -= Math.PI * 2;
                            if (aiYawDiff > Math.PI / 2) targetTurretYaw = t.baseYaw + Math.PI / 2;
                            if (aiYawDiff < -Math.PI / 2) targetTurretYaw = t.baseYaw - Math.PI / 2;

                            let tDiff = targetTurretYaw - t.swivel.rotation.y;
                            while (tDiff < -Math.PI) tDiff += Math.PI * 2; while (tDiff > Math.PI) tDiff -= Math.PI * 2;
                            t.swivel.rotation.y += tDiff * 5 * dt;
                            
                            // Align turret pitch
                            const tDist2d = Math.sqrt(tx*tx + tz*tz);
                            const ty = targetPos.y - (t.mesh.position.y + 0.3);
                            const targetTurretPitch = Math.atan2(ty, tDist2d); 
                            t.pitchGroup.rotation.x += (targetTurretPitch - t.pitchGroup.rotation.x) * 5 * dt;

                            // Sync AI body yaw to look like they are holding it
                            this.mesh.rotation.y = t.swivel.rotation.y + Math.PI; 
                            
                            if (this.shootDelay <= 0) {
                                // Ensure barrel is actually facing target before shooting
                                if (Math.abs(tDiff) < 0.2) {
                                    shootTurret(t, this);
                                    this.shootDelay = 1.8 + Math.random() * 0.4;
                                }
                            } else {
                                this.shootDelay -= dt;
                            }
                        } else {
                            this.target = this.findTarget();
                            this.shootDelay = 0.5 + Math.random() * 0.5;
                            // Idle swivel back to baseline
                            t.swivel.rotation.y += (this.scanBaseYaw - t.swivel.rotation.y) * 2 * dt;
                            t.pitchGroup.rotation.x += (0 - t.pitchGroup.rotation.x) * 2 * dt;
                            this.mesh.rotation.y = t.swivel.rotation.y + Math.PI; 
                        }
                        break;
                    case 'popping':
                        targetCrouch = 0.0; targetAim = 1.0;
                        if (this.target) this.aimAtTarget(dt);
                        if (this.timer <= 0) {
                            this.state = 'aiming'; this.timer = 0.5 + Math.random() * 1.0;
                            if (!this.target || this.target.dead || !this.checkLOS(this.target)) {
                                this.target = this.findTarget();
                            } else { this.shootDelay = 0.1 + Math.random() * 0.2; }
                        }
                        break;
                    case 'aiming':
                        targetCrouch = 0.0; targetAim = 1.0;
                        if (this.target && !this.target.dead && this.checkLOS(this.target)) {
                            this.aimAtTarget(dt);
                            if (this.shootDelay <= 0) {
                                this.state = 'shooting'; this.shotsFired = 0; this.shotsToFire = 3 + Math.floor(Math.random() * 4); this.timer = 0.1;
                            } else this.shootDelay -= dt;
                        } else {
                            this.target = this.findTarget(); this.shootDelay = 0.1 + Math.random() * 0.2;
                            this.mesh.rotation.y = this.scanBaseYaw + Math.sin(performance.now() * 0.002 + this.mesh.id) * 0.5;
                            if (this.timer <= 0) { this.state = 'hidden'; this.timer = 0.5 + Math.random(); }
                        }
                        break;
                    case 'shooting':
                        targetCrouch = 0.0; targetAim = 1.0;
                        if (!this.target || this.target.dead || !this.checkLOS(this.target)) { this.state = 'hidden'; this.timer = 0.5 + Math.random(); break; }
                        this.aimAtTarget(dt);
                        if (this.timer <= 0) {
                            this.shoot();
                            this.shotsFired++;
                            this.timer = 0.15 + Math.random() * 0.15;
                            if (this.shotsFired >= this.shotsToFire) {
                                if (this.interruptedMove) {
                                    this.interruptedMove = false;
                                    this.state = 'moving';
                                } else if (this.isAdvancing && this.coverTier < 2 && Math.random() < 0.95) {
                                    this.coverTier++;
                                    this.pickCover();
                                    this.state = 'moving';
                                } else if (this.isAdvancing && Math.random() < 0.2) {
                                    this.pickCover();
                                    this.state = 'moving';
                                } else {
                                    if (!this.isAdvancing) {
                                        const team = this.isEnemy ? enemies : allies;
                                        let living = 0, adv = 0;
                                        team.forEach(s => { if (!s.dead) { living++; if (s.isAdvancing) adv++; } });
                                        if (adv / living < 0.4) {
                                            this.isAdvancing = true; 
                                        }
                                    }
                                    
                                    this.state = 'hidden'; 
                                    this.timer = 0.5 + Math.random() * 1.0;
                                }
                            }
                        }
                        break;
                }

                this.crouchT += (targetCrouch - this.crouchT) * 10 * dt;
                this.aimT += (targetAim - this.aimT) * 12 * dt;

                this.bodyRoot.position.y = 0.85 - (this.crouchT * 0.45); 
                this.torso.rotation.x = this.crouchT * 0.4; this.headGroup.rotation.x = -this.torso.rotation.x; 

                let legSwing = 0; let armSwing = 0;
                if (this.state === 'moving') { this.walkTime += dt * 10; legSwing = Math.sin(this.walkTime) * 0.6; armSwing = Math.sin(this.walkTime) * 0.3; } else { this.walkTime = 0; }

                const squatThighRot = -1.2 * this.crouchT; const squatCalfRot = 2.0 * this.crouchT;
                this.leftLeg.rotation.z = 0.15 * this.crouchT; this.rightLeg.rotation.z = -0.15 * this.crouchT;
                this.leftLeg.rotation.x = squatThighRot + legSwing; this.leftCalf.rotation.x = squatCalfRot; if (legSwing < 0) this.leftCalf.rotation.x += legSwing * -0.5;
                this.rightLeg.rotation.x = squatThighRot - legSwing; this.rightCalf.rotation.x = squatCalfRot; if (legSwing > 0) this.rightCalf.rotation.x += -legSwing * -0.5;

                const aimRotRightX = -Math.PI / 2 + 0.1; const idleRotRightX = (this.crouchT * -0.2) + armSwing; this.rightArm.rotation.x = idleRotRightX + (aimRotRightX - idleRotRightX) * this.aimT;
                const aimRotLeftX = -Math.PI / 2 + 0.2; const idleRotLeftX = (this.crouchT * -0.2) - armSwing; this.leftArm.rotation.x = idleRotLeftX + (aimRotLeftX - idleRotLeftX) * this.aimT;
                this.rightArm.rotation.z = 0.15 * this.aimT; this.leftArm.rotation.z = -0.3 * this.aimT; this.leftArm.rotation.y = 0.4 * this.aimT;

                const peers = this.isEnemy ? enemies : allies;
                peers.forEach(peer => {
                    if (peer !== this && !peer.dead) {
                        const cdx = this.mesh.position.x - peer.mesh.position.x; const cdz = this.mesh.position.z - peer.mesh.position.z; const distSq = cdx*cdx + cdz*cdz;
                        if (distSq < 0.64 && distSq > 0.0001) {
                            const cDist = Math.sqrt(distSq); const overlap = 0.8 - cDist;
                            let nx = cdx / cDist; let nz = cdz / cDist; let tx = -nz; let tz = nx;
                            this.mesh.position.x += (nx * 0.6 + tx * 0.8) * overlap * 5 * dt; this.mesh.position.z += (nz * 0.6 + tz * 0.8) * overlap * 5 * dt;
                        }
                    }
                });

                let aiPos2D = { x: this.mesh.position.x, z: this.mesh.position.z };
                resolveObstacles(aiPos2D, 0.4);
                this.mesh.position.x = aiPos2D.x;
                this.mesh.position.z = aiPos2D.z;

                let minZ, maxZ;
                if (this.isEnemy) {
                    if (this.coverTier > 0) { minZ = -5.0; maxZ = 36.2; } 
                    else if (this.trenchLevel === 'front') { minZ = 18.2; maxZ = 21.8; }
                    else { minZ = 26.8; maxZ = 36.2; }
                } else {
                    if (this.coverTier > 0) { minZ = -36.2; maxZ = 5.0; }
                    else if (this.trenchLevel === 'front') { minZ = -21.8; maxZ = -18.2; }
                    else { minZ = -36.2; maxZ = -26.8; }
                }
                this.mesh.position.z = Math.max(minZ, Math.min(maxZ, this.mesh.position.z));

                if (this.state !== 'moving' && this.state !== 'using_turret' && this.targetCover && !this.targetCover.isTurret) {
                    this.mesh.position.x += (this.targetCover.x - this.mesh.position.x) * 2 * dt;
                    this.mesh.position.z += (this.targetCover.z - this.mesh.position.z) * 2 * dt;
                }

                this.mesh.position.y = getTerrainHeight(this.mesh.position.x, this.mesh.position.z);
            }

            calculateExposure(target) {
                const heightOffset = 1.55 - (this.crouchT * 0.45);
                const eyeStart = this.mesh.position.clone().add(new THREE.Vector3(0, heightOffset, 0));
                const pointsToCheck = [];
                
                if (target.isPlayer) {
                    const base = playerRoot.position.clone();
                    const pProne = isProne || slideTimer > 0;
                    pointsToCheck.push(base.clone().add(new THREE.Vector3(0, pProne ? 0.3 : (isCrouched ? 0.8 : 1.5), 0))); 
                    pointsToCheck.push(base.clone().add(new THREE.Vector3(0, pProne ? 0.15 : (isCrouched ? 0.4 : 1.0), 0))); 
                    pointsToCheck.push(base.clone().add(new THREE.Vector3(0, 0.2, 0)));                    
                } else {
                    const base = target.mesh.position.clone();
                    const cOffset = target.crouchT * 0.45;
                    pointsToCheck.push(base.clone().add(new THREE.Vector3(0, 1.55 - cOffset, 0)));         
                    pointsToCheck.push(base.clone().add(new THREE.Vector3(0, 1.0 - (cOffset * 0.5), 0)));  
                    pointsToCheck.push(base.clone().add(new THREE.Vector3(0, 0.3, 0)));                    
                }

                let hits = 0;
                
                for (let pt of pointsToCheck) {
                    const dir = pt.clone().sub(eyeStart).normalize();
                    const dist = eyeStart.distanceTo(pt);
                    raycaster.set(eyeStart, dir);
                    const intersects = raycaster.intersectObjects(worldMeshes, false);
                    
                    if (!(intersects.length > 0 && intersects[0].distance < dist)) {
                        hits++;
                    }
                }
                
                return hits / pointsToCheck.length; 
            }

            checkLOS(target) {
                return this.calculateExposure(target) > 0;
            }

            findTarget() {
                let targets = this.isEnemy ? [...allies, playerAI] : enemies;
                targets = targets.filter(t => !t.dead && t.hp > 0);
                if (targets.length === 0) return null;
                
                const myPos = this.mesh.position;
                const myForward = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), this.mesh.rotation.y);
                
                let bestTarget = null;
                let bestScore = Infinity;

                for (let i = 0; i < targets.length; i++) {
                    const target = targets[i];
                    const tPos = target.isPlayer ? playerRoot.position : target.mesh.position;
                    let score = tPos.distanceToSquared(myPos);
                    
                    if (score > 10000) continue; 
                    
                    const exposure = this.calculateExposure(target);
                    if (exposure === 0) continue; 

                    const toTarget = tPos.clone().sub(myPos).normalize();
                    const dot = myForward.dot(toTarget);
                    
                    if (dot > 0.5) score *= 0.3; 
                    else if (dot < 0) score *= 2.5;
                    
                    score /= exposure; 
                    
                    score *= (0.8 + Math.random() * 0.4); 

                    if (score < bestScore) {
                        bestScore = score;
                        bestTarget = target;
                    }
                }
                
                return bestTarget;
            }

            aimAtTarget(dt) {
                if (!this.target) return;
                let targetPos = new THREE.Vector3();
                if (this.target.isPlayer) camera.getWorldPosition(targetPos);
                else targetPos.copy(this.target.mesh.position);
                
                const targetYaw = Math.atan2(targetPos.x - this.mesh.position.x, targetPos.z - this.mesh.position.z);
                let diff = targetYaw - this.mesh.rotation.y;
                while (diff < -Math.PI) diff += Math.PI * 2; while (diff > Math.PI) diff -= Math.PI * 2;
                this.mesh.rotation.y += diff * 8 * dt;
            }

            shoot() {
                if (!this.target || this.target.dead) return;
                const heightOffset = 1.55 - (this.crouchT * 0.45);
                const eyeStart = this.mesh.position.clone().add(new THREE.Vector3(0, heightOffset, 0));
                const visualStart = this.mesh.position.clone().add(new THREE.Vector3(0, heightOffset - 0.2, 0));

                let targetPos = new THREE.Vector3();
                if (this.target.isPlayer) { camera.getWorldPosition(targetPos); targetPos.y -= 0.2; } 
                else { const targetHeightOffset = 1.55 - (this.target.crouchT * 0.45); targetPos.copy(this.target.mesh.position).add(new THREE.Vector3(0, targetHeightOffset, 0)); }
                
                const dir = targetPos.clone().sub(eyeStart).normalize(); const dist = eyeStart.distanceTo(targetPos);
                
                // Calculate spread, and massively decrease accuracy if shooting at another AI to prolong skirmishes
                let spread = 0.05 + (dist * 0.002);
                if (!this.target.isPlayer) {
                    spread *= 8.0; // Increased stormtrooper aim for AI vs AI
                }
                
                dir.x += (Math.random() - 0.5) * spread; dir.y += (Math.random() - 0.5) * spread; dir.z += (Math.random() - 0.5) * spread; dir.normalize();

                showMuzzleFlash(visualStart, dir); raycaster.set(eyeStart, dir);
                
                // Play local gunshot sound if the AI is close enough
                playPositionalSound(visualStart, 'gunshot'); 

                // Target everyone
                const hitTargets = [playerAI.mesh, ...allies.map(a => a.mesh), ...enemies.map(e => e.mesh)];
                const intersects = raycaster.intersectObjects([...worldMeshes, ...hitTargets], true);

                let hitDistance = 200;
                if (intersects.length > 0) {
                    const hit = intersects[0]; hitDistance = hit.distance;
                    playPositionalSound(hit.point, 'impact'); // Local impact snap if it lands near the player
                    
                    if (hit.object.userData.ai) {
                        const hitAI = hit.object.userData.ai;
                        if (hitAI.isPlayer) hitAI.takeDamage(1, this);
                        else hitAI.takeDamage(hit.object.name === "head" ? 99 : 1, this);
                    } else {
                        let normal = new THREE.Vector3(0, 1, 0);
                        if (hit.face) { normal.copy(hit.face.normal).applyMatrix3(new THREE.Matrix3().getNormalMatrix(hit.object.matrixWorld)).normalize(); }
                        createImpact(hit.point, normal);
                        
                        // Tracer Ricochet
                        if (Math.random() < 0.3) {
                            let reflection = dir.clone().sub(normal.clone().multiplyScalar(2 * dir.dot(normal))).normalize();
                            reflection.x += (Math.random() - 0.5) * 0.3; reflection.y += Math.random() * 0.4; reflection.z += (Math.random() - 0.5) * 0.3; reflection.normalize();
                            createTracer(hit.point, reflection, 60);
                            
                            // ONLY hear ricochets near the camera
                            if (camera.getWorldPosition(new THREE.Vector3()).distanceToSquared(hit.point) < 64.0) {
                                playSoundFile('whiz', 1.5 + Math.random() * 0.5, 0.2); 
                            }
                        }
                    }
                }

                if (Math.random() < 0.25) createTracer(visualStart, dir, hitDistance);

                const bulletRay = new THREE.Ray(eyeStart, dir);
                // Check for close calls against everyone
                const hitPool = [...allies, ...enemies, playerAI];
                let closestPt = new THREE.Vector3();
                hitPool.forEach(t => {
                    if (!t.dead) {
                        const posOffset = t.isPlayer ? ((isProne || slideTimer > 0) ? 0.15 : (isCrouched ? 0.4 : 1.0)) : (1.0 - (t.crouchT * 0.45));
                        const pos = t.isPlayer ? playerRoot.position.clone() : t.mesh.position.clone(); pos.y += posOffset;
                        
                        bulletRay.closestPointToPoint(pos, closestPt);
                        const distAlongRay = eyeStart.distanceTo(closestPt);
                        
                        // Ensure the bullet hasn't hit a wall BEFORE passing the target
                        if (distAlongRay < hitDistance + 1.0) {
                            const distSq = closestPt.distanceToSquared(pos);
                            if (!t.isPlayer) {
                                if (distSq < 16.0) t.alert(this); 
                            } else {
                                // Play the bullet whiz sound if it passes closely
                                if (distSq < 2.0) playNearMissSound(); 
                            }
                        }
                    }
                });
            }
        }

        const allies = [];
        const enemies = [];
        
        function spawnSoldiers(count) {
            allies.forEach(a => scene.remove(a.mesh)); enemies.forEach(e => scene.remove(e.mesh));
            allies.length = 0; enemies.length = 0;
            for (let i = 0; i < count; i++) { allies.push(new AI(false)); enemies.push(new AI(true)); }
        }
        spawnSoldiers(25);

        // --- GAME LOOP ---
        let lastTime = performance.now();
        let bobTime = 0;
        let breathTime = 0;
        let currentScreenShake = 0;

        function animate() {
            requestAnimationFrame(animate);

            const now = performance.now();
            let dt = (now - lastTime) / 1000;
            lastTime = now;
            if (dt > 0.1) dt = 0.1;
            
            breathTime += dt * 1.5; // Idle breathing timer

            if (!playerAI.dead && document.pointerLockElement) {
                if (gameMode === 'elimination') {
                    const aliveEnemies = enemies.filter(e => !e.dead).length;
                    document.getElementById('reserves-indicator').innerText = `Enemies Remaining: ${enemyReserves + aliveEnemies}`;
                    
                    if (aliveEnemies === 0 && enemyReserves <= 0) {
                        document.exitPointerLock();
                        document.getElementById('victory-screen').style.display = 'flex';
                        playerAI.dead = true; 
                        return; 
                    }
                }

                if (mgHeat > 0) {
                    mgHeat -= (mgOverheated ? 20 : 35) * dt;
                    if (mgHeat <= 0) { mgHeat = 0; mgOverheated = false; }
                }
                
                const heatContainer = document.getElementById('heatbar-container');
                if (currentWeaponIndex === 1 && !mountedTurret) {
                    heatContainer.style.display = 'block';
                    document.getElementById('heatbar').style.width = mgHeat + '%';
                    document.getElementById('heatbar').style.background = mgOverheated ? '#ff0000' : '#ff8800';
                } else heatContainer.style.display = 'none';

                const wep = weaponsData[currentWeaponIndex];
                
                // Allow shooting from hand weapon OR mounted turret
                if (keys.lmb) { 
                    if (mountedTurret) shootTurret(mountedTurret, playerAI);
                    else if (wep.type === 'auto' || lmbJustPressed) shootPlayer(); 
                }
                lmbJustPressed = false;

                // Enforce bolt action sniper delay independently
                const preBoltDelay = 250; // 0.25 seconds delay before pulling the bolt
                let isRechambering = false;
                let isActivelyBolting = false;
                let boltProgress = 0;

                if (currentWeaponIndex === 2 && sniperNeedsRechamber && !mountedTurret) {
                    isRechambering = true;
                    const timeSinceBoltStart = now - sniperRechamberStartTime;
                    
                    if (timeSinceBoltStart >= wep.fireRate) {
                        sniperNeedsRechamber = false; // Finished rechambering!
                        isRechambering = false;
                    } else if (timeSinceBoltStart >= preBoltDelay) {
                        isActivelyBolting = true;
                        boltProgress = (timeSinceBoltStart - preBoltDelay) / (wep.fireRate - preBoltDelay);
                    }
                }

                // Wait to pull out of scope until the bolt animation actually begins
                const isAiming = (keys.rmb || keys.space) && !isActivelyBolting; let targetFov = 75;
                document.getElementById('scope-overlay').style.display = (isAiming && currentWeaponIndex === 2 && !mountedTurret) ? 'flex' : 'none';
                
                let hideCrosshair = false;
                if (mountedTurret) {
                    hideCrosshair = isAiming; // Hide crosshair when aiming down turret sights
                } else {
                    hideCrosshair = isAiming || currentWeaponIndex === 2; // Standard weapon crosshair logic
                }
                document.getElementById('crosshair').style.display = hideCrosshair ? 'none' : 'block';

                // --- UI INTERACTION PROMPT ---
                const promptEl = document.getElementById('action-prompt');
                let canMount = false;
                if (!mountedTurret) {
                    turrets.forEach(t => {
                        const canClaim = !t.user || (t.user && !t.user.isEnemy && t.user !== playerAI);
                        if (canClaim && playerRoot.position.distanceTo(t.mesh.position) < 3.0) canMount = true;
                    });
                }
                
                if (mountedTurret) {
                    promptEl.style.display = 'block';
                    promptEl.innerText = "Press T to leave turret";
                } else if (canMount) {
                    promptEl.style.display = 'block';
                    promptEl.innerText = "Press T to use turret";
                } else {
                    promptEl.style.display = 'none';
                }

                // --- WEAPON SWAY & JOSTLE ---
                let bobOffsetX = 0;
                let bobOffsetY = 0;
                let targetWeaponRotY = 0;
                let targetWeaponRotZ = 0;
                let targetWeaponRotX = 0;
                let targetBoltRotZ = 0;
                let targetBoltPosZ = -0.05;

                const isMovingInput = (keys.w || keys.s || keys.a || keys.d) && document.pointerLockElement && !mountedTurret;
                
                if (slideTimer > 0 && !isAiming) {
                    targetWeaponRotX -= 0.15; // Dip weapon
                    targetWeaponRotZ += 0.15; // Tilt weapon sideways
                    bobOffsetX = Math.cos(bobTime) * 0.01;
                    bobOffsetY = Math.sin(bobTime) * 0.01;
                } else if (isMovingInput && !isAiming) {
                    let moveMult = 1.0;
                    if (isProne) moveMult = 0.3;
                    else if (isCrouched) moveMult = keys.shift ? 1.5 : 0.5; 
                    else if (keys.shift) moveMult = 2.5; 
                    
                    // Figure-8 motion for position
                    bobOffsetX = Math.cos(bobTime * 0.5) * 0.015 * moveMult;
                    bobOffsetY = Math.sin(bobTime) * 0.015 * moveMult;
                    
                    // Twist and tilt (rotation)
                    targetWeaponRotZ += Math.cos(bobTime * 0.5) * -0.05 * moveMult;
                    targetWeaponRotX += Math.sin(bobTime) * 0.02 * moveMult;
                    targetWeaponRotY += Math.cos(bobTime * 0.5) * 0.04 * moveMult;
                } else if (!isAiming && !mountedTurret) {
                    // Idle breathing sway
                    bobOffsetY = Math.sin(breathTime) * 0.004;
                    targetWeaponRotX += Math.sin(breathTime) * 0.005;
                }

                if (isAiming && !mountedTurret) {
                    if (currentWeaponIndex === 2) { targetFov = 75 / sniperZoomLevel; modelSniper.visible = false; } 
                    else { targetFov = 40; weaponContainer.position.lerp(new THREE.Vector3(0, wep.alignY, -0.25), 15 * dt); }
                } else if (!mountedTurret) {
                    if (currentWeaponIndex === 2) modelSniper.visible = true;
                    // Apply position sway offsets to the idle target coordinate
                    weaponContainer.position.lerp(new THREE.Vector3(0.2 + bobOffsetX, -0.2 + bobOffsetY, -0.4), 15 * dt);
                } else if (mountedTurret) {
                    targetFov = isAiming ? 40 : 75;
                }

                if (isActivelyBolting && !mountedTurret) {
                    // Add bolt-action tilt on top of the movement sway
                    targetWeaponRotZ += Math.sin(boltProgress * Math.PI) * 0.25; 
                    targetWeaponRotX += Math.sin(boltProgress * Math.PI) * -0.05; 
                    
                    // 4-stage bolt action animation
                    if (boltProgress < 0.15) {
                        // 1. Unlock (rotate up)
                        targetBoltRotZ = (boltProgress / 0.15) * (-Math.PI / 3);
                    } else if (boltProgress < 0.4) {
                        // 2. Pull back
                        targetBoltRotZ = -Math.PI / 3;
                        targetBoltPosZ = -0.05 + ((boltProgress - 0.15) / 0.25) * 0.15;
                    } else if (boltProgress < 0.65) {
                        // 3. Push forward
                        targetBoltRotZ = -Math.PI / 3;
                        targetBoltPosZ = 0.10 - ((boltProgress - 0.4) / 0.25) * 0.15;
                    } else if (boltProgress < 0.8) {
                        // 4. Lock (rotate down)
                        targetBoltRotZ = -Math.PI / 3 + ((boltProgress - 0.65) / 0.15) * (Math.PI / 3);
                    }
                }
                
                weaponContainer.rotation.z += (targetWeaponRotZ - weaponContainer.rotation.z) * 10 * dt;
                weaponContainer.rotation.x += (targetWeaponRotX - weaponContainer.rotation.x) * 10 * dt;
                weaponContainer.rotation.y += (targetWeaponRotY - (weaponContainer.rotation.y || 0)) * 10 * dt;
                
                // Animate the bolt handle
                snBoltGroup.rotation.z += (targetBoltRotZ - snBoltGroup.rotation.z) * 25 * dt;
                snBoltGroup.position.z += (targetBoltPosZ - snBoltGroup.position.z) * 25 * dt;

                camera.fov += (targetFov - camera.fov) * 15 * dt; camera.updateProjectionMatrix();
                weaponContainer.position.z += (-0.4 - weaponContainer.position.z) * 10 * dt;

                const isLeaningLeft = (keys.q || qToggled) && !mountedTurret;
                const isLeaningRight = (keys.e || eToggled) && !mountedTurret && !isLeaningLeft;

                const targetLeanZ = isLeaningLeft ? 0.25 : (isLeaningRight ? -0.25 : 0); 
                const targetLeanX = isLeaningLeft ? -0.5 : (isLeaningRight ? 0.5 : 0);
                
                leanObject.rotation.z += (targetLeanZ - leanObject.rotation.z) * 10 * dt; 
                
                if (typeof leanObject.userData.baseLocalX === 'undefined') leanObject.userData.baseLocalX = 0;
                leanObject.userData.baseLocalX += (targetLeanX - leanObject.userData.baseLocalX) * 10 * dt;

                let targetCamY = 0;
                let targetCamZ = 0;

                if (!mountedTurret) {
                    let leanLocalVec = new THREE.Vector3(leanObject.userData.baseLocalX, 0, 0);
                    leanLocalVec.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
                    let leanPos2D = { x: playerRoot.position.x + leanLocalVec.x, z: playerRoot.position.z + leanLocalVec.z };
                    
                    resolveObstacles(leanPos2D, 0.3); 
                    
                    let resolvedLocalVec = new THREE.Vector3(leanPos2D.x - playerRoot.position.x, 0, leanPos2D.z - playerRoot.position.z);
                    resolvedLocalVec.applyAxisAngle(new THREE.Vector3(0, 1, 0), -yaw);
                    
                    leanObject.position.x = resolvedLocalVec.x;
                    leanObject.position.z = resolvedLocalVec.z; 

                    const effProne = isProne || slideTimer > 0;
                    const targetEyeY = effProne ? 0.3 : (isCrouched ? 0.8 : 1.5); 
                    leanObject.position.y += (targetEyeY - leanObject.position.y) * 10 * dt;
                    
                    pitchObject.position.z += (0 - pitchObject.position.z) * 15 * dt; // Reset Z when unmounted
                    
                    playerAI.mesh.scale.y = effProne ? 0.2 : (isCrouched ? 0.5 : 1.0); 
                    playerAI.mesh.position.y = effProne ? 0.18 : (isCrouched ? 0.45 : 0.9); 
                    playerAI.mesh.position.x = leanObject.position.x; 
                    playerAI.mesh.position.z = leanObject.position.z; 

                    const moveDir = new THREE.Vector3();
                    if (keys.w) moveDir.z -= 1; if (keys.s) moveDir.z += 1; if (keys.a) moveDir.x -= 1; if (keys.d) moveDir.x += 1;
                    if (moveDir.lengthSq() > 0) moveDir.normalize(); moveDir.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);

                    let speed = 5; let bobSpeed = 8; let bobAmp = 0.05;
                    let slideVelocity = new THREE.Vector3(0,0,0);
                    
                    if (slideTimer > 0) {
                        slideTimer -= dt;
                        slideSpeed = Math.max(0, slideSpeed - 20 * dt); // Friction decay
                        slideVelocity.copy(slideDir).multiplyScalar(slideSpeed * dt);
                        speed = 1.5; bobSpeed = 0; bobAmp = 0; // Much lower steering control while sliding
                    } else if (isProne) {
                        speed = 1.125; bobSpeed = 4; bobAmp = 0.015; // Speed cut to 75% of previous (1.5)
                    } else if (isCrouched) {
                        if (keys.shift && !isAiming) { speed = 6.5; bobSpeed = 10; bobAmp = 0.035; } // Crouch sprint
                        else { speed = 3; bobSpeed = 6; bobAmp = 0.02; } // Crouch walk
                    } else {
                        if (keys.shift && !isAiming) { speed = 8; bobSpeed = 12; bobAmp = 0.05; } // Stand sprint
                        else { speed = 5; bobSpeed = 8; bobAmp = 0.05; } // Stand walk
                    }
                    const velocity = moveDir.multiplyScalar(speed * dt).add(slideVelocity);

                    if (moveDir.lengthSq() > 0 && document.pointerLockElement) {
                        bobTime += dt * bobSpeed; 
                        pitchObject.position.y = Math.sin(bobTime) * bobAmp;
                    } else if (document.pointerLockElement) {
                        // Idle camera breathing
                        pitchObject.position.y += (Math.sin(breathTime) * 0.015 - pitchObject.position.y) * 5 * dt;
                    } else {
                        pitchObject.position.y += (0 - pitchObject.position.y) * 10 * dt;
                    }

                    let nextPos = playerRoot.position.clone().add(velocity); const pr = 0.4; 
                    
                    if (nextPos.z < -36.3 + pr) nextPos.z = -36.3 + pr; if (nextPos.z > 36.3 - pr) nextPos.z = 36.3 - pr;
                    if (nextPos.x < -95 + pr) nextPos.x = -95 + pr; if (nextPos.x > 95 - pr) nextPos.x = 95 - pr;

                    let pPos2D = { x: nextPos.x, z: nextPos.z };
                    resolveObstacles(pPos2D, pr);
                    nextPos.x = pPos2D.x; nextPos.z = pPos2D.z;

                    const allLivingAI = [...allies, ...enemies].filter(a => !a.dead);
                    allLivingAI.forEach(ai => {
                        let dx = nextPos.x - ai.mesh.position.x; let dz = nextPos.z - ai.mesh.position.z; let distSq = dx * dx + dz * dz;
                        let minDist = 0.8; 
                        if (distSq < minDist * minDist && distSq > 0.0001) {
                            let dist = Math.sqrt(distSq); let overlap = minDist - dist;
                            nextPos.x += (dx / dist) * overlap; nextPos.z += (dz / dist) * overlap;
                        }
                    });

                    playerRoot.position.copy(nextPos);
                    playerRoot.position.y = getTerrainHeight(playerRoot.position.x, playerRoot.position.z);
                } else {
                    // Lock lean object dead-center onto the turret's swivel pivot point
                    leanObject.position.x += (0 - leanObject.position.x) * 15 * dt;
                    leanObject.position.z += (0 - leanObject.position.z) * 15 * dt;
                    leanObject.position.y += (0.1 - leanObject.position.y) * 15 * dt; // Match swivel height precisely
                    
                    // Reset pitchObject translation back to 0 so we pivot exactly around the swivel!
                    pitchObject.position.z += (0 - pitchObject.position.z) * 15 * dt;
                    pitchObject.position.y += (0 - pitchObject.position.y) * 15 * dt;
                    
                    // Move the actual camera backwards/upwards relative to the pivot
                    targetCamZ = isAiming ? 0.25 : 0.8; 
                    targetCamY = isAiming ? 0.105 : 0.35; // 0.105 aligns flawlessly with the iron sights line-of-sight
                
                    // Shift the internal camera position to orbit the pivot
                    camera.position.y += (targetCamY - camera.position.y) * 15 * dt;
                    camera.position.z += (targetCamZ - camera.position.z) * 15 * dt;
                    
                    // Lock player root exactly to the base of the turret so their pivots match perfectly
                    playerRoot.position.copy(mountedTurret.mesh.position);
                    
                    // Sync the heavy turret mesh directly to the player's mouse view
                    mountedTurret.swivel.rotation.y = yaw;
                    mountedTurret.pitchGroup.rotation.x = pitch;
                }
                
                // --- UPDATE WEAPON UI ---
                const weaponInd = document.getElementById('weapon-indicator');
                if (mountedTurret) {
                    if (mountedTurret.isReloading) {
                        weaponInd.innerText = `Turret [RELOADING...] (${mountedTurret.ammo}/${mountedTurret.maxAmmo})`;
                        weaponInd.style.color = '#ffffaa';
                    } else {
                        weaponInd.innerText = `Turret (${mountedTurret.ammo}/${mountedTurret.maxAmmo})`;
                        weaponInd.style.color = mountedTurret.ammo === 0 ? '#ff5555' : 'white';
                    }
                } else {
                    weaponInd.innerText = weaponsData[currentWeaponIndex].name;
                    weaponInd.style.color = 'white';
                }

                // Animate ALL turrets recoiling back and handle reloading logic
                turrets.forEach(t => {
                    t.pitchGroup.position.z += (0 - t.pitchGroup.position.z) * 10 * dt; // Recoil recovery
                    
                    if (t.isReloading) {
                        // Only actively progress the reload if someone is manning it
                        if (t.user) {
                            t.reloadTimer -= dt;
                            t.dummyShell.visible = true;
                            
                            // Animate shell falling into the chamber
                            let loadProgress = 1.0 - (t.reloadTimer / 0.6);
                            if (loadProgress > 1) loadProgress = 1;
                            if (loadProgress < 0) loadProgress = 0;
                            t.dummyShell.position.set(0, 0.4 - (loadProgress * 0.3), 0.1); 
                            
                            if (t.reloadTimer <= 0) {
                                t.ammo++;
                                playSoundFile('gunshot', 3.0, 0.05); // High pitched metallic clack
                                t.pitchGroup.rotation.z = (Math.random() - 0.5) * 0.15; // Visual wobble
                                
                                if (t.ammo >= t.maxAmmo) {
                                    t.isReloading = false;
                                    t.dummyShell.visible = false;
                                } else {
                                    t.reloadTimer = 0.6; // Start next shell
                                }
                            }
                        } else {
                            // Hide shell mid-air if user dismounts
                            t.dummyShell.visible = false;
                        }
                        
                        // Return wobble to 0 smoothly
                        t.pitchGroup.rotation.z += (0 - t.pitchGroup.rotation.z) * 10 * dt;
                    } else {
                        t.dummyShell.visible = false;
                        t.pitchGroup.rotation.z += (0 - t.pitchGroup.rotation.z) * 10 * dt;
                        
                        // Auto-start reload if empty and someone is on it
                        if (t.ammo <= 0 && t.user) {
                            t.isReloading = true;
                            t.reloadTimer = 0.6;
                        }
                    }
                });
            }

            const hurtEl = document.getElementById('hurt-overlay');
            if (!playerAI.dead && parseFloat(hurtEl.style.opacity) > 0) hurtEl.style.opacity = Math.max(0, parseFloat(hurtEl.style.opacity) - dt);

            if (fpFlashMaterial.opacity > 0) { fpFlashMaterial.opacity = Math.max(0, fpFlashMaterial.opacity - dt * 20); fpFlashLight.intensity = Math.max(0, fpFlashLight.intensity - dt * 40); }

            explosions.forEach(exp => {
                if (exp.life > 0) {
                    exp.life -= dt;
                    let t = 1.0 - (exp.life / exp.maxLife); 
                    if (t > 1) t = 1;
                    
                    // Explosive shockwave scaling (fast pop, slow end)
                    const scale = 0.5 + (Math.pow(t, 0.4) * 9.0); 
                    exp.mesh.scale.set(scale, scale, scale);
                    
                    // Dramatic color shift: White hot -> Bright Orange -> Dark Smoky Red
                    if (t < 0.15) exp.mesh.material.color.setHex(0xffffff);
                    else if (t < 0.4) exp.mesh.material.color.setHex(0xff8800);
                    else exp.mesh.material.color.setHex(0x330800);
                    
                    exp.mesh.material.opacity = (1.0 - t) * 0.9;
                    exp.light.intensity = Math.max(0, 20.0 * (1.0 - (t * 1.5))); // Flash fades quickly
                    
                    if (exp.life <= 0) {
                        exp.mesh.visible = false;
                        exp.light.intensity = 0;
                    }
                }
            });

            impacts.forEach(imp => {
                if (imp.life > 0) { imp.life -= dt; imp.mesh.scale.addScalar(dt * 10); imp.mesh.material.opacity = (imp.life / 0.2); if (imp.life <= 0) imp.mesh.visible = false; }
            });

            allies.forEach(a => a.update(dt)); enemies.forEach(e => e.update(dt));

            flashes.forEach(f => { if (f.life > 0) { f.life -= dt; if (f.life <= 0) f.mesh.material.opacity = 0; } });

            tracers.forEach(t => {
                if (t.life > 0) {
                    t.life -= dt; const moveDist = 150 * dt; t.traveled += moveDist;
                    if (t.traveled >= t.maxDist) { t.life = 0; t.mesh.visible = false; } 
                    else { t.mesh.position.add(t.dir.clone().multiplyScalar(moveDist)); }
                }
            });

            // Update Ambient Particles
            const positions = ashParticles.geometry.attributes.position.array;
            for(let i = 0; i < ashCount * 3; i += 3) {
                positions[i] -= dt * 1.5; // Drift left
                positions[i+1] -= dt * 0.8; // Fall down
                if(positions[i] < -100) positions[i] = 100;
                if(positions[i+1] < -2) positions[i+1] = 10 + Math.random() * 5;
            }
            ashParticles.geometry.attributes.position.needsUpdate = true;

            // Decay Horizon Lights
            horizonLights.forEach(hl => {
                if(hl.timer > 0) {
                    hl.timer -= dt;
                    if(hl.timer <= 0) hl.light.intensity = 0;
                } else {
                    hl.light.intensity = Math.max(0, hl.light.intensity - dt * 20);
                }
            });

            // Process Shell Shock Audio Effects
            if (audioCtx && masterFilter) {
                if (shellShockTimer > 0) {
                    shellShockTimer -= dt;
                    // Instantly muffle when shocked
                    masterFilter.frequency.setTargetAtTime(300, audioCtx.currentTime, 0.1);
                    masterGain.gain.setTargetAtTime(0.4, audioCtx.currentTime, 0.1);
                } else {
                    // Slowly recover hearing
                    masterFilter.frequency.setTargetAtTime(22000, audioCtx.currentTime, 2.0);
                    masterGain.gain.setTargetAtTime(1.0, audioCtx.currentTime, 2.0);
                }
            }

            // Apply temporary screen shake offsets
            let sx = 0, sy = 0, sz = 0;
            if (currentScreenShake > 0) {
                currentScreenShake -= dt;
                sx = (Math.random() - 0.5) * currentScreenShake;
                sy = (Math.random() - 0.5) * currentScreenShake;
                sz = (Math.random() - 0.5) * currentScreenShake;
                camera.position.x += sx;
                camera.position.y += sy;
                camera.position.z += sz;
            }

            renderer.render(scene, camera);

            // Immediately revert camera shake offsets so true logical aiming isn't ruined
            if (sx !== 0 || sy !== 0 || sz !== 0) {
                camera.position.x -= sx;
                camera.position.y -= sy;
                camera.position.z -= sz;
            }
        }

        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        animate();

    </script>
</body>
</html>
